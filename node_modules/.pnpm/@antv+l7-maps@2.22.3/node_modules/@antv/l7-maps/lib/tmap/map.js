"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Core = require("@antv/l7-core");
var _l7Map = require("@antv/l7-map");
var _l7Utils = require("@antv/l7-utils");
var _glMatrix = require("gl-matrix");
var _webMercatorViewport = _interopRequireDefault(require("../lib/web-mercator-viewport"));
var _BaseMapService = _interopRequireDefault(require("../utils/BaseMapService"));
var _maploader = _interopRequireDefault(require("./maploader"));
const _excluded = ["id", "mapInstance", "center", "token", "version", "libraries", "minZoom", "maxZoom", "rotation", "pitch", "mapSize", "logoVisible"];
function loadStyles(css, doc) {
  var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== 'undefined' && wx !== null && (typeof wx.request !== 'undefined' || typeof wx.miniProgram !== 'undefined');
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc) doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName('head')[0];
  if (!head) {
    head = doc.createElement('head');
    var body = doc.body || doc.getElementsByTagName('body')[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement('style');
  style.type = 'text/css';
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles(`img[src*='//mapapi.qq.com/web/jsapi/logo/logo_def.png'],.logo-text
{
  display: none !important;
}

.tencent-map > canvas + div {
  z-index: 3 !important;
}
`);
const TMAP_API_KEY = 'OB4BZ-D4W3U-B7VVO-4PJWW-6TKDJ-WPB77';
const BMAP_VERSION = '1.exp';
const EventMap = {
  mapmove: 'center_changed',
  camerachange: ['drag', 'pan', 'rotate', 'pitch', 'zoom'],
  zoomchange: 'zoom',
  dragging: 'drag'
};

// TODO: 基于抽象类 BaseMap 实现，补全缺失方法，解决类型问题
class TMapService extends _BaseMapService.default {
  constructor(...args) {
    super(...args);
    // @ts-ignore
    (0, _defineProperty2.default)(this, "viewport", null);
    (0, _defineProperty2.default)(this, "evtCbProxyMap", new Map());
    (0, _defineProperty2.default)(this, "handleCameraChanged", () => {
      // Trigger map change event
      this.emit('mapchange');
      // resync
      const map = this.map;
      // @ts-ignore
      const {
        lng,
        lat
      } = map.getCenter();
      const option = {
        center: [lng, lat],
        // @ts-ignore
        viewportHeight: map.getContainer().clientHeight,
        // @ts-ignore
        viewportWidth: map.getContainer().clientWidth,
        // @ts-ignore
        bearing: map.getHeading(),
        // @ts-ignore
        pitch: map.getPitch(),
        // @ts-ignore
        zoom: map.getZoom() - 1
      };
      this.viewport.syncWithMapCamera(option);
      this.updateCoordinateSystemService();
      this.cameraChangedCallback(this.viewport);
    });
  }
  init() {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      var _this$map$controlMana;
      _this.viewport = new _webMercatorViewport.default();

      // TODO: Handle initial config
      const _this$config = _this.config,
        {
          id,
          mapInstance,
          center = [121.30654632240122, 31.25744185633306],
          token = TMAP_API_KEY,
          version = BMAP_VERSION,
          libraries = [],
          minZoom = 3,
          maxZoom = 18,
          rotation = 0,
          pitch = 0,
          mapSize = 10000,
          logoVisible = true
        } = _this$config,
        rest = (0, _objectWithoutProperties2.default)(_this$config, _excluded);
      if (!(window.TMap || mapInstance)) {
        yield _maploader.default.load({
          key: token,
          version,
          libraries
        });
      }
      if (mapInstance) {
        // If there's already a map instance, maybe not setting any other configurations
        _this.map = mapInstance;
        _this.$mapContainer = _this.map.getContainer();
        if (logoVisible === false) {
          _this.hideLogo();
        }
      } else {
        if (!id) {
          throw Error('No container id specified');
        }
        const mapContainer = _l7Utils.DOM.getContainer(id);
        const map = new TMap.Map(mapContainer, (0, _objectSpread2.default)({
          maxZoom,
          minZoom,
          rotation,
          pitch,
          showControl: false,
          // Tencent use (Lat, Lng) while center is (Lng, Lat)
          center: new TMap.LatLng(center[1], center[0])
        }, rest));

        // @ts-ignore
        _this.map = map;
        // @ts-ignore
        _this.$mapContainer = map.getContainer();
        if (logoVisible === false) {
          _this.hideLogo();
        }
      }

      // Set tencent map canvas element position as absolute
      // @ts-ignore
      _this.map.canvasContainer.style.position = 'absolute';
      // @ts-ignore
      _this.map.drawContainer.classList.add('tencent-map');

      // Set tencent map control layer dom index
      // @ts-ignore
      const controlParentContainer = (_this$map$controlMana = _this.map.controlManager.controlContainer) === null || _this$map$controlMana === void 0 ? void 0 : _this$map$controlMana.parentNode;
      if (controlParentContainer) {
        controlParentContainer.style.zIndex = 2;
      }
      _this.simpleMapCoord.setSize(mapSize);

      // May be find an integrated event replacing following events
      _this.map.on('drag', _this.handleCameraChanged);
      _this.map.on('pan', _this.handleCameraChanged);
      _this.map.on('rotate', _this.handleCameraChanged);
      _this.map.on('pitch', _this.handleCameraChanged);
      _this.map.on('zoom', _this.handleCameraChanged);

      // Trigger camera change after init
      _this.handleCameraChanged();
    })();
  }
  destroy() {
    this.map.destroy();
  }
  onCameraChanged(callback) {
    this.cameraChangedCallback = callback;
  }
  addMarkerContainer() {
    const container = this.map.getContainer();
    this.markerContainer = _l7Utils.DOM.create('div', 'l7-marker-container', container);
    this.markerContainer.setAttribute('tabindex', '-1');
    this.markerContainer.style.zIndex = '2';
  }
  getMarkerContainer() {
    return this.markerContainer;
  }

  // MapEvent
  on(type, handle) {
    if (_l7Core.MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.on(type, handle);
    } else {
      const onProxy = eventName => {
        let cbProxyMap = this.evtCbProxyMap.get(eventName);
        if (!cbProxyMap) {
          this.evtCbProxyMap.set(eventName, cbProxyMap = new Map());
        }
        if (cbProxyMap.get(handle)) {
          return;
        }
        const handleProxy = (...args) => {
          if (args[0] && typeof args[0] === 'object' && !args[0].lngLat && !args[0].lnglat) {
            args[0].lngLat = args[0].latlng || args[0].latLng;
          }
          handle(...args);
        };
        cbProxyMap.set(handle, handleProxy);
        this.map.on(eventName, handleProxy);
      };
      if (Array.isArray(EventMap[type])) {
        EventMap[type].forEach(eventName => {
          onProxy(eventName || type);
        });
      } else {
        onProxy(EventMap[type] || type);
      }
    }
  }
  off(type, handle) {
    if (_l7Core.MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.off(type, handle);
      return;
    }
    const offProxy = eventName => {
      var _this$evtCbProxyMap$g, _this$evtCbProxyMap$g2;
      const handleProxy = (_this$evtCbProxyMap$g = this.evtCbProxyMap.get(type)) === null || _this$evtCbProxyMap$g === void 0 ? void 0 : _this$evtCbProxyMap$g.get(handle);
      if (!handleProxy) {
        return;
      }
      (_this$evtCbProxyMap$g2 = this.evtCbProxyMap.get(eventName)) === null || _this$evtCbProxyMap$g2 === void 0 || _this$evtCbProxyMap$g2.delete(handle);
      this.map.off(eventName, handleProxy);
    };
    if (Array.isArray(EventMap[type])) {
      EventMap[type].forEach(eventName => {
        offProxy(eventName || type);
      });
    } else {
      offProxy(EventMap[type] || type);
    }
  }
  once() {
    throw new Error('Method not implemented.');
  }

  // get dom
  getContainer() {
    return this.map.getContainer();
  }
  getSize() {
    // @ts-ignore
    return [this.map.width, this.map.height];
  }

  // get map status method
  getMinZoom() {
    // @ts-ignore
    return this.map.transform._minZoom;
  }
  getMaxZoom() {
    // @ts-ignore
    return this.map.transform._maxZoom;
  }

  // get map params
  getType() {
    return 'tmap';
  }
  getZoom() {
    return this.map.getZoom();
  }
  getCenter() {
    const {
      lng,
      lat
    } = this.map.getCenter();
    return {
      lng,
      lat
    };
  }
  getPitch() {
    return this.map.getPitch();
  }
  getRotation() {
    return this.map.getRotation();
  }
  getBounds() {
    const ne = this.map.getBounds().getNorthEast();
    const sw = this.map.getBounds().getSouthWest();
    return [[sw.lng, sw.lat], [ne.lng, ne.lat]];
  }
  getMapContainer() {
    return this.map.getContainer();
  }
  getMapCanvasContainer() {
    var _this$map$getContaine;
    return (_this$map$getContaine = this.map.getContainer()) === null || _this$map$getContaine === void 0 ? void 0 : _this$map$getContaine.getElementsByTagName('canvas')[0];
  }
  getCanvasOverlays() {
    var _this$getMapCanvasCon;
    return (_this$getMapCanvasCon = this.getMapCanvasContainer()) === null || _this$getMapCanvasCon === void 0 || (_this$getMapCanvasCon = _this$getMapCanvasCon.nextSibling) === null || _this$getMapCanvasCon === void 0 ? void 0 : _this$getMapCanvasCon.firstChild;
  }
  getMapStyleConfig() {
    // return this.getMap()
    throw new Error('Method not implemented.');
  }
  setBgColor(color) {
    this.bgColor = color;
  }
  setMapStyle(styleId) {
    this.map.setMapStyleId(styleId);
  }

  // control with raw map
  setRotation(rotation) {
    this.map.setRotation(rotation);
  }
  zoomIn() {
    this.map.setZoom(this.getZoom() + 1);
  }
  zoomOut() {
    this.map.setZoom(this.getZoom() - 1);
  }
  panTo([lng, lat]) {
    this.map.panTo(new TMap.LatLng(lat, lng));
  }
  panBy(x, y) {
    this.map.panBy([x, y]);
  }
  fitBounds(bound, fitBoundsOptions) {
    const [sw, ne] = bound;
    const swLatLng = new TMap.LatLng(sw[1], sw[0]);
    const neLatLng = new TMap.LatLng(ne[1], ne[0]);
    const bounds = new TMap.LatLngBounds(swLatLng, neLatLng);
    // @ts-ignore
    this.map.fitBounds(bounds, fitBoundsOptions);
  }
  setZoomAndCenter(zoom, [lng, lat]) {
    this.map.setCenter(new TMap.LatLng(lat, lng));
    this.map.setZoom(zoom);
  }
  setCenter([lng, lat]) {
    this.map.setCenter(new TMap.LatLng(lat, lng));
  }
  setPitch(pitch) {
    this.map.setPitch(pitch);
  }
  setZoom(zoom) {
    this.map.setZoom(zoom);
  }
  setMapStatus(option) {
    Object.keys(option).map(status => {
      switch (status) {
        case 'doubleClickZoom':
          this.map.setDoubleClickZoom(!!option.doubleClickZoom);
          break;
        case 'dragEnable':
          this.map.setDraggable(!!option.dragEnable);
          break;
        case 'rotateEnable':
          // @ts-ignore
          this.map.setRotatable(!!option.rotateEnable);
          break;
        case 'zoomEnable':
          this.map.setDoubleClickZoom(!!option.zoomEnable);
          this.map.setScrollable(!!option.zoomEnable);
          break;
        case 'keyboardEnable':
        case 'resizeEnable':
        case 'showIndoorMap':
          throw Error('Options may bot be supported');
        default:
      }
    });
  }

  // coordinates methods
  meterToCoord([centerLon, centerLat], [outerLon, outerLat]) {
    const metreDistance = TMap.geometry.computeDistance([new TMap.LatLng(centerLat, centerLon), new TMap.LatLng(outerLat, outerLon)]);
    const [x1, y1] = this.lngLatToCoord([centerLon, centerLat]);
    const [x2, y2] = this.lngLatToCoord([outerLon, outerLat]);
    const coordDistance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    return coordDistance / metreDistance;
  }
  pixelToLngLat([x, y]) {
    // Since tecent map didn't provide the reverse method for transforming from pixel to lnglat
    // It had to be done by calculate the relative distance in container coordinates
    const {
      lng: clng,
      lat: clat
    } = this.map.getCenter();
    const {
      x: centerPixelX,
      y: centerPixelY
    } = this.lngLatToPixel([clng, clat]);
    const {
      x: centerContainerX,
      y: centerContainerY
    } = this.lngLatToContainer([clng, clat]);
    const {
      lng,
      lat
    } = this.map.unprojectFromContainer(new TMap.Point(centerContainerX + (x - centerPixelX), centerContainerY + (y - centerPixelY)));
    return this.containerToLngLat([lng, lat]);
  }
  lngLatToPixel([lng, lat]) {
    // @ts-ignore
    const {
      x,
      y
    } = this.map.projectToWorldPlane(new TMap.LatLng(lat, lng));
    return {
      x,
      y
    };
  }
  containerToLngLat([x, y]) {
    const {
      lng,
      lat
    } = this.map.unprojectFromContainer(new TMap.Point(x, y));
    return {
      lng,
      lat
    };
  }
  lngLatToContainer([lng, lat]) {
    // @ts-ignore
    const {
      x,
      y
    } = this.map.projectToContainer(new TMap.LatLng(lat, lng));
    return {
      x,
      y
    };
  }
  lngLatToCoord([lng, lat]) {
    // TODO: Perhaps need to check the three.js coordinates
    const {
      x,
      y
    } = this.lngLatToPixel([lng, lat]);
    return [x, -y];
  }
  lngLatToCoords(list) {
    return list.map(item => Array.isArray(item[0]) ? this.lngLatToCoords(item) : this.lngLatToCoord(item));
  }
  lngLatToMercator(lnglat, altitude) {
    // Use built in mercator tools due to Tencent not provided related methods
    const {
      x = 0,
      y = 0,
      z = 0
    } = _l7Map.MercatorCoordinate.fromLngLat(lnglat, altitude);
    return {
      x,
      y,
      z
    };
  }
  getModelMatrix(lnglat, altitude, rotate, scale = [1, 1, 1]) {
    const flat = this.viewport.projectFlat(lnglat);
    // @ts-ignore
    const modelMatrix = _glMatrix.mat4.create();
    _glMatrix.mat4.translate(modelMatrix, modelMatrix, _glMatrix.vec3.fromValues(flat[0], flat[1], altitude));
    _glMatrix.mat4.scale(modelMatrix, modelMatrix, _glMatrix.vec3.fromValues(scale[0], scale[1], scale[2]));
    _glMatrix.mat4.rotateX(modelMatrix, modelMatrix, rotate[0]);
    _glMatrix.mat4.rotateY(modelMatrix, modelMatrix, rotate[1]);
    _glMatrix.mat4.rotateZ(modelMatrix, modelMatrix, rotate[2]);
    return modelMatrix;
  }
  getCustomCoordCenter() {
    throw new Error('Method not implemented.');
  }
  exportMap(type) {
    const renderCanvas = this.getMapCanvasContainer();
    const layersPng = type === 'jpg' ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL('image/jpeg') : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL('image/png');
    return layersPng;
  }

  // Method on earth mode
  rotateY() {
    throw new Error('Method not implemented.');
  }
  hideLogo() {
    const container = this.map.getContainer();
    if (!container) {
      return;
    }
    _l7Utils.DOM.addClass(container, 'tmap-contianer--hide-logo');
  }
}
exports.default = TMapService;