"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _BaseMapService = _interopRequireDefault(require("../utils/BaseMapService"));
var _l7Core = require("@antv/l7-core");
var _l7Map = require("@antv/l7-map");
var _webMercatorViewport = _interopRequireDefault(require("../lib/web-mercator-viewport"));
var _maploader = require("./maploader");
let mapdivCount = 0;
const EventMap = {
  zoomchange: ['Ge']
};

// TODO: 基于抽象类 BaseMap 实现，补全缺失方法，解决类型问题
class TdtMapService extends _BaseMapService.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "viewport", null);
    (0, _defineProperty2.default)(this, "evtCbProxyMap", new Map());
    // @ts-ignore
    (0, _defineProperty2.default)(this, "sceneContainer", void 0);
    (0, _defineProperty2.default)(this, "handleCameraChanged", () => {
      this.emit('mapchange');
      const map = this.map;
      const {
        lng,
        lat
      } = this.map.getCenter();
      const option = {
        center: [lng, lat],
        // @ts-ignore
        viewportHeight: map.getContainer().clientHeight,
        // @ts-ignore
        viewportWidth: map.getContainer().clientWidth,
        // @ts-ignore
        bearing: 360,
        // @ts-ignore
        pitch: 0,
        // @ts-ignore
        zoom: map.getZoom() - 1
      };
      if (this.viewport) {
        this.viewport.syncWithMapCamera(option);
        this.updateCoordinateSystemService();
        this.cameraChangedCallback(this.viewport);
      }
    });
  }
  // 不直接用自带的marker的div，因为会收到天地图缩放时visibility变成hidden的影响
  addMarkerContainer() {
    const container = this.map.getContainer();
    const div = this.markerContainer = document.createElement('div');
    container.appendChild(div);
    // div.classList.add('l7-marker-container');
    // div.classList.add('leaflet-layer');
    // div.classList.add('leaflet-zoom-animated');
    div.setAttribute('tabindex', '-1');
    div.id = 'tdt-L7-marker';
    div.style.position = 'absolute';
    div.style.left = '';
    div.style.top = '';
    div.style.zIndex = '600';
    div.style.width = '0px';
    div.style.height = '0px';
    div.style.overflow = 'visible';
    return;
  }
  getMarkerContainer() {
    return this.markerContainer;
  }
  onCameraChanged(callback) {
    this.cameraChangedCallback = callback;
  }
  resize(ev) {
    this.sceneContainer.style.width = ev.newSize.x + 'px';
    this.sceneContainer.style.height = ev.newSize.y + 'px';
  }
  update() {
    const bounds = this.map.getBounds();
    const {
      x,
      y
    } = this.map.lngLatToLayerPoint({
      lng: bounds.getSouthWest().lng,
      lat: bounds.getNorthEast().lat
    });
    this.sceneContainer.style.transition = '';
    this.sceneContainer.style.transformOrigin = 'center';
    this.sceneContainer.style.transform = `translate3d(${x}px, ${y}px, 0px) scale(1)`;
    //更新marker容器的位置 实现平移
    this.markerContainer.style.transition = '';
    this.markerContainer.style.transformOrigin = 'center';
    this.markerContainer.style.transform = `translate3d(${-x}px, ${-y}px, 0px) scale(1)`;
    // @ts-ignore
    this.sceneContainer._tdt_pos = new T.Point(x, y);
    this.handleCameraChanged();
  }
  getZoomScale(toZoom, fromZoom) {
    // TODO replace with universal implementation after refactoring projections
    const crs = this.map.options.IW;
    fromZoom = fromZoom === undefined ? this.map.getZoom() : fromZoom;
    return crs.scale(toZoom) / crs.scale(fromZoom);
  }
  zoomStartUpdate(ev) {
    // T._Q :DomUtil
    // this.map.options.IW.qW:map.project
    // GQ:multiply aQ:add DQ:substract
    // 都是混淆后的方法,后续需要考虑讲这些方法都实现了,避免api更新后方法名发生改变
    const center = ev.center;
    const zoom = ev.zoom;
    const scale = this.getZoomScale(zoom, this.map.getZoom());

    // @ts-ignore
    const position = T._Q.getPosition(this.sceneContainer);
    const viewHalf = this.map.getSize().GQ(0.5);
    const currentCenterPoint = this.map.options.IW.qW(this.map.getCenter(), zoom);
    const destCenterPoint = this.map.options.IW.qW(center, zoom);
    const centerOffset = destCenterPoint.DQ(currentCenterPoint);
    // @ts-ignore
    const topLeftOffset = new T.Point(viewHalf.x, viewHalf.y).GQ(-scale);
    topLeftOffset.aQ(position);
    topLeftOffset.aQ(viewHalf);
    topLeftOffset.DQ(centerOffset);
    this.sceneContainer.style.transform = `translate3d(${topLeftOffset.x}px,${topLeftOffset.y}px,0px) scale(${scale})`;
    this.sceneContainer.style.transformOrigin = '0 0';
    this.sceneContainer.style.transition = 'transform 0.25s cubic-bezier(0,0,0.25,1)';
    this.handleCameraChanged();
  }
  getOverlayContainer() {
    var _this$map$getPanes;
    const overlayPane = (_this$map$getPanes = this.map.getPanes()) === null || _this$map$getPanes === void 0 ? void 0 : _this$map$getPanes.overlayPane;
    const container = document.createElement('div');
    overlayPane.parentElement.appendChild(container);
    container.id = 'tdt-L7';
    const size = this.map.getSize();
    container.style.zIndex = '200'; //置于上层
    container.style.width = `${size.x}px`;
    container.style.height = `${size.y}px`;
    // @ts-ignore
    this.sceneContainer = container;
    return container;
  }
  init() {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      _this.viewport = new _webMercatorViewport.default();
      const {
        id,
        mapInstance,
        center = [121.30654632240122, 31.25744185633306],
        token = 'b15e548080c79819617367d3f6095c69',
        minZoom = 1,
        maxZoom = 18,
        zoom = 3
      } = _this.config;

      // @ts-ignore
      if (!window.T) {
        yield (0, _maploader.load)({
          tk: token
        });
      }
      if (mapInstance) {
        _this.map = mapInstance;
        // @ts-ignore
        _this.map.centerAndZoom(new window.T.LngLat(center[0], center[1]), zoom);
        _this.$mapContainer = _this.map.getContainer();

        // @ts-ignore
        const point = new window.T.LngLat(center[0], center[1]);
        _this.map.centerAndZoom(point, zoom);
        _this.setMinZoom(minZoom);
        _this.setMaxZoom(maxZoom);
      } else {
        if (!id) {
          throw Error('No container id specified');
        }
        _this.$mapContainer = _this.creatMapContainer(id);
        // @ts-ignore
        const map = new T.Map(_this.$mapContainer, {
          // @ts-ignore
          center: window.T.LngLat(center[0], center[1]),
          minZoom,
          maxZoom,
          zoom,
          projection: 'EPSG:900913'
        });
        _this.map = map;
        // @ts-ignore
        const control = new window.T.Control.Zoom();
        map.addControl(control);
      }
      const container = _this.map.getContainer();
      const tdtPanes = container.querySelector('.tdt-pane');
      tdtPanes.style.zIndex = 1;
      _this.handleCameraChanged();
      _this.map.on('move', _this.update, _this);
      //对应leaflet中的zoomanim
      _this.map.on('Ge', _this.zoomStartUpdate, _this);
      _this.map.on('resize', _this.resize, _this);
    })();
  }
  destroy() {
    return;
  }

  // MapEvent
  on(type, handle) {
    if (_l7Core.MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.on(type, handle);
    } else {
      const onProxy = eventName => {
        let cbProxyMap = this.evtCbProxyMap.get(eventName);
        if (!cbProxyMap) {
          this.evtCbProxyMap.set(eventName, cbProxyMap = new Map());
        }
        if (cbProxyMap.get(handle)) {
          return;
        }
        const handleProxy = (...args) => {
          if (args[0] && typeof args[0] === 'object' && !args[0].lngLat && !args[0].lnglat) {
            args[0].lngLat = args[0].latlng || args[0].latLng;
            args[0].map = this.map;
          }
          handle(...args);
        };
        cbProxyMap.set(handle, handleProxy);
        this.map.on(eventName, handleProxy);
      };
      if (Array.isArray(EventMap[type])) {
        EventMap[type].forEach(eventName => {
          onProxy(eventName || type);
        });
      } else {
        onProxy(EventMap[type] || type);
      }
    }
  }
  off(type, handle) {
    if (_l7Core.MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.off(type, handle);
      return;
    }
    const offProxy = eventName => {
      var _this$evtCbProxyMap$g, _this$evtCbProxyMap$g2;
      const handleProxy = (_this$evtCbProxyMap$g = this.evtCbProxyMap.get(type)) === null || _this$evtCbProxyMap$g === void 0 ? void 0 : _this$evtCbProxyMap$g.get(handle);
      if (!handleProxy) {
        return;
      }
      (_this$evtCbProxyMap$g2 = this.evtCbProxyMap.get(eventName)) === null || _this$evtCbProxyMap$g2 === void 0 || _this$evtCbProxyMap$g2.delete(handle);
      this.map.off(eventName, handleProxy);
    };
    if (Array.isArray(EventMap[type])) {
      EventMap[type].forEach(eventName => {
        offProxy(eventName || type);
      });
    } else {
      offProxy(EventMap[type] || type);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  once(type, handler) {
    throw new Error('Method not implemented.');
  }

  // get dom

  getMapContainer() {
    return this.map.getContainer();
  }
  getType() {
    return 'tdtmap';
  }
  getMapCanvasContainer() {
    var _this$map$getContaine;
    // tdt-container
    return (_this$map$getContaine = this.map.getContainer()) === null || _this$map$getContaine === void 0 ? void 0 : _this$map$getContaine.getElementsByClassName('tdt-container')[0];
  }

  // get mapStatus method
  getSize() {
    const size = this.map.getSize();
    return [size.x, size.y];
  }

  // get mapStatus method

  getZoom() {
    return this.map.getZoom();
  }
  setZoom(zoom) {
    return this.map.setZoom(zoom);
  }
  getCenter() {
    return this.map.getCenter();
  }
  setCenter(lnglat) {
    // @ts-ignore
    const lngLat = window.T.LngLat(lnglat[0], lnglat[1]);
    this.map.centerAndZoom(lngLat, this.map.getZoom());
  }
  setZoomAndCenter(zoom, center) {
    // @ts-ignore
    const lngLat = window.T.LngLat(center[0], center[1]);
    this.map.centerAndZoom(lngLat, zoom);
  }
  getPitch() {
    return 0;
  }
  getRotation() {
    return 0;
  }
  setRotation(rotation) {
    this.map.setBearing(rotation);
  }
  zoomIn(option, eventData) {
    this.map.zoomIn(option, eventData);
  }
  zoomOut(option, eventData) {
    this.map.zoomOut(option, eventData);
  }
  panTo(p) {
    this.map.panTo(p);
  }
  panBy(x = 0, y = 0) {
    // @ts-ignore
    this.map.panBy([x, y]);
  }
  fitBounds(bound) {
    const [sw, ne] = bound;
    // @ts-ignore
    this.map.setViewport([new window.T.LngLat(sw[0], sw[1]), new window.T.LngLat(ne[0], ne[1])]);
  }
  setMaxZoom(max) {
    this.map.setMaxZoom(max);
  }
  setMinZoom(min) {
    this.map.setMinZoom(min);
  }
  setMapStatus(option) {
    if (option.doubleClickZoom === true) {
      this.map.enableDoubleClickZoom();
    }
    if (option.doubleClickZoom === false) {
      this.map.disableDoubleClickZoom();
    }
    if (option.dragEnable === false) {
      this.map.disableDrag();
    }
    if (option.dragEnable === true) {
      this.map.enableDrag();
    }
    if (option.keyboardEnable === false) {
      this.map.disableKeyboard();
    }
    if (option.keyboardEnable === true) {
      this.map.enableKeyboard();
    }
    if (option.zoomEnable === false) {
      this.map.disableScrollWheelZoom();
    }
    if (option.zoomEnable === true) {
      this.map.enableScrollWheelZoom();
    }
  }

  // coordinates methods

  getModelMatrix() {
    throw new Error('Method not implemented.');
  }
  pixelToLngLat([x, y]) {
    const lngLat = this.map.layerPointToLngLat({
      x,
      y
    });
    return {
      lng: lngLat.lng,
      lat: lngLat.lat
    };
  }
  lngLatToPixel([lng, lat]) {
    const pixel = this.map.lngLatToLayerPoint({
      lng,
      lat
    });
    return {
      x: pixel.x,
      y: pixel.y
    };
  }
  containerToLngLat([x, y]) {
    const point = this.map.containerPointToLngLat({
      x,
      y
    });
    return {
      lng: point.lng,
      lat: point.lat
    };
  }
  lngLatToContainer([lng, lat]) {
    const overlayPixel = this.map.lngLatToContainerPoint({
      lat,
      lng
    });
    return {
      x: overlayPixel.x,
      y: overlayPixel.y
    };
  }
  lngLatToCoord([lng, lat]) {
    const pixelCoord = this.lngLatToPixel([lng, lat]);
    return [pixelCoord.x, pixelCoord.y];
  }
  lngLatToCoords(list) {
    return list.map(item => Array.isArray(item[0]) ? this.lngLatToCoords(item) : this.lngLatToCoord(item));
  }
  getBounds() {
    const latlngBound = this.map.getBounds();
    const sw = latlngBound.getSouthWest(),
      ne = latlngBound.getNorthEast();
    return [[sw.lng, sw.lat], [ne.lng, ne.lat]];
  }
  lngLatToMercator(lnglat, altitude) {
    // Use built in mercator tools due to Tencent not provided related methods
    const {
      x = 0,
      y = 0,
      z = 0
    } = _l7Map.MercatorCoordinate.fromLngLat(lnglat, altitude);
    return {
      x,
      y,
      z
    };
  }
  getCustomCoordCenter() {
    throw new Error('Method not implemented.');
  }
  creatMapContainer(id) {
    let $wrapper = id;
    if (typeof id === 'string') {
      $wrapper = document.getElementById(id);
    }
    const $tdtmapdiv = document.createElement('div');
    $tdtmapdiv.style.cssText += `
      position: absolute;
      top: 0;
      height: 100%;
      width: 100%;
    `;
    $tdtmapdiv.id = 'l7_tdt_div' + mapdivCount++;
    $wrapper.appendChild($tdtmapdiv);
    return $tdtmapdiv;
  }

  // public exportMap() {}
  //
  // private hideLogo() {}
}
exports.default = TdtMapService;