"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Core = require("@antv/l7-core");
var _l7Utils = require("@antv/l7-utils");
var _glMatrix = require("gl-matrix");
var _webMercatorViewport = _interopRequireDefault(require("../lib/web-mercator-viewport"));
var _BaseMapService = _interopRequireDefault(require("../utils/BaseMapService"));
var _utils = require("../utils/utils");
var _bmapglloader = _interopRequireDefault(require("./bmapglloader"));
const _excluded = ["id", "center", "zoom", "token", "mapInstance", "version", "mapSize", "minZoom", "maxZoom"];
function loadStyles(css, doc) {
  var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== 'undefined' && wx !== null && (typeof wx.request !== 'undefined' || typeof wx.miniProgram !== 'undefined');
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc) doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName('head')[0];
  if (!head) {
    head = doc.createElement('head');
    var body = doc.body || doc.getElementsByTagName('body')[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement('style');
  style.type = 'text/css';
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles(`.BMap_cpyCtrl .anchorBL {
  display: none !important;
}

.anchorBL {
  display: none !important;
}
`);
const EventMap = {
  mapmove: 'moving',
  contextmenu: 'rightclick',
  camerachange: 'update',
  zoomchange: 'zoomend'
};
const BMAP_API_KEY = 'zLhopYPPERGtpGOgimcdKcCimGRyyIsh';
const BMAP_VERSION = '1.0';

// TODO: 基于抽象类 BaseMap 实现，补全缺失方法，解决类型问题
class BMapService extends _BaseMapService.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "viewport", void 0);
    (0, _defineProperty2.default)(this, "styleConfig", {
      normal: []
    });
    (0, _defineProperty2.default)(this, "currentStyle", 'normal');
    // 事件回调代理
    (0, _defineProperty2.default)(this, "evtCbProxyMap", new Map());
    (0, _defineProperty2.default)(this, "handleCameraChanged", () => {
      this.emit('mapchange');
      const map = this.getMap();
      const {
        lng,
        lat
      } = map.getCenter();
      const option = {
        center: [lng, lat],
        viewportHeight: map.getContainer().clientHeight,
        viewportWidth: map.getContainer().clientWidth,
        bearing: 360 - map.getHeading(),
        pitch: map.getTilt(),
        zoom: map.getZoom() - 1.75
      };
      this.viewport.syncWithMapCamera(option);
      this.updateCoordinateSystemService();
      this.cameraChangedCallback(this.viewport);
    });
  }
  getMap() {
    return this.map;
  }
  setBgColor(color) {
    this.bgColor = color;
  }
  init() {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      _this.viewport = new _webMercatorViewport.default();
      const _this$config = _this.config,
        {
          id,
          center = [121.30654632240122, 31.25744185633306],
          zoom = 12,
          token = BMAP_API_KEY,
          mapInstance,
          version = BMAP_VERSION,
          mapSize = 10000,
          minZoom = 0,
          maxZoom = 21
        } = _this$config,
        rest = (0, _objectWithoutProperties2.default)(_this$config, _excluded);
      _this.viewport = new _webMercatorViewport.default();
      _this.version = version;
      _this.simpleMapCoord.setSize(mapSize);
      if (!(window.BMapGL || mapInstance)) {
        yield _bmapglloader.default.load({
          key: token,
          // 申请好的Web端开发者Key，首次调用 load 时必填
          version: BMAP_VERSION // 指定要加载的 JSAPI 的gl版本，缺省时默认为 1.0
        });
      }
      if (mapInstance) {
        // @ts-ignore
        _this.map = mapInstance;
        _this.$mapContainer = _this.map.getContainer();
        const point = new BMapGL.Point(center[0], center[1]);
        // false，表示用户未执行centerAndZoom进行地图初始渲染
        // @ts-ignore
        if (!_this.map.isLoaded()) {
          _this.map.centerAndZoom(point, zoom);
        }
        _this.initMapByConfig(_this.config);
        _this.map.on('update', _this.handleCameraChanged);
      } else {
        const mapConstructorOptions = (0, _objectSpread2.default)({
          enableWheelZoom: true,
          minZoom,
          maxZoom
        }, rest);
        if (token === BMAP_API_KEY) {
          console.warn(`%c${_this.configService.getSceneWarninfo('MapToken')}!`, 'color: #873bf4;font-weigh:900;font-size: 16px;');
        }
        if (!id) {
          throw Error('No container id specified');
        }
        const mapContainer = _l7Utils.DOM.getContainer(id);

        // 存储控件等容器，百度地图实例会被卸载掉，所以实例化后需要重新挂载
        // @ts-ignore
        let mapChildNodes = [...mapContainer.childNodes];
        // @ts-ignore
        const map = new BMapGL.Map(mapContainer, mapConstructorOptions);
        _this.$mapContainer = map.getContainer();
        mapChildNodes.forEach(child => {
          _this.$mapContainer.appendChild(child);
        });
        // @ts-ignore
        mapChildNodes = null;

        // @ts-ignore
        _this.map = map;
        const point = new BMapGL.Point(center[0], center[1]);
        _this.map.centerAndZoom(point, zoom);
        _this.initMapByConfig(_this.config);
        // 监听地图相机事件
        // @ts-ignore
        map.on('update', _this.handleCameraChanged);
      }
    })();
  }
  destroy() {
    this.getMap().destroy();
  }
  onCameraChanged(callback) {
    this.cameraChangedCallback = callback;
  }

  // tslint:disable-next-line:no-empty
  addMarkerContainer() {}
  getMarkerContainer() {
    return this.map.getPanes().markerPane;
  }
  getCanvasOverlays() {
    var _this$getMap$getConta;
    return (_this$getMap$getConta = this.getMap().getContainer().querySelector('#platform')) === null || _this$getMap$getConta === void 0 ? void 0 : _this$getMap$getConta.lastChild;
  }

  // MapEvent // 定义事件类型
  on(type, handle) {
    if (_l7Core.MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.on(type, handle);
      return;
    }
    let cbProxyMap = this.evtCbProxyMap.get(type);
    if (!cbProxyMap) {
      this.evtCbProxyMap.set(type, cbProxyMap = new Map());
    }

    // 忽略重复监听回调
    if (cbProxyMap.get(handle)) {
      return;
    }

    // 对事件对象的经纬度进行统一处理l7需要的
    const handleProxy = (...args) => {
      if (args[0] && typeof args[0] === 'object' && !args[0].lngLat && !args[0].lnglat) {
        args[0].lngLat = args[0].latlng || args[0].latLng;
      }
      handle(...args);
    };
    cbProxyMap.set(handle, handleProxy);
    this.map.on(EventMap[type] || type, handleProxy);
  }
  off(type, handle) {
    var _this$evtCbProxyMap$g, _this$evtCbProxyMap$g2;
    if (_l7Core.MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.off(type, handle);
      return;
    }
    const handleProxy = (_this$evtCbProxyMap$g = this.evtCbProxyMap.get(type)) === null || _this$evtCbProxyMap$g === void 0 ? void 0 : _this$evtCbProxyMap$g.get(handle);
    if (!handleProxy) {
      return;
    }
    (_this$evtCbProxyMap$g2 = this.evtCbProxyMap.get(type)) === null || _this$evtCbProxyMap$g2 === void 0 || _this$evtCbProxyMap$g2.delete(handle);
    this.map.off(EventMap[type] || type, handleProxy);
  }
  once(type, handler) {
    this.eventEmitter.once(type, handler);
  }
  getContainer() {
    return this.getMap().getContainer();
  }
  getSize() {
    const size = this.getMap().getSize();
    return [size.width, size.height];
  }
  // 百度地图缩放等级
  getMinZoom() {
    return this.map.getMinZoom();
  }
  getMaxZoom() {
    return this.map.getMaxZoom();
  }

  // get map params
  getType() {
    return 'bmap';
  }
  getZoom() {
    return this.getMap().getZoom();
  }
  getCenter(options) {
    if (options !== null && options !== void 0 && options.padding) {
      const originCenter = this.getCenter();
      const padding = (0, _utils.toPaddingOptions)(options.padding);
      const px = this.lngLatToPixel([originCenter.lng, originCenter.lat]);
      const offsetPx = [(padding.right - padding.left) / 2, (padding.bottom - padding.top) / 2];
      const newCenter = this.pixelToLngLat([px.x - offsetPx[0], px.y - offsetPx[1]]);
      return newCenter;
    }
    const center = this.map.getCenter();
    return {
      lng: center.lng,
      lat: center.lat
    };
  }
  getPitch() {
    return this.getMap().getTilt();
  }
  getRotation() {
    return 360 - this.getMap().getHeading();
  }
  getBounds() {
    const bounds = this.getMap().getBounds();
    const ne = bounds.getNorthEast();
    const sw = bounds.getSouthWest();
    return [[sw.lng, sw.lat], [ne.lng, ne.lat]];
  }
  getMapContainer() {
    return this.getMap().getContainer();
  }
  getMapCanvasContainer() {
    return this.getMap().getContainer();
  }
  getMapStyleConfig() {
    return this.styleConfig;
  }
  getMapStyleValue(name) {
    return this.styleConfig[name];
  }
  setMapStyle(style) {
    if (this.currentStyle === style) {
      return;
    }
    const styleVal = Array.isArray(style) ? style : this.styleConfig[style] || style;
    if (Array.isArray(styleVal)) {
      this.map.setMapStyleV2({
        styleJson: styleVal
      });
      this.currentStyle = style;
      return;
    }
    if (typeof styleVal === 'string') {
      this.map.setMapStyleV2({
        styleId: styleVal
      });
      this.currentStyle = style;
      return;
    }
  }
  setRotation(rotation) {
    this.getMap().setHeading(rotation);
  }
  zoomIn() {
    this.getMap().zoomIn();
  }
  zoomOut() {
    this.getMap().zoomOut();
  }
  panTo(p) {
    this.getMap().panTo(new BMapGL.Point(p[0], p[1]));
  }
  panBy(x, y) {
    this.getMap().panBy(x, y);
  }
  fitBounds(bound, fitBoundsOptions) {
    this.map.setViewport(bound.map(item => new BMapGL.Point(item[0], item[1])), fitBoundsOptions);
  }
  setZoomAndCenter(zoom, [lng, lat]) {
    this.getMap().centerAndZoom(new BMapGL.Point(lng, lat), zoom + 1.75);
  }
  setCenter([lng, lat], options) {
    let newCenter = {
      lng,
      lat
    };
    if (options !== null && options !== void 0 && options.padding) {
      const padding = (0, _utils.toPaddingOptions)(options.padding);
      const px = this.lngLatToPixel([lng, lat]);
      const offsetPx = [(padding.right - padding.left) / 2, (padding.bottom - padding.top) / 2];
      newCenter = this.pixelToLngLat([px.x + offsetPx[0], px.y + offsetPx[1]]);
    }
    this.getMap().setCenter(new BMapGL.Point(newCenter.lng, newCenter.lat));
  }
  setPitch(pitch) {
    this.getMap().setTilt(pitch);
  }
  setZoom(zoom) {
    this.getMap().setZoom(zoom);
  }
  setMapStatus(option) {
    const map = this.getMap();
    Object.keys(option).map(status => {
      switch (status) {
        case 'doubleClickZoom':
          option.doubleClickZoom ? map.enableDoubleClickZoom() : map.disableDoubleClickZoom();
          break;
        case 'dragEnable':
          option.dragEnable ? map.enableDragging() : map.disableDragging();
          break;
        case 'keyboardEnable':
          option.keyboardEnable ? map.enableKeyboard() : map.disableKeyboard();
          break;
        case 'resizeEnable':
          option.resizeEnable ? map.enableAutoResize() : map.disableAutoResize();
          break;
        case 'rotateEnable':
          if (option.rotateEnable) {
            map.enableRotate();
            map.enableRotateGestures();
          } else {
            map.disableRotate();
            map.disableRotateGestures();
          }
          break;
        case 'zoomEnable':
          if (option.zoomEnable) {
            this.map.enableDoubleClickZoom();
            this.map.enableScrollWheelZoom();
            this.map.enablePinchToZoom();
          } else {
            this.map.disableDoubleClickZoom();
            this.map.disableScrollWheelZoom();
            this.map.disablePinchToZoom();
          }
          break;
        case 'showIndoorMap':
          map.setDisplayOptions({
            indoor: !!option.showIndoorMap
          });
          break;
        default:
      }
    });
  }

  // coordinates methods
  meterToCoord(center, outer) {
    const metreDistance = this.getMap().getDistance(new BMapGL.Point(...center), new BMapGL.Point(...outer));
    const [x1, y1] = this.lngLatToCoord(center);
    const [x2, y2] = this.lngLatToCoord(outer);
    const coordDistance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    return coordDistance / metreDistance;
  }
  pixelToLngLat([x, y]) {
    const lngLat = this.getMap().pixelToPoint(new BMapGL.Pixel(x, y));
    return {
      lng: lngLat.lng,
      lat: lngLat.lat
    };
  }
  lngLatToPixel([lng, lat]) {
    const pixel = this.getMap().pointToPixel(new BMapGL.Point(lng, lat));
    return {
      x: pixel.x,
      y: pixel.y
    };
  }
  containerToLngLat([x, y]) {
    const point = this.getMap().overlayPixelToPoint(new BMapGL.Pixel(x, y));
    return {
      lng: point.lng,
      lat: point.lat
    };
  }
  lngLatToContainer([lng, lat]) {
    const overlayPixel = this.getMap().pointToOverlayPixel(new BMapGL.Point(lng, lat));
    return {
      x: overlayPixel.x,
      y: overlayPixel.y
    };
  }
  lngLatToCoord([lng, lat]) {
    const {
      x,
      y
    } = this.getMap().pointToPixel(new BMapGL.Point(lng, lat));
    return [x, -y];
  }
  lngLatToCoords(list) {
    return list.map(item => Array.isArray(item[0]) ? this.lngLatToCoords(item) : this.lngLatToCoord(item));
  }
  lngLatToMercator([lng, lat], altitude) {
    const [McLng, McLat] = this.getMap().lnglatToMercator(lng, lat);
    return {
      x: McLng,
      y: McLat,
      z: altitude
    };
  }
  getModelMatrix(lnglat, altitude, rotate, scale = [1, 1, 1]) {
    const flat = this.viewport.projectFlat(lnglat);
    const modelMatrix = _glMatrix.mat4.create();
    _glMatrix.mat4.translate(modelMatrix, modelMatrix, _glMatrix.vec3.fromValues(flat[0], flat[1], altitude));
    _glMatrix.mat4.scale(modelMatrix, modelMatrix, _glMatrix.vec3.fromValues(scale[0], scale[1], scale[2]));
    _glMatrix.mat4.rotateX(modelMatrix, modelMatrix, rotate[0]);
    _glMatrix.mat4.rotateY(modelMatrix, modelMatrix, rotate[1]);
    _glMatrix.mat4.rotateZ(modelMatrix, modelMatrix, rotate[2]);
    return modelMatrix;
  }
  getCustomCoordCenter() {
    throw new Error('Method not implemented.');
  }
  exportMap(type) {
    const renderCanvas = this.getMap()._webglPainter._canvas;
    const layersPng = type === 'jpg' ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL('image/jpeg') : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL('image/png');
    return layersPng;
  }
  hideLogo() {
    const container = this.map.getContainer();
    if (!container) {
      return;
    }
    _l7Utils.DOM.addClass(container, 'bmap-contianer--hide-logo');
  }
  initMapByConfig(config) {
    const {
      style,
      pitch = 0,
      rotation = 0,
      logoVisible = true
    } = config;
    if (style) {
      this.setMapStyle(style);
    }
    if (pitch) {
      this.setPitch(pitch);
    }
    if (rotation) {
      this.setRotation(rotation);
    }
    if (logoVisible === false) {
      this.hideLogo();
    }
  }
}
exports.default = BMapService;