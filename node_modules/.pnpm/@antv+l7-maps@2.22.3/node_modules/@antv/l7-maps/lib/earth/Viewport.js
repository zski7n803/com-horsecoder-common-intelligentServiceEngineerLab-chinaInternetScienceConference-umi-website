"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _glMatrix = require("gl-matrix");
class Viewport {
  constructor() {
    // 初始化相机的姿态 看向地球
    (0, _defineProperty2.default)(this, "xzReg", -Math.PI * 0.6);
    (0, _defineProperty2.default)(this, "yReg", Math.PI * 0.2);
    // 默认的地球相机半径、地球相机缩放层级
    (0, _defineProperty2.default)(this, "earthCameraRadius", 200);
    (0, _defineProperty2.default)(this, "earthCameraZoom", 1);
    (0, _defineProperty2.default)(this, "cameraPosition", _glMatrix.vec3.create());
    (0, _defineProperty2.default)(this, "viewport", void 0);
    (0, _defineProperty2.default)(this, "projectionMatrix", _glMatrix.mat4.create());
    (0, _defineProperty2.default)(this, "modelMatrix", _glMatrix.mat4.create());
    (0, _defineProperty2.default)(this, "viewMatrix", _glMatrix.mat4.create());
    (0, _defineProperty2.default)(this, "viewProjectionMatrix", _glMatrix.mat4.create());
    (0, _defineProperty2.default)(this, "ViewProjectionMatrixUncentered", _glMatrix.mat4.create());
    (0, _defineProperty2.default)(this, "viewUncenteredMatrix", _glMatrix.mat4.create());
  }
  syncWithMapCamera(mapCamera) {
    const {
      viewportHeight = 1,
      viewportWidth = 1
    } = mapCamera;
    const aspect = viewportWidth / viewportHeight;
    const near = 0.1;
    const far = 10000;
    const fov = 20;

    // 计算透视投影矩阵 projectionMatrix
    _glMatrix.mat4.perspective(this.projectionMatrix, fov, aspect, near, far);
    // 计算相机矩阵 viewMatrix
    const x = this.earthCameraRadius * Math.cos(this.xzReg);
    const z = this.earthCameraRadius * Math.sin(this.xzReg);
    const y = this.earthCameraRadius * Math.sin(this.yReg);
    this.cameraPosition = _glMatrix.vec3.fromValues(x, y, z);
    _glMatrix.vec3.normalize(this.cameraPosition, this.cameraPosition);
    _glMatrix.vec3.multiply(this.cameraPosition, this.cameraPosition, _glMatrix.vec3.fromValues(this.earthCameraRadius, this.earthCameraRadius, this.earthCameraRadius));
    _glMatrix.vec3.scale(this.cameraPosition, this.cameraPosition, this.earthCameraZoom);
    const crossY = _glMatrix.vec3.create();
    _glMatrix.vec3.cross(crossY, this.cameraPosition, _glMatrix.vec3.fromValues(0, 1, 0));
    const up = _glMatrix.vec3.fromValues(0, 1, 0);
    _glMatrix.vec3.cross(up, crossY, this.cameraPosition);
    const target = _glMatrix.vec3.fromValues(0, 0, 0);
    _glMatrix.mat4.lookAt(this.viewMatrix, this.cameraPosition, target, up);
    this.viewUncenteredMatrix = _glMatrix.mat4.clone(this.viewMatrix);
    _glMatrix.mat4.multiply(this.viewProjectionMatrix, this.projectionMatrix, this.viewMatrix);
    _glMatrix.mat4.multiply(this.ViewProjectionMatrixUncentered, this.projectionMatrix, this.viewMatrix);
  }

  /**
   * 旋转方法 Y 轴
   * @param r
   */
  rotateY(r) {
    this.xzReg += r * Math.min(this.earthCameraZoom * this.earthCameraZoom, 1);
  }

  /**
   * 旋转方法 X 轴
   * @param r
   */
  rotateX(r) {
    this.yReg += r * Math.min(this.earthCameraZoom * this.earthCameraZoom, 1);
  }

  /**
   * 缩放方法
   * @param z
   */
  scaleZoom(z) {
    this.earthCameraZoom += z;
    this.earthCameraZoom = Math.max(this.earthCameraZoom, 0.6);
  }
  getZoom() {
    return 4;
  }
  getZoomScale() {
    return Math.pow(2, this.getZoom());
  }
  getCenter() {
    return [0, 0];
  }
  getProjectionMatrix() {
    return this.projectionMatrix;
  }
  getModelMatrix() {
    return this.modelMatrix;
  }
  getViewMatrix() {
    return this.viewMatrix;
  }
  getViewMatrixUncentered() {
    return this.viewMatrix;
  }
  getViewProjectionMatrix() {
    return this.viewProjectionMatrix;
  }
  getViewProjectionMatrixUncentered() {
    return this.viewProjectionMatrix;
  }
  getFocalDistance() {
    return 1;
  }
  projectFlat(lngLat, scale) {
    return this.viewport.projectFlat(lngLat, scale);
  }
}
exports.default = Viewport;