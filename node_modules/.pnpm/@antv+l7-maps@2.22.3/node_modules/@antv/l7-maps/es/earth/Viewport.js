import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { mat4, vec3 } from 'gl-matrix';
export default class Viewport {
  constructor() {
    // 初始化相机的姿态 看向地球
    _defineProperty(this, "xzReg", -Math.PI * 0.6);
    _defineProperty(this, "yReg", Math.PI * 0.2);
    // 默认的地球相机半径、地球相机缩放层级
    _defineProperty(this, "earthCameraRadius", 200);
    _defineProperty(this, "earthCameraZoom", 1);
    _defineProperty(this, "cameraPosition", vec3.create());
    _defineProperty(this, "viewport", void 0);
    _defineProperty(this, "projectionMatrix", mat4.create());
    _defineProperty(this, "modelMatrix", mat4.create());
    _defineProperty(this, "viewMatrix", mat4.create());
    _defineProperty(this, "viewProjectionMatrix", mat4.create());
    _defineProperty(this, "ViewProjectionMatrixUncentered", mat4.create());
    _defineProperty(this, "viewUncenteredMatrix", mat4.create());
  }
  syncWithMapCamera(mapCamera) {
    const {
      viewportHeight = 1,
      viewportWidth = 1
    } = mapCamera;
    const aspect = viewportWidth / viewportHeight;
    const near = 0.1;
    const far = 10000;
    const fov = 20;

    // 计算透视投影矩阵 projectionMatrix
    mat4.perspective(this.projectionMatrix, fov, aspect, near, far);
    // 计算相机矩阵 viewMatrix
    const x = this.earthCameraRadius * Math.cos(this.xzReg);
    const z = this.earthCameraRadius * Math.sin(this.xzReg);
    const y = this.earthCameraRadius * Math.sin(this.yReg);
    this.cameraPosition = vec3.fromValues(x, y, z);
    vec3.normalize(this.cameraPosition, this.cameraPosition);
    vec3.multiply(this.cameraPosition, this.cameraPosition, vec3.fromValues(this.earthCameraRadius, this.earthCameraRadius, this.earthCameraRadius));
    vec3.scale(this.cameraPosition, this.cameraPosition, this.earthCameraZoom);
    const crossY = vec3.create();
    vec3.cross(crossY, this.cameraPosition, vec3.fromValues(0, 1, 0));
    const up = vec3.fromValues(0, 1, 0);
    vec3.cross(up, crossY, this.cameraPosition);
    const target = vec3.fromValues(0, 0, 0);
    mat4.lookAt(this.viewMatrix, this.cameraPosition, target, up);
    this.viewUncenteredMatrix = mat4.clone(this.viewMatrix);
    mat4.multiply(this.viewProjectionMatrix, this.projectionMatrix, this.viewMatrix);
    mat4.multiply(this.ViewProjectionMatrixUncentered, this.projectionMatrix, this.viewMatrix);
  }

  /**
   * 旋转方法 Y 轴
   * @param r
   */
  rotateY(r) {
    this.xzReg += r * Math.min(this.earthCameraZoom * this.earthCameraZoom, 1);
  }

  /**
   * 旋转方法 X 轴
   * @param r
   */
  rotateX(r) {
    this.yReg += r * Math.min(this.earthCameraZoom * this.earthCameraZoom, 1);
  }

  /**
   * 缩放方法
   * @param z
   */
  scaleZoom(z) {
    this.earthCameraZoom += z;
    this.earthCameraZoom = Math.max(this.earthCameraZoom, 0.6);
  }
  getZoom() {
    return 4;
  }
  getZoomScale() {
    return Math.pow(2, this.getZoom());
  }
  getCenter() {
    return [0, 0];
  }
  getProjectionMatrix() {
    return this.projectionMatrix;
  }
  getModelMatrix() {
    return this.modelMatrix;
  }
  getViewMatrix() {
    return this.viewMatrix;
  }
  getViewMatrixUncentered() {
    return this.viewMatrix;
  }
  getViewProjectionMatrix() {
    return this.viewProjectionMatrix;
  }
  getViewProjectionMatrixUncentered() {
    return this.viewProjectionMatrix;
  }
  getFocalDistance() {
    return 1;
  }
  projectFlat(lngLat, scale) {
    return this.viewport.projectFlat(lngLat, scale);
  }
}