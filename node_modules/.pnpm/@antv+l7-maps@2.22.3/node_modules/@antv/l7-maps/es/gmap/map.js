import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
const _excluded = ["id", "mapInstance", "center", "token", "minZoom", "maxZoom", "logoVisible"];
import { MapServiceEvent } from '@antv/l7-core';
import { MercatorCoordinate } from '@antv/l7-map';
import { DOM } from '@antv/l7-utils';
import { mat4, vec3 } from 'gl-matrix';
import Viewport from "../lib/web-mercator-viewport";
import BaseMapService from "../utils/BaseMapService";
function loadStyles(css, doc) {
  var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== 'undefined' && wx !== null && (typeof wx.request !== 'undefined' || typeof wx.miniProgram !== 'undefined');
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc) doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName('head')[0];
  if (!head) {
    head = doc.createElement('head');
    var body = doc.body || doc.getElementsByTagName('body')[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement('style');
  style.type = 'text/css';
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles(`img[src*='//mapapi.qq.com/web/jsapi/logo/logo_def.png'],.logo-text
{
  display: none !important;
}
`);
import GMapLoader from "./maploader";
const GMAP_API_KEY = 'AIzaSyDBDCfl4pvuDtaazdCog3LmhA7CQLhmcRE';
const EventMap = {
  mapmove: 'center_changed',
  camerachange: ['drag', 'pan', 'rotate', 'tilt', 'zoom_changed'],
  zoomchange: 'zoom_changed',
  dragging: 'drag'
};

// TODO: 基于抽象类 BaseMap 实现，补全缺失方法，解决类型问题
export default class TMapService extends BaseMapService {
  constructor(...args) {
    super(...args);
    // @ts-ignore
    _defineProperty(this, "viewport", null);
    _defineProperty(this, "evtCbProxyMap", new Map());
    _defineProperty(this, "handleCameraChanged", () => {
      this.emit('mapchange');
      const map = this.map;
      const {
        lng,
        lat
      } = map.getCenter();
      const option = {
        center: [lng(), lat()],
        viewportHeight: map.getDiv().clientHeight,
        viewportWidth: map.getDiv().clientWidth,
        bearing: map.getHeading(),
        pitch: map.getTilt(),
        zoom: map.getZoom() - 1
      };
      this.viewport.syncWithMapCamera(option);
      this.updateCoordinateSystemService();
      this.cameraChangedCallback(this.viewport);
    });
  }
  init() {
    var _this = this;
    return _asyncToGenerator(function* () {
      var _window$google;
      _this.viewport = new Viewport();
      const _this$config = _this.config,
        {
          id,
          mapInstance,
          center = [121.30654632240122, 31.25744185633306],
          token = GMAP_API_KEY,
          minZoom = 3,
          maxZoom = 18,
          logoVisible = true
        } = _this$config,
        rest = _objectWithoutProperties(_this$config, _excluded);
      if (!((_window$google = window.google) !== null && _window$google !== void 0 && (_window$google = _window$google.maps) !== null && _window$google !== void 0 && _window$google.Map || mapInstance)) {
        yield GMapLoader.load({
          key: token
        });
      }
      if (mapInstance) {
        // If there's already a map instance, maybe not setting any other configurations
        _this.map = mapInstance;
        _this.$mapContainer = _this.map.getDiv();
        if (logoVisible === false) {
          _this.hideLogo();
        }
      } else {
        if (!id) {
          throw Error('No container id specified');
        }
        const mapContainer = DOM.getContainer(id);
        const map = new google.maps.Map(mapContainer, _objectSpread({
          maxZoom,
          minZoom,
          zoomControl: false,
          fullscreenControl: false,
          center: new google.maps.LatLng(center[1], center[0])
        }, rest));
        _this.map = map;
        _this.$mapContainer = map.getDiv();
        if (logoVisible === false) {
          _this.hideLogo();
        }
      }

      // TODO: 拖动快的时候，事件失效
      google.maps.event.addListener(_this.map, 'drag', _this.handleCameraChanged);
      google.maps.event.addListener(_this.map, 'pan', _this.handleCameraChanged);
      google.maps.event.addListener(_this.map, 'rotate', _this.handleCameraChanged);

      // 空闲时间
      google.maps.event.addListener(_this.map, 'idle', _this.handleCameraChanged);
      google.maps.event.addListener(_this.map, 'zoom_changed', _this.handleCameraChanged);
      _this.handleCameraChanged();
    })();
  }
  destroy() {
    this.map.setMap(null);
  }
  onCameraChanged(callback) {
    this.cameraChangedCallback = callback;
  }
  addMarkerContainer() {
    // const container = this.map.getDiv();
    // this.markerContainer = DOM.create('div', 'l7-marker-container', container);
    // this.markerContainer.setAttribute('tabindex', '-1');
    // this.markerContainer.style.zIndex = '2';
  }
  getMarkerContainer() {
    return this.markerContainer;
  }
  getCanvasOverlays() {
    // TODO: 由于 Google Map 的 loaded 提前触发，导致 Google Map 的 DOM 结构无法获取
    return this.map.getDiv();
  }

  // MapEvent
  on(type, handle) {
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.on(type, handle);
    } else {
      const onProxy = eventName => {
        let cbProxyMap = this.evtCbProxyMap.get(eventName);
        if (!cbProxyMap) {
          this.evtCbProxyMap.set(eventName, cbProxyMap = new Map());
        }
        if (cbProxyMap.get(handle)) {
          return;
        }
        const handleProxy = (...args) => {
          if (args[0] && typeof args[0] === 'object' && !args[0].lngLat && !args[0].lnglat) {
            args[0].lngLat = args[0].latlng || args[0].latLng;
          }
          handle(...args);
        };
        cbProxyMap.set(handle, handleProxy);
        this.map.on(eventName, handleProxy);
      };
      if (Array.isArray(EventMap[type])) {
        EventMap[type].forEach(eventName => {
          onProxy(eventName || type);
        });
      } else {
        onProxy(EventMap[type] || type);
      }
    }
  }
  off(type, handle) {
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.off(type, handle);
      return;
    }
    const offProxy = eventName => {
      var _this$evtCbProxyMap$g, _this$evtCbProxyMap$g2;
      const handleProxy = (_this$evtCbProxyMap$g = this.evtCbProxyMap.get(type)) === null || _this$evtCbProxyMap$g === void 0 ? void 0 : _this$evtCbProxyMap$g.get(handle);
      if (!handleProxy) {
        return;
      }
      (_this$evtCbProxyMap$g2 = this.evtCbProxyMap.get(eventName)) === null || _this$evtCbProxyMap$g2 === void 0 || _this$evtCbProxyMap$g2.delete(handle);
      this.map.off(eventName, handleProxy);
    };
    if (Array.isArray(EventMap[type])) {
      EventMap[type].forEach(eventName => {
        offProxy(eventName || type);
      });
    } else {
      offProxy(EventMap[type] || type);
    }
  }
  once() {
    throw new Error('Method not implemented.');
  }

  // get dom
  getContainer() {
    return this.map.getDiv();
  }
  getSize() {
    return [this.map.width, this.map.height];
  }

  // get map status method
  getMinZoom() {
    return this.map.transform._minZoom;
  }
  getMaxZoom() {
    return this.map.transform._maxZoom;
  }

  // get map params
  getType() {
    return 'googlemap';
  }
  getZoom() {
    return this.map.getZoom();
  }
  getCenter() {
    const {
      lng,
      lat
    } = this.map.getCenter();
    return {
      lng: lng(),
      lat: lat()
    };
  }
  getPitch() {
    return this.map.getTilt();
  }
  getRotation() {
    const rotation = this.map.getHeading();
    return rotation;
  }
  getBounds() {
    // TODO
    // 官网解释：如果地图尚未初始化，或者尚未设置中心位置且未设置缩放，则结果为 undefine
    const bounds = this.map.getBounds();
    const ne = bounds === null || bounds === void 0 ? void 0 : bounds.getNorthEast();
    const sw = bounds === null || bounds === void 0 ? void 0 : bounds.getSouthWest();
    return [[sw.lng(), sw.lat()], [ne.lng(), ne.lat()]];
  }
  getMapContainer() {
    return this.map.getDiv();
  }
  getMapCanvasContainer() {
    var _this$map$getDiv;
    return (_this$map$getDiv = this.map.getDiv()) === null || _this$map$getDiv === void 0 ? void 0 : _this$map$getDiv.getElementsByTagName('canvas')[0];
  }
  getMapStyleConfig() {
    throw new Error('Method not implemented.');
  }
  setBgColor(color) {
    this.bgColor = color;
  }
  setMapStyle(styleId) {
    this.map.setMapStyleId(styleId);
  }

  // control with raw map
  setRotation(rotation) {
    this.map.setHeading(rotation);
  }
  zoomIn() {
    const currentZoom = this.map.getZoom();
    this.map.setZoom(currentZoom + 1);
  }
  zoomOut() {
    const currentZoom = this.map.getZoom();
    this.map.setZoom(currentZoom - 1);
  }
  panTo([lng, lat]) {
    this.map.panTo({
      lat,
      lng
    });
  }
  panBy(x, y) {
    this.map.panBy(x, y);
  }
  fitBounds(bound, fitBoundsOptions) {
    const [sw, ne] = bound;
    const bounds = new google.maps.LatLngBounds({
      lat: sw[1],
      lng: sw[0]
    }, {
      lat: ne[1],
      lng: ne[0]
    });
    this.map.fitBounds(bounds, fitBoundsOptions);
  }
  setZoomAndCenter(zoom, [lng, lat]) {
    this.map.setZoom(zoom);
    this.map.setCenter({
      lat: lat,
      lng: lng
    });
  }
  setCenter([lng, lat]) {
    this.map.setCenter({
      lat: lat,
      lng: lng
    });
  }
  setPitch(pitch) {
    this.map.setTilt(pitch);
  }
  setZoom(zoom) {
    this.map.setZoom(zoom);
  }
  setMapStatus(option) {
    Object.keys(option).map(status => {
      switch (status) {
        case 'doubleClickZoom':
          this.map.setOptions({
            gestureHandling: option.doubleClickZoom ? 'auto' : 'none'
          });
          break;
        case 'dragEnable':
          this.map.setOptions({
            draggable: option.dragEnable
          });
          break;
        case 'rotateEnable':
          // Google Map 默认支持旋转，无需额外设置
          break;
        case 'zoomEnable':
          this.map.setOptions({
            zoomControl: option.zoomEnable
          });
          break;
        case 'keyboardEnable':
        case 'resizeEnable':
        case 'showIndoorMap':
          throw Error('Options may not be supported');
        default:
      }
    });
  }

  // coordinates methods
  meterToCoord([centerLon, centerLat], [outerLon, outerLat]) {
    // @ts-ignore
    // https://developers.google.com/maps/documentation/javascript/reference/geometry?hl=zh-cn#spherical.computeDistanceBetween
    const metreDistance = google.maps.geometry.spherical.computeDistanceBetween([new google.maps.LatLng(centerLat, centerLon), new google.maps.LatLng(outerLat, outerLon)]);
    const [x1, y1] = this.lngLatToCoord([centerLon, centerLat]);
    const [x2, y2] = this.lngLatToCoord([outerLon, outerLat]);
    const coordDistance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    return coordDistance / metreDistance;
  }
  pixelToLngLat([x, y]) {
    const {
      lng: clng,
      lat: clat
    } = this.map.getCenter();
    const {
      x: centerPixelX,
      y: centerPixelY
    } = this.lngLatToPixel([clng(), clat()]);
    const {
      x: centerContainerX,
      y: centerContainerY
    } = this.lngLatToContainer([clng(), clat()]);
    const {
      lng,
      lat
    } = this.map.unprojectFromContainer(new google.maps.Point(centerContainerX + (x - centerPixelX), centerContainerY + (y - centerPixelY)));
    return this.containerToLngLat([lng, lat]);
  }
  lngLatToPixel([lng, lat]) {
    const latLng = new google.maps.LatLng(lat, lng);
    const point = this.map.getProjection().fromLatLngToPoint(latLng);
    return {
      x: point.x,
      y: point.y
    };
  }
  containerToLngLat([x, y]) {
    var _this$map$getProjecti;
    const pixelCoordinate = new google.maps.Point(x, y);
    const lngLat = (_this$map$getProjecti = this.map.getProjection()) === null || _this$map$getProjecti === void 0 ? void 0 : _this$map$getProjecti.fromPointToLatLng(pixelCoordinate);
    return {
      lng: lngLat.lng(),
      lat: lngLat.lat()
    };
  }
  lngLatToContainer([lng, lat]) {
    var _this$map$getProjecti2, _this$map$getProjecti3;
    const latLng = new google.maps.LatLng(lat, lng);
    const pixel = (_this$map$getProjecti2 = this.map.getProjection()) === null || _this$map$getProjecti2 === void 0 || (_this$map$getProjecti3 = _this$map$getProjecti2.fromLatLngToContainerPixel) === null || _this$map$getProjecti3 === void 0 ? void 0 : _this$map$getProjecti3.call(_this$map$getProjecti2, latLng);
    return {
      x: pixel.x,
      y: pixel.y
    };
  }
  lngLatToCoord([lng, lat]) {
    // TODO: Perhaps need to check the three.js coordinates
    const {
      x,
      y
    } = this.lngLatToPixel([lng, lat]);
    return [x, -y];
  }
  lngLatToCoords(list) {
    return list.map(item => Array.isArray(item[0]) ? this.lngLatToCoords(item) : this.lngLatToCoord(item));
  }
  lngLatToMercator(lnglat, altitude) {
    // Use built in mercator tools due to Tencent not provided related methods
    const {
      x = 0,
      y = 0,
      z = 0
    } = MercatorCoordinate.fromLngLat(lnglat, altitude);
    return {
      x,
      y,
      z
    };
  }
  getModelMatrix(lnglat, altitude, rotate, scale = [1, 1, 1]) {
    const flat = this.viewport.projectFlat(lnglat);
    const modelMatrix = mat4.create();
    mat4.translate(modelMatrix, modelMatrix, vec3.fromValues(flat[0], flat[1], altitude));
    mat4.scale(modelMatrix, modelMatrix, vec3.fromValues(scale[0], scale[1], scale[2]));
    mat4.rotateX(modelMatrix, modelMatrix, rotate[0]);
    mat4.rotateY(modelMatrix, modelMatrix, rotate[1]);
    mat4.rotateZ(modelMatrix, modelMatrix, rotate[2]);
    return modelMatrix;
  }
  getCustomCoordCenter() {
    throw new Error('Method not implemented.');
  }
  exportMap(type) {
    const renderCanvas = this.getMapCanvasContainer();
    const layersPng = type === 'jpg' ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL('image/jpeg') : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL('image/png');
    return layersPng;
  }

  // Method on earth mode
  rotateY() {
    throw new Error('Method not implemented.');
  }
  hideLogo() {
    const container = this.map.getDiv();
    if (!container) {
      return;
    }
    DOM.addClass(container, 'tmap-contianer--hide-logo');
  }
}