"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.VALID_PROPS = exports.DEFAULT_RADIUS = exports.DEFAULT_FONT_WEIGHT = exports.DEFAULT_FONT_SIZE = exports.DEFAULT_FONT_FAMILY = exports.DEFAULT_CUTOFF = exports.DEFAULT_CHAR_SET = exports.DEFAULT_BUFFER = void 0;
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Utils = require("@antv/l7-utils");
var _tinySdf = _interopRequireDefault(require("@mapbox/tiny-sdf"));
var _eventemitter = require("eventemitter3");
var _font_util = require("../../utils/font_util");
// @ts-ignore

const DEFAULT_CHAR_SET = exports.DEFAULT_CHAR_SET = getDefaultCharacterSet();
const DEFAULT_FONT_FAMILY = exports.DEFAULT_FONT_FAMILY = 'sans-serif';
const DEFAULT_FONT_WEIGHT = exports.DEFAULT_FONT_WEIGHT = 'normal';
const DEFAULT_FONT_SIZE = exports.DEFAULT_FONT_SIZE = 24;
const DEFAULT_BUFFER = exports.DEFAULT_BUFFER = 3;
const DEFAULT_CUTOFF = exports.DEFAULT_CUTOFF = 0.25;
const DEFAULT_RADIUS = exports.DEFAULT_RADIUS = 8;
const MAX_CANVAS_WIDTH = 1024;
const BASELINE_SCALE = 1.0;
const HEIGHT_SCALE = 1.0;
const CACHE_LIMIT = 3;
const VALID_PROPS = exports.VALID_PROPS = ['fontFamily', 'fontWeight', 'characterSet', 'fontSize', 'sdf', 'buffer', 'cutoff', 'radius'];
function getDefaultCharacterSet() {
  const charSet = [];
  for (let i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }
  return charSet;
}
function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
  ctx.fillStyle = 'black';
  ctx.textBaseline = 'middle';
  // ctx.textAlign = 'left';
}
function populateAlphaChannel(alphaChannel, imageData) {
  // populate distance value from tinySDF to image alpha channel
  for (let i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}
class FontService extends _eventemitter.EventEmitter {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "fontAtlas", void 0);
    // iconFontMap 记录用户设置的 iconfont unicode 和名称的键值关系
    (0, _defineProperty2.default)(this, "iconFontMap", void 0);
    (0, _defineProperty2.default)(this, "iconFontGlyphs", {});
    (0, _defineProperty2.default)(this, "fontOptions", void 0);
    (0, _defineProperty2.default)(this, "key", void 0);
    (0, _defineProperty2.default)(this, "cache", new _l7Utils.LRUCache(CACHE_LIMIT));
  }
  get scale() {
    return HEIGHT_SCALE;
  }
  get canvas() {
    const data = this.cache.get(this.key);
    return data && data.data;
  }
  get mapping() {
    const data = this.cache.get(this.key);
    return data && data.mapping || {};
  }
  getCanvasByKey(key) {
    const data = this.cache.get(key);
    return data && data.data;
  }
  getMappingByKey(key) {
    const data = this.cache.get(key);
    return data && data.mapping || {};
  }
  init() {
    this.cache.clear();
    this.fontOptions = {
      fontFamily: DEFAULT_FONT_FAMILY,
      fontWeight: DEFAULT_FONT_WEIGHT,
      characterSet: DEFAULT_CHAR_SET,
      fontSize: DEFAULT_FONT_SIZE,
      buffer: DEFAULT_BUFFER,
      sdf: true,
      cutoff: DEFAULT_CUTOFF,
      radius: DEFAULT_RADIUS,
      iconfont: false
    };
    this.key = '';
    this.iconFontMap = new Map();
  }
  addIconGlyphs(glyphs) {
    glyphs.forEach(glyph => {
      this.iconFontGlyphs[glyph.name] = glyph.unicode;
    });
  }

  /**
   * 添加对 iconfont unicode 的映射
   * @param fontUnicode
   * @param name
   */
  addIconFont(name, fontUnicode) {
    this.iconFontMap.set(name, fontUnicode);
  }

  /**
   * 获取自定义 iconfont 别称对应的 unicode 编码，若是当前的 map 中没有对应的键值对，那么就返回原值
   * @param name
   * @returns
   */
  getIconFontKey(name) {
    return this.iconFontMap.get(name) || name;
  }
  getGlyph(name) {
    if (this.iconFontGlyphs[name]) {
      return String.fromCharCode(parseInt(this.iconFontGlyphs[name], 16));
    }
    return '';
  }
  setFontOptions(option) {
    this.fontOptions = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, this.fontOptions), option);
    this.key = this.getKey();
    const charSet = this.getNewChars(this.key, this.fontOptions.characterSet);
    const cachedFontAtlas = this.cache.get(this.key);
    if (cachedFontAtlas && charSet.length === 0) {
      // update texture with cached fontAtlas
      return;
    }
    // update fontAtlas with new settings
    const fontAtlas = this.generateFontAtlas(this.key, charSet, cachedFontAtlas);
    this.fontAtlas = fontAtlas;

    // update cache
    this.cache.set(this.key, fontAtlas);
  }
  /**
   * 用户自定义添加第三方字体 （用户使用 layer/point/text/iconfont 的前提需要加载第三方字体文件）
   * @param fontFamily
   * @param fontPath
   */
  addFontFace(fontFamily, fontPath) {
    const style = document.createElement('style');
    style.type = 'text/css';
    style.innerText = `
        @font-face{
            font-family: '${fontFamily}';
            src: url('${fontPath}') format('woff2'),
            url('${fontPath}') format('woff'),
            url('${fontPath}') format('truetype');
        }`;
    style.onload = () => {
      if (document.fonts) {
        try {
          // @ts-ignore
          document.fonts.load(`24px ${fontFamily}`, 'L7text');
          document.fonts.ready.then(() => {
            this.emit('fontloaded', {
              fontFamily
            });
          });
        } catch (e) {
          console.warn('当前环境不支持 document.fonts !');
          console.warn('当前环境不支持 iconfont !');
          console.warn(e);
        }
      }
    };
    document.getElementsByTagName('head')[0].appendChild(style);
  }
  destroy() {
    this.cache.clear();
    this.iconFontMap.clear();
  }
  generateFontAtlas(key, characterSet, cachedFontAtlas) {
    const {
      fontFamily,
      fontWeight,
      fontSize,
      buffer,
      sdf,
      radius,
      cutoff,
      iconfont
    } = this.fontOptions;
    let canvas = cachedFontAtlas && cachedFontAtlas.data;
    if (!canvas) {
      canvas = window.document.createElement('canvas');
      canvas.width = MAX_CANVAS_WIDTH;
    }
    const ctx = canvas.getContext('2d', {
      willReadFrequently: true
    });
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);

    // 1. build mapping
    const {
      mapping,
      canvasHeight,
      xOffset,
      yOffset
    } = (0, _font_util.buildMapping)((0, _objectSpread2.default)({
      getFontWidth: char => ctx.measureText(char).width,
      fontHeight: fontSize * HEIGHT_SCALE,
      buffer,
      characterSet,
      maxCanvasWidth: MAX_CANVAS_WIDTH
    }, cachedFontAtlas && {
      mapping: cachedFontAtlas.mapping,
      xOffset: cachedFontAtlas.xOffset,
      yOffset: cachedFontAtlas.yOffset
    }));

    // 2. update canvas
    // copy old canvas data to new canvas only when height changed
    // TODO safari 不能正常更新
    const copyImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    canvas.height = canvasHeight;
    ctx.putImageData(copyImageData, 0, 0);
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);

    // 3. layout characters
    if (sdf) {
      const tinySDF = new _tinySdf.default(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);
      // used to store distance values from tinySDF
      // tinySDF.size equals `fontSize + buffer * 2`
      const imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);
      for (const char of characterSet) {
        if (iconfont) {
          // @ts-ignore
          // const icon = eval(
          //   '("' + char.replace('&#x', '\\u').replace(';', '') + '")',
          // );

          const icon = String.fromCharCode(parseInt(char.replace('&#x', '').replace(';', ''), 16));
          const iconData = tinySDF.draw(icon);
          populateAlphaChannel(iconData, imageData);
        } else {
          populateAlphaChannel(tinySDF.draw(char), imageData);
        }
        // populateAlphaChannel(tinySDF.draw(char), imageData);

        // 考虑到描边，需要保留 sdf 的 buffer，不能像 deck.gl 一样直接减去
        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);
      }
    } else {
      for (const char of characterSet) {
        ctx.fillText(char, mapping[char].x, mapping[char].y + fontSize * BASELINE_SCALE);
      }
    }
    return {
      xOffset,
      yOffset,
      mapping,
      data: canvas,
      width: canvas.width,
      height: canvas.height
    };
  }
  getKey() {
    const {
      fontFamily,
      fontWeight
    } = this.fontOptions;
    return `${fontFamily}_${fontWeight}`;
  }

  /**
   *
   * @param key
   * @param characterSet
   * @returns
   * 若是相同的 key，那么将字符存储到同同一个字符列表中
   */
  getNewChars(key, characterSet) {
    const cachedFontAtlas = this.cache.get(key);
    if (!cachedFontAtlas) {
      return characterSet;
    }
    const newChars = [];
    const cachedMapping = cachedFontAtlas.mapping;
    const cachedCharSet = new Set(Object.keys(cachedMapping));
    const charSet = new Set(characterSet);
    charSet.forEach(char => {
      if (!cachedCharSet.has(char)) {
        newChars.push(char);
      }
    });
    return newChars;
  }
}
exports.default = FontService;