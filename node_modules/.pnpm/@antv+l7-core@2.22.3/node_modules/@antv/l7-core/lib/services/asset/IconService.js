"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _eventemitter = require("eventemitter3");
var _font_util = require("../../utils/font_util");
const BUFFER = 3;
const MAX_CANVAS_WIDTH = 1024;
const imageSize = 64;
class IconService extends _eventemitter.EventEmitter {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "canvasHeight", 128);
    (0, _defineProperty2.default)(this, "texture", void 0);
    (0, _defineProperty2.default)(this, "canvas", void 0);
    (0, _defineProperty2.default)(this, "iconData", void 0);
    (0, _defineProperty2.default)(this, "iconMap", void 0);
    (0, _defineProperty2.default)(this, "ctx", void 0);
    (0, _defineProperty2.default)(this, "loadingImageCount", 0);
  }
  isLoading() {
    return this.loadingImageCount === 0;
  }
  init() {
    this.iconData = [];
    this.iconMap = {};
    this.canvas = window.document.createElement('canvas');
    this.canvas.width = 128;
    this.canvas.height = 128;
    this.ctx = this.canvas.getContext('2d');
  }
  addImage(id, image) {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      let imagedata = new Image();
      _this.loadingImageCount++;
      if (_this.hasImage(id)) {
        console.warn('Image Id already exists');
      } else {
        _this.iconData.push({
          id,
          size: imageSize
        });
      }
      _this.updateIconMap(); // 先存储 ID，
      imagedata = yield _this.loadImage(image);
      const iconImage = _this.iconData.find(icon => {
        return icon.id === id;
      });
      if (iconImage) {
        iconImage.image = imagedata;
        iconImage.width = imagedata.width;
        iconImage.height = imagedata.height;
      }
      _this.update();
    })();
  }

  /**
   * 适配小程序
   * @param id
   * @param image
   * @param sceneService
   */
  addImageMini(id, image, sceneService) {
    const canvas = sceneService.getSceneConfig().canvas;
    // @ts-ignore
    let imagedata = canvas.createImage();
    this.loadingImageCount++;
    if (this.hasImage(id)) {
      throw new Error('Image Id already exists');
    }
    this.iconData.push({
      id,
      size: imageSize
    });
    this.updateIconMap();
    this.loadImageMini(image, canvas).then(img => {
      imagedata = img;
      const iconImage = this.iconData.find(icon => {
        return icon.id === id;
      });
      if (iconImage) {
        iconImage.image = imagedata;
        iconImage.width = imagedata.width;
        iconImage.height = imagedata.height;
      }
      this.update();
    });
  }
  getTexture() {
    return this.texture;
  }
  getIconMap() {
    return this.iconMap;
  }
  getCanvas() {
    return this.canvas;
  }
  hasImage(id) {
    return this.iconMap.hasOwnProperty(id);
  }
  removeImage(id) {
    if (this.hasImage(id)) {
      this.iconData = this.iconData.filter(icon => {
        return icon.id !== id;
      });
      delete this.iconMap[id];
      this.update();
    }
  }
  destroy() {
    // 在销毁的时候清除所有注册的监听
    this.removeAllListeners('imageUpdate');
    this.iconData = [];
    this.iconMap = {};
  }
  loadImage(url) {
    return new Promise((resolve, reject) => {
      if (url instanceof HTMLImageElement) {
        resolve(url);
        return;
      }
      const image = new Image();
      image.crossOrigin = 'anonymous';
      image.onload = () => {
        resolve(image);
      };
      image.onerror = () => {
        reject(new Error('Could not load image at ' + url));
      };
      image.src = url instanceof File ? URL.createObjectURL(url) : url;
    });
  }
  update() {
    this.updateIconMap();
    this.updateIconAtlas();
    this.loadingImageCount--;
    if (this.loadingImageCount === 0) {
      this.emit('imageUpdate');
    }
  }

  /**
   * 将新增的 icon 图像存储到画布上（正方形）
   */
  updateIconAtlas() {
    this.canvas.width = MAX_CANVAS_WIDTH;
    this.canvas.height = this.canvasHeight;
    Object.keys(this.iconMap).forEach(item => {
      const {
        x,
        y,
        image,
        width = 64,
        height = 64
      } = this.iconMap[item];
      const max = Math.max(width, height);
      const ratio = max / imageSize;
      const drawHeight = height / ratio;
      const drawWidth = width / ratio;
      if (image) {
        this.ctx.drawImage(image, x + (imageSize - drawWidth) / 2, y + (imageSize - drawHeight) / 2, drawWidth, drawHeight);
      }
    });
  }

  /**
   * 计算 icon 在画布上的排布（是否需要换行）
   */
  updateIconMap() {
    const {
      mapping,
      canvasHeight
    } = (0, _font_util.buildIconMaping)(this.iconData, BUFFER, MAX_CANVAS_WIDTH);
    this.iconMap = mapping;
    this.canvasHeight = canvasHeight;
  }

  /**
   * 适配小程序
   * @param url
   * @returns
   */
  loadImageMini(url, canvas) {
    return new Promise((resolve, reject) => {
      // @ts-ignore
      const image = canvas.createImage();
      image.crossOrigin = 'anonymous';
      image.onload = () => {
        resolve(image);
      };
      image.onerror = () => {
        reject(new Error('Could not load image at ' + url));
      };
      image.src = url;
    });
  }
}
exports.default = IconService;