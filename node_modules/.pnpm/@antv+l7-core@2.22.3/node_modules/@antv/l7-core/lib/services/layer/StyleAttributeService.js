"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _gl = require("../renderer/gl");
var _StyleAttribute = _interopRequireDefault(require("./StyleAttribute"));
const _excluded = ["buffer", "update", "name"],
  _excluded2 = ["buffer", "update", "name"];
const bytesPerElementMap = {
  [_gl.gl.FLOAT]: 4,
  [_gl.gl.UNSIGNED_BYTE]: 1,
  [_gl.gl.UNSIGNED_SHORT]: 2
};

/**
 * 每个 Layer 都拥有一个，用于管理样式属性的注册和更新
 */
class StyleAttributeService {
  constructor(rendererService) {
    (0, _defineProperty2.default)(this, "attributesAndIndices", void 0);
    (0, _defineProperty2.default)(this, "attributes", []);
    (0, _defineProperty2.default)(this, "triangulation", void 0);
    (0, _defineProperty2.default)(this, "featureLayout", {
      sizePerElement: 0,
      elements: []
    });
    this.rendererService = rendererService;
  }
  registerStyleAttribute(options) {
    let attributeToUpdate = this.getLayerStyleAttribute(options.name || '');
    if (attributeToUpdate) {
      attributeToUpdate.setProps(options);
    } else {
      attributeToUpdate = new _StyleAttribute.default(options);
      this.attributes.push(attributeToUpdate);
    }
    return attributeToUpdate;
  }
  unRegisterStyleAttribute(name) {
    const attributeIndex = this.attributes.findIndex(attribute => attribute.name === name);
    if (attributeIndex > -1) {
      this.attributes.splice(attributeIndex, 1);
    }
  }
  updateScaleAttribute(scaleOption) {
    this.attributes.forEach(attr => {
      var _attr$scale;
      const name = attr.name;
      const field = (_attr$scale = attr.scale) === null || _attr$scale === void 0 ? void 0 : _attr$scale.field;
      if (scaleOption[name] || field && scaleOption[field]) {
        // 字段类型和映射类型
        attr.needRescale = true;
        attr.needRemapping = true;
        attr.needRegenerateVertices = true;
      }
    });
  }
  updateStyleAttribute(attributeName, options, updateOptions) {
    let attributeToUpdate = this.getLayerStyleAttribute(attributeName);
    if (!attributeToUpdate) {
      attributeToUpdate = this.registerStyleAttribute((0, _objectSpread2.default)((0, _objectSpread2.default)({}, options), {}, {
        name: attributeName
      }));
    }
    const {
      scale
    } = options;
    if (scale && attributeToUpdate) {
      // TODO: 需要比较新旧值确定是否需要 rescale
      // 需要重新 scale，肯定也需要重新进行数据映射
      attributeToUpdate.scale = scale;
      attributeToUpdate.needRescale = true;
      attributeToUpdate.needRemapping = true;
      attributeToUpdate.needRegenerateVertices = true;
      if (updateOptions && updateOptions.featureRange) {
        attributeToUpdate.featureRange = updateOptions.featureRange;
      }
    }
  }
  getLayerStyleAttributes() {
    return this.attributes;
  }
  getLayerStyleAttribute(attributeName) {
    return this.attributes.find(attribute => attribute.name === attributeName);
  }
  getLayerAttributeScale(name) {
    var _attribute$scale;
    const attribute = this.getLayerStyleAttribute(name);
    const scale = attribute === null || attribute === void 0 || (_attribute$scale = attribute.scale) === null || _attribute$scale === void 0 ? void 0 : _attribute$scale.scalers;
    if (scale && scale[0]) {
      return scale[0].func;
    }
    return null;
  }
  updateAttributeByFeatureRange(attributeName, features, startFeatureIdx = 0, endFeatureIdx, layer) {
    const attributeToUpdate = this.attributes.find(attribute => attribute.name === attributeName);
    if (attributeToUpdate && attributeToUpdate.descriptor) {
      const {
        descriptor
      } = attributeToUpdate;
      const {
        update,
        buffer,
        size = 0
      } = descriptor;
      const bytesPerElement = bytesPerElementMap[buffer.type || _gl.gl.FLOAT];
      if (update) {
        const {
          elements,
          sizePerElement
        } = this.featureLayout;
        // 截取待更新的 feature 范围
        const featuresToUpdate = elements.slice(startFeatureIdx, endFeatureIdx);
        // [n, n] 中断更新
        if (!featuresToUpdate.length) {
          return;
        }
        const {
          offset
        } = featuresToUpdate[0];
        // 以 byte 为单位计算 buffer 中的偏移
        const bufferOffsetInBytes = offset * size * bytesPerElement;
        const updatedBufferData = featuresToUpdate.map(({
          featureIdx,
          vertices,
          normals
        }, attributeIdx) => {
          const verticesNumForCurrentFeature = vertices.length / sizePerElement;
          const featureData = [];
          for (let vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
            const normal = normals ?
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            normals.slice(vertexIdx * 3, vertexIdx * 3 + 3) : [];
            featureData.push(...update(features[featureIdx], featureIdx, vertices.slice(vertexIdx * sizePerElement, vertexIdx * sizePerElement + sizePerElement), attributeIdx, normal));
          }
          return featureData;
        }).flat();

        // 更新底层 IAttribute 中包含的 IBuffer，使用 subdata
        attributeToUpdate.vertexAttribute.updateBuffer({
          data: updatedBufferData,
          offset: bufferOffsetInBytes
        });
        // size color 触发更新事件
        layer === null || layer === void 0 || layer.emit(`legend:${attributeName}`, layer.getLegend(attributeName));
      }
    }
  }
  createAttributesAndIndices(features, triangulation, styleOption, layer) {
    // 每次创建的初始化化 LayerOut
    this.featureLayout = {
      sizePerElement: 0,
      elements: []
    };
    if (triangulation) {
      this.triangulation = triangulation;
    }
    const descriptors = this.attributes.map(attr => {
      attr.resetDescriptor();
      return attr.descriptor;
    });
    let verticesNum = 0;
    let vecticesCount = 0; // 在不使用 element 的时候记录顶点、图层所有顶点的总数
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const indices = [];
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    let size = 3;
    features.forEach((feature, featureIdx) => {
      // 逐 feature 进行三角化
      const {
        indices: indicesForCurrentFeature,
        vertices: verticesForCurrentFeature,
        normals: normalsForCurrentFeature,
        size: vertexSize,
        indexes,
        count
      } = this.triangulation(feature, styleOption);
      if (typeof count === 'number') {
        // 顶点数
        vecticesCount += count;
      }
      indicesForCurrentFeature.forEach(i => {
        indices.push(i + verticesNum);
      });
      size = vertexSize;
      const verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;

      // 记录三角化结果，用于后续精确更新指定 feature
      this.featureLayout.sizePerElement = size;
      this.featureLayout.elements.push({
        featureIdx,
        vertices: verticesForCurrentFeature,
        normals: normalsForCurrentFeature,
        offset: verticesNum
      });
      verticesNum += verticesNumForCurrentFeature;
      // 根据 position 顶点生成其他顶点数据 // color/size/ui
      for (let vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
        const normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];
        const vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);
        let vertexIndex = 0;
        if (indexes && indexes[vertexIdx] !== undefined) {
          vertexIndex = indexes[vertexIdx];
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        descriptors.forEach((descriptor, attributeIdx) => {
          if (descriptor && descriptor.update) {
            descriptor.buffer.data.push(...descriptor.update(feature, featureIdx, vertice, vertexIdx,
            // 当前顶点所在feature索引
            normal, vertexIndex
            // 传入顶点索引 vertexIdx
            ));
          } // end if
        }); // end for each
      } // end for
    }); // end features for Each
    const {
      createAttribute,
      createBuffer,
      createElements
    } = this.rendererService;
    const attributes = {};
    descriptors.forEach((descriptor, attributeIdx) => {
      if (descriptor) {
        // IAttribute 参数透传
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const {
            buffer,
            update,
            name
          } = descriptor,
          rest = (0, _objectWithoutProperties2.default)(descriptor, _excluded);
        const vertexAttribute = createAttribute((0, _objectSpread2.default)({
          // IBuffer 参数透传
          buffer: createBuffer(buffer)
        }, rest));
        attributes[descriptor.name || ''] = vertexAttribute;

        // 在 StyleAttribute 上保存对 VertexAttribute 的引用
        this.attributes[attributeIdx].vertexAttribute = vertexAttribute;
      }
    });
    const elements = createElements({
      data: indices,
      type: _gl.gl.UNSIGNED_INT,
      count: indices.length
    });
    this.attributesAndIndices = {
      attributes,
      elements,
      count: vecticesCount
    };
    Object.values(this.attributes).filter(attribute => attribute.scale).forEach(attribute => {
      const attributeName = attribute.name;
      // size color 触发更新事件
      layer === null || layer === void 0 || layer.emit(`legend:${attributeName}`, layer.getLegend(attributeName));
    });
    return this.attributesAndIndices;
  }
  createAttributes(features, triangulation) {
    // 每次创建的初始化化 LayerOut
    this.featureLayout = {
      sizePerElement: 0,
      elements: []
    };
    if (triangulation) {
      this.triangulation = triangulation;
    }
    const descriptors = this.attributes.map(attr => {
      attr.resetDescriptor();
      return attr.descriptor;
    });
    let verticesNum = 0;
    const indices = [];
    let size = 3;
    features.forEach((feature, featureIdx) => {
      // 逐 feature 进行三角化
      const {
        indices: indicesForCurrentFeature,
        vertices: verticesForCurrentFeature,
        normals: normalsForCurrentFeature,
        size: vertexSize,
        indexes
      } = this.triangulation(feature);
      indicesForCurrentFeature.forEach(i => {
        indices.push(i + verticesNum);
      });
      size = vertexSize;
      const verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;

      // 记录三角化结果，用于后续精确更新指定 feature
      this.featureLayout.sizePerElement = size;
      this.featureLayout.elements.push({
        featureIdx,
        vertices: verticesForCurrentFeature,
        normals: normalsForCurrentFeature,
        offset: verticesNum
      });
      verticesNum += verticesNumForCurrentFeature;
      // 根据 position 顶点生成其他顶点数据
      for (let vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
        const normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];
        const vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);
        let vertexIndex = 0;
        if (indexes && indexes[vertexIdx] !== undefined) {
          vertexIndex = indexes[vertexIdx];
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        descriptors.forEach((descriptor, attributeIdx) => {
          if (descriptor && descriptor.update) {
            descriptor.buffer.data.push(...descriptor.update(feature, featureIdx, vertice, vertexIdx,
            // 当前顶点所在feature索引
            normal, vertexIndex
            // 传入顶点索引 vertexIdx
            ));
          } // end if
        }); // end for each
      } // end for
    }); // end features for Each
    const {
      createAttribute,
      createBuffer
    } = this.rendererService;
    const attributes = {};
    descriptors.forEach((descriptor, attributeIdx) => {
      if (descriptor) {
        // IAttribute 参数透传
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const {
            buffer,
            update,
            name
          } = descriptor,
          rest = (0, _objectWithoutProperties2.default)(descriptor, _excluded2);
        const vertexAttribute = createAttribute((0, _objectSpread2.default)({
          // IBuffer 参数透传
          buffer: createBuffer(buffer)
        }, rest));
        attributes[descriptor.name || ''] = vertexAttribute;

        // 在 StyleAttribute 上保存对 VertexAttribute 的引用
        this.attributes[attributeIdx].vertexAttribute = vertexAttribute;
      }
    });
    return {
      attributes
    };
  }
  clearAllAttributes() {
    var _this$attributesAndIn;
    // 销毁关联的 vertex attribute buffer objects
    this.attributes.forEach(attribute => {
      if (attribute.vertexAttribute) {
        attribute.vertexAttribute.destroy();
      }
    });
    (_this$attributesAndIn = this.attributesAndIndices) === null || _this$attributesAndIn === void 0 || _this$attributesAndIn.elements.destroy();
    this.attributes = [];
  }
}
exports.default = StyleAttributeService;