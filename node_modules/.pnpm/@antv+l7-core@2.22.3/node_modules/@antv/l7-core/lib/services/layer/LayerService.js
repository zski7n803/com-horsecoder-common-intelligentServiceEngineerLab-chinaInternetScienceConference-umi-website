"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Utils = require("@antv/l7-utils");
var _eventemitter = require("eventemitter3");
var _clock = _interopRequireDefault(require("../../utils/clock"));
var _ILayerService = require("./ILayerService");
const {
  throttle
} = _l7Utils.lodashUtil;
class LayerService extends _eventemitter.EventEmitter {
  get renderService() {
    return this.container.rendererService;
  }
  get mapService() {
    return this.container.mapService;
  }
  get debugService() {
    return this.container.debugService;
  }
  constructor(container) {
    super();
    // pickedLayerId 参数用于指定当前存在被选中的 layer
    (0, _defineProperty2.default)(this, "pickedLayerId", -1);
    (0, _defineProperty2.default)(this, "clock", new _clock.default());
    (0, _defineProperty2.default)(this, "alreadyInRendering", false);
    (0, _defineProperty2.default)(this, "layers", []);
    (0, _defineProperty2.default)(this, "layerList", []);
    (0, _defineProperty2.default)(this, "layerRenderID", void 0);
    (0, _defineProperty2.default)(this, "sceneInited", false);
    (0, _defineProperty2.default)(this, "animateInstanceCount", 0);
    // TODO: 是否开启 shader 中的颜色拾取计算
    (0, _defineProperty2.default)(this, "shaderPicking", true);
    (0, _defineProperty2.default)(this, "enableRender", true);
    (0, _defineProperty2.default)(this, "reRender", throttle(() => {
      this.renderLayers();
    }, 32));
    (0, _defineProperty2.default)(this, "throttleRenderLayers", throttle(() => {
      this.renderLayers();
    }, 16));
    this.container = container;
  }
  needPick(type) {
    this.updateLayerRenderList();
    return this.layerList.some(layer => layer.needPick(type));
  }
  add(layer) {
    this.layers.push(layer);
    if (this.sceneInited) {
      layer.init().then(() => {
        this.renderLayers();
      });
    }
  }
  addMask(mask) {
    if (this.sceneInited) {
      mask.init().then(() => {
        this.renderLayers();
      });
    }
  }
  initLayers() {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      _this.sceneInited = true;
      _this.layers.forEach( /*#__PURE__*/function () {
        var _ref = (0, _asyncToGenerator2.default)(function* (layer) {
          if (!layer.startInit) {
            yield layer.init();
            _this.updateLayerRenderList();
          }
        });
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
    })();
  }
  getSceneInited() {
    return this.sceneInited;
  }
  getRenderList() {
    return this.layerList;
  }
  getLayers() {
    return this.layers;
  }
  getLayer(id) {
    return this.layers.find(layer => layer.id === id);
  }
  getLayerByName(name) {
    return this.layers.find(layer => layer.name === name);
  }
  remove(layer, parentLayer) {
    var _this2 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      // Tip: layer.layerChildren 当 layer 存在子图层的情况
      if (parentLayer) {
        parentLayer.layerChildren = parentLayer.layerChildren.filter(item => item !== layer);
      } else {
        _this2.layers = _this2.layers.filter(item => item !== layer);
      }
      layer.destroy();
      _this2.reRender();
      _this2.emit('layerChange', _this2.layers);
    })();
  }
  removeAllLayers() {
    var _this3 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      _this3.destroy();
      _this3.reRender();
    })();
  }
  setEnableRender(flag) {
    this.enableRender = flag;
  }
  renderLayers() {
    var _this4 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      if (_this4.alreadyInRendering || !_this4.enableRender) {
        return;
      }
      _this4.updateLayerRenderList();
      const renderUid = _this4.debugService.generateRenderUid();
      _this4.debugService.renderStart(renderUid);
      _this4.alreadyInRendering = true;
      _this4.clear();
      for (const layer of _this4.layerList) {
        layer.prerender();
      }

      // The main render pass, all layers in a whole.
      _this4.renderService.beginFrame();
      for (const layer of _this4.layerList) {
        const {
          enableMask
        } = layer.getLayerConfig();
        if (layer.masks.filter(m => m.inited).length > 0 && enableMask) {
          // 清除上一次的模版缓存
          _this4.renderMask(layer.masks);
        }
        if (layer.getLayerConfig().enableMultiPassRenderer) {
          // multiPassRender 不是同步渲染完成的
          yield layer.renderMultiPass();
        } else {
          layer.render();
        }
      }
      _this4.renderService.endFrame();
      _this4.debugService.renderEnd(renderUid);
      _this4.alreadyInRendering = false;
    })();
  }
  renderMask(masks) {
    let maskIndex = 0;
    this.renderService.clear({
      stencil: 0,
      depth: 1,
      framebuffer: null
    });
    const stencilType = masks.length > 1 ? _ILayerService.StencilType.MULTIPLE : _ILayerService.StencilType.SINGLE;
    for (const layer of masks) {
      // 清除上一次的模版缓存
      layer.render({
        isStencil: true,
        stencilType,
        stencilIndex: maskIndex++
      });
    }
  }
  beforeRenderData(layer) {
    var _this5 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      const flag = yield layer.hooks.beforeRenderData.promise();
      if (flag) {
        _this5.renderLayers();
      }
    })();
  }
  renderTileLayerMask(layer) {
    let maskindex = 0;
    const {
      enableMask = true
    } = layer.getLayerConfig();
    let maskCount = layer.tileMask ? 1 : 0; // 瓦片裁剪 线图层或者面图层
    const masklayers = layer.masks.filter(m => m.inited);
    maskCount = maskCount + (enableMask ? masklayers.length : 1);
    const stencilType = maskCount > 1 ? _ILayerService.StencilType.MULTIPLE : _ILayerService.StencilType.SINGLE;
    //  兼容MaskLayer MaskLayer的掩模不能clear
    if (layer.tileMask || masklayers.length && enableMask) {
      this.renderService.clear({
        stencil: 0,
        depth: 1,
        framebuffer: null
      });
    }
    if (masklayers.length && enableMask) {
      for (const mask of masklayers) {
        mask.render({
          isStencil: true,
          stencilType,
          stencilIndex: maskindex++
        });
      }
    }
    // // 瓦片裁剪
    if (layer.tileMask) {
      layer.tileMask.render({
        isStencil: true,
        stencilType,
        stencilIndex: maskindex++,
        stencilOperation: _ILayerService.MaskOperation.OR
      });
    }
  }
  // 瓦片图层渲染
  renderTileLayer(layer) {
    var _this6 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      _this6.renderTileLayerMask(layer);
      if (layer.getLayerConfig().enableMultiPassRenderer) {
        // multiPassRender 不是同步渲染完成的
        yield layer.renderMultiPass();
      } else {
        yield layer.render();
      }
    })();
  }
  updateLayerRenderList() {
    // Tip: 每次更新都是从 layers 重新构建
    this.layerList = [];
    this.layers.filter(layer => layer.inited).filter(layer => layer.isVisible()).sort((pre, next) => {
      // 根据 zIndex 对渲染顺序进行排序
      return pre.zIndex - next.zIndex;
    }).forEach(layer => {
      this.layerList.push(layer);
    });
  }
  destroy() {
    this.layers.forEach(layer => {
      layer.destroy();
    });
    this.layers = [];
    this.layerList = [];
    this.emit('layerChange', this.layers);
  }
  startAnimate() {
    if (this.animateInstanceCount++ === 0) {
      this.clock.start();
      this.runRender();
    }
  }
  stopAnimate() {
    if (--this.animateInstanceCount === 0) {
      this.stopRender();
      this.clock.stop();
    }
  }
  getOESTextureFloat() {
    return this.renderService.extensionObject.OES_texture_float;
  }

  // 控制着色器颜色拾取计算
  enableShaderPick() {
    this.shaderPicking = true;
  }
  disableShaderPick() {
    this.shaderPicking = false;
  }
  getShaderPickStat() {
    return this.shaderPicking;
  }
  clear() {
    const color = (0, _l7Utils.rgb2arr)(this.mapService.bgColor);
    this.renderService.clear({
      color,
      depth: 1,
      stencil: 0,
      framebuffer: null
    });
  }
  runRender() {
    this.renderLayers();
    this.layerRenderID = window.requestAnimationFrame(this.runRender.bind(this));
  }
  stopRender() {
    window.cancelAnimationFrame(this.layerRenderID);
  }
}
exports.default = LayerService;