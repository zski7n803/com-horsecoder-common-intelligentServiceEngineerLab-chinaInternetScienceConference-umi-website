import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { decodePickingColor, DOM } from '@antv/l7-utils';
import { isEventCrash } from "../../utils/dom";
import { InteractionEvent } from "../interaction/IInteractionService";
import { TextureUsage } from "../renderer/ITexture2D";
export default class PickingService {
  constructor(container) {
    var _this = this;
    _defineProperty(this, "pickedColors", void 0);
    _defineProperty(this, "pickedTileLayers", []);
    _defineProperty(this, "pickingFBO", void 0);
    _defineProperty(this, "width", 0);
    _defineProperty(this, "height", 0);
    _defineProperty(this, "alreadyInPicking", false);
    _defineProperty(this, "pickBufferScale", 1.0);
    _defineProperty(this, "pickFromPickingFBO", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (layer, {
        x,
        y,
        lngLat,
        type,
        target
      }) {
        var _pickedColors;
        let isPicked = false;
        const {
          readPixels,
          readPixelsAsync,
          getViewportSize,
          queryVerdorInfo
        } = _this.rendererService;
        const {
          width,
          height
        } = getViewportSize();
        const {
          enableHighlight,
          enableSelect
        } = layer.getLayerConfig();
        const xInDevicePixel = x * DOM.DPR;
        const yInDevicePixel = y * DOM.DPR;
        if (xInDevicePixel > width - 1 * DOM.DPR || xInDevicePixel < 0 || yInDevicePixel > height - 1 * DOM.DPR || yInDevicePixel < 0) {
          return false;
        }
        let pickedColors;

        // readPixelsAsync 比 readPixels 慢，会造成拾取事件冒泡延迟，优先使用 readPixelsAsync，WebGPU 只支持 readPixelsAsync API
        const isWebGPU = queryVerdorInfo() === 'WebGPU';
        if (isWebGPU) {
          pickedColors = yield readPixelsAsync({
            x: Math.floor(xInDevicePixel / _this.pickBufferScale),
            // 视口坐标系原点在左上，而 WebGL 在左下，需要翻转 Y 轴
            y: Math.floor((height - (y + 1) * DOM.DPR) / _this.pickBufferScale),
            width: 1,
            height: 1,
            data: new Uint8Array(1 * 1 * 4),
            framebuffer: _this.pickingFBO
          });
        } else {
          pickedColors = readPixels({
            x: Math.floor(xInDevicePixel / _this.pickBufferScale),
            // 视口坐标系原点在左上，而 WebGL 在左下，需要翻转 Y 轴
            y: Math.floor((height - (y + 1) * DOM.DPR) / _this.pickBufferScale),
            width: 1,
            height: 1,
            data: new Uint8Array(1 * 1 * 4),
            framebuffer: _this.pickingFBO
          });
        }
        _this.pickedColors = pickedColors;
        if (pickedColors[0] !== 0 || pickedColors[1] !== 0 || pickedColors[2] !== 0) {
          const pickedFeatureIdx = decodePickingColor(pickedColors);
          // 瓦片数据获取性能问题需要优化
          const rawFeature = layer.layerPickService.getFeatureById(pickedFeatureIdx);
          if (pickedFeatureIdx !== layer.getCurrentPickId() && type === 'mousemove') {
            type = 'mouseenter';
          }
          const layerTarget = {
            x,
            y,
            type,
            lngLat,
            featureId: pickedFeatureIdx,
            feature: rawFeature,
            target
          };
          if (!rawFeature) {
            // this.logger.error(
            //   '未找到颜色编码解码后的原始 feature，请检查 fragment shader 中末尾是否添加了 `gl_FragColor = filterColor(gl_FragColor);`',
            // );
          } else {
            // trigger onHover/Click callback on layer
            isPicked = true;
            layer.setCurrentPickId(pickedFeatureIdx);
            _this.triggerHoverOnLayer(layer, layerTarget); // 触发拾取事件
          }
        } else {
          // 未选中
          const layerTarget = {
            x,
            y,
            lngLat,
            type: layer.getCurrentPickId() !== null && type === 'mousemove' ? 'mouseout' : 'un' + type,
            featureId: null,
            target,
            feature: null
          };
          _this.triggerHoverOnLayer(layer, _objectSpread(_objectSpread({}, layerTarget), {}, {
            type: 'unpick'
          }));
          _this.triggerHoverOnLayer(layer, layerTarget);
          layer.setCurrentPickId(null);
        }
        if (enableHighlight) {
          layer.layerPickService.highlightPickedFeature(pickedColors);
        }
        if (enableSelect && type === 'click' && ((_pickedColors = pickedColors) === null || _pickedColors === void 0 ? void 0 : _pickedColors.toString()) !== [0, 0, 0, 0].toString()) {
          const selectedId = decodePickingColor(pickedColors);
          if (layer.getCurrentSelectedId() === null || selectedId !== layer.getCurrentSelectedId()) {
            layer.layerPickService.selectFeature(pickedColors);
            layer.setCurrentSelectedId(selectedId);
          } else {
            layer.layerPickService.selectFeature(new Uint8Array([0, 0, 0, 0])); // toggle select
            layer.setCurrentSelectedId(null);
          }
        }
        return isPicked;
      });
      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
    this.container = container;
  }
  get mapService() {
    return this.container.mapService;
  }
  get rendererService() {
    return this.container.rendererService;
  }
  get configService() {
    return this.container.globalConfigService;
  }
  get interactionService() {
    return this.container.interactionService;
  }
  get layerService() {
    return this.container.layerService;
  }
  init(id) {
    const {
      createTexture2D,
      createFramebuffer,
      getViewportSize
    } = this.rendererService;
    let {
      width,
      height
    } = getViewportSize();
    this.pickBufferScale = this.configService.getSceneConfig(id).pickBufferScale || 1;
    width = Math.round(width / this.pickBufferScale);
    height = Math.round(height / this.pickBufferScale);
    // 创建 picking framebuffer，后续实时 resize
    const pickingColorTexture = createTexture2D({
      width,
      height,
      // wrapS: gl.CLAMP_TO_EDGE,
      // wrapT: gl.CLAMP_TO_EDGE,
      usage: TextureUsage.RENDER_TARGET,
      label: 'Picking Texture'
    });
    this.pickingFBO = createFramebuffer({
      color: pickingColorTexture,
      depth: true,
      width,
      height
    });

    // 监听 hover 事件
    this.interactionService.on(InteractionEvent.Hover, this.pickingAllLayer.bind(this));
  }
  boxPickLayer(layer, box, cb) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        useFramebufferAsync,
        clear
      } = _this2.rendererService;
      _this2.resizePickingFBO();
      layer.hooks.beforePickingEncode.call();
      yield useFramebufferAsync(_this2.pickingFBO, /*#__PURE__*/_asyncToGenerator(function* () {
        clear({
          framebuffer: _this2.pickingFBO,
          color: [0, 0, 0, 0],
          stencil: 0,
          depth: 1
        });
        layer.renderModels({
          ispick: true
        });
      }));
      layer.hooks.afterPickingEncode.call();
      const features = yield _this2.pickBox(layer, box);
      cb(features);
    })();
  }
  pickBox(layer, box) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      const [xMin, yMin, xMax, yMax] = box.map(v => {
        const tmpV = v < 0 ? 0 : v;
        return Math.floor(tmpV * DOM.DPR / _this3.pickBufferScale);
      });
      const {
        readPixelsAsync,
        getViewportSize
      } = _this3.rendererService;
      const {
        width,
        height
      } = getViewportSize();
      if (xMin > (width - 1) * DOM.DPR / _this3.pickBufferScale || xMax < 0 || yMin > (height - 1) * DOM.DPR / _this3.pickBufferScale || yMax < 0) {
        return [];
      }
      const w = Math.min(width / _this3.pickBufferScale, xMax) - xMin;
      const h = Math.min(height / _this3.pickBufferScale, yMax) - yMin;
      const pickedColors = yield readPixelsAsync({
        x: xMin,
        // 视口坐标系原点在左上，而 WebGL 在左下，需要翻转 Y 轴
        y: Math.floor(height / _this3.pickBufferScale - (yMax + 1)),
        width: w,
        height: h,
        data: new Uint8Array(w * h * 4),
        framebuffer: _this3.pickingFBO
      });
      const features = [];
      const featuresIdMap = {};
      for (let i = 0; i < pickedColors.length / 4; i = i + 1) {
        const color = pickedColors.slice(i * 4, i * 4 + 4);
        const pickedFeatureIdx = decodePickingColor(color);
        if (pickedFeatureIdx !== -1 && !featuresIdMap[pickedFeatureIdx]) {
          const rawFeature = layer.layerPickService.getFeatureById(pickedFeatureIdx);
          features.push(_objectSpread(_objectSpread({}, rawFeature), {}, {
            pickedFeatureIdx
          }));
          featuresIdMap[pickedFeatureIdx] = true;
        }
      }
      return features;
    })();
  }

  // 动态设置鼠标光标
  handleCursor(layer, type) {
    const {
      cursor = '',
      cursorEnabled
    } = layer.getLayerConfig();
    if (cursorEnabled) {
      const mapType = this.mapService.getType();
      const domContainer = mapType === 'amap' ? this.mapService.getMapContainer() : this.mapService.getMarkerContainer();
      // const domContainer = this.mapService.getMarkerContainer();
      // const domContainer = this.mapService.getMapContainer();
      const defaultCursor = domContainer === null || domContainer === void 0 ? void 0 : domContainer.style.getPropertyValue('cursor');
      if (type === 'unmousemove' && defaultCursor !== '') {
        domContainer === null || domContainer === void 0 || domContainer.style.setProperty('cursor', '');
      } else if (type === 'mousemove') {
        domContainer === null || domContainer === void 0 || domContainer.style.setProperty('cursor', cursor);
      }
    }
    // const domContainer = this.mapService.getMapContainer()
    // domContainer?.style.setProperty('cursor', 'move');
  }
  destroy() {
    this.pickingFBO.destroy();
    // this.pickingFBO = null; 清除对 webgl 实例的引用
    // @ts-ignore
    this.pickingFBO = null;
  }
  pickingAllLayer(target) {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      // 判断是否进行拾取操作
      if (!_this4.layerService.needPick(target.type) || !_this4.isPickingAllLayer()) {
        return;
      }
      _this4.alreadyInPicking = true;
      yield _this4.pickingLayers(target);
      _this4.layerService.renderLayers();
      _this4.alreadyInPicking = false;
    })();
  }
  isPickingAllLayer() {
    // this.alreadyInPicking 避免多次重复拾取

    if (this.alreadyInPicking) {
      return false;
    }
    // this.layerService.alreadyInRendering 一个渲染序列中只进行一次拾取操作
    if (this.layerService.alreadyInRendering) {
      return false;
    }
    // this.interactionService.dragging amap2 在点击操作的时候同时会触发 dragging 的情况（避免舍去）
    if (this.interactionService.indragging) {
      return false;
    }

    // 判断当前进行 shader pick 拾取判断
    if (!this.layerService.getShaderPickStat()) {
      return false;
    }

    // 进行拾取
    return true;
  }
  resizePickingFBO() {
    const {
      getViewportSize
    } = this.rendererService;
    const {
      width,
      height
    } = getViewportSize();
    if (this.width !== width || this.height !== height) {
      this.pickingFBO.resize({
        width: Math.round(width / this.pickBufferScale),
        height: Math.round(height / this.pickBufferScale)
      });
      this.width = width;
      this.height = height;
    }
  }
  pickingLayers(target) {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      const {
        clear,
        useFramebufferAsync
      } = _this5.rendererService;
      _this5.resizePickingFBO();
      const layers = _this5.layerService.getRenderList();
      for (const layer of layers.filter(layer => layer.needPick(target.type)).reverse()) {
        yield useFramebufferAsync(_this5.pickingFBO, /*#__PURE__*/_asyncToGenerator(function* () {
          clear({
            framebuffer: _this5.pickingFBO,
            color: [0, 0, 0, 0],
            stencil: 0,
            depth: 1
          });
          // 渲染需要拾取的图层
          layer.layerPickService.pickRender(target);
        }));
        const isPicked = yield _this5.pickFromPickingFBO(layer, target);
        _this5.layerService.pickedLayerId = isPicked ? +layer.id : -1;
        if (isPicked && !layer.getLayerConfig().enablePropagation) {
          break;
        }
      }
    })();
  }
  triggerHoverOnLayer(layer, target) {
    // layer.emit(target.type, target);
    // 判断是否发生事件冲突
    if (isEventCrash(target)) {
      // Tip: 允许用户动态设置鼠标光标
      this.handleCursor(layer, target.type);
      layer.emit(target.type, target);
    }
  }
}