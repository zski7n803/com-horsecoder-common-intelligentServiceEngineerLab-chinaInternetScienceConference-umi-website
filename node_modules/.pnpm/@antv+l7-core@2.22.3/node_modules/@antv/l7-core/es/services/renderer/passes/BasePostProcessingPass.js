import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
// lodashUtil
import { lodashUtil } from '@antv/l7-utils';
/* babel-plugin-inline-import '../../../shaders/post-processing/quad.glsl' */
const quad = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
import { PassType } from "../IMultiPassRenderer";
import { gl } from "../gl";
const {
  camelCase,
  isNil,
  upperFirst
} = lodashUtil;

/**
 * 后处理 Pass 基类，通过 PostProcessor 驱动。
 *
 * 约定使用 u_Texture 传递渲染纹理。
 */
export default class BasePostProcessingPass {
  constructor() {
    _defineProperty(this, "shaderModuleService", void 0);
    _defineProperty(this, "rendererService", void 0);
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "quad", quad);
    /**
     * 启用开关
     */
    _defineProperty(this, "enabled", true);
    /**
     * 是否渲染到屏幕
     */
    _defineProperty(this, "renderToScreen", false);
    /**
     * 渲染命令
     */
    _defineProperty(this, "model", void 0);
    /**
     * 效果名，便于在图层中引用
     */
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "optionsToUpdate", {});
  }
  getName() {
    return this.name;
  }
  setName(name) {
    this.name = name;
  }
  getType() {
    return PassType.PostProcessing;
  }
  init(layer, config) {
    this.config = config;
    this.rendererService = layer.getContainer().rendererService;
    this.shaderModuleService = layer.getContainer().shaderModuleService;
    const {
      createAttribute,
      createBuffer,
      createModel
    } = this.rendererService;
    const {
      vs,
      fs,
      uniforms
    } = this.setupShaders();
    this.model = createModel({
      vs,
      fs,
      attributes: {
        // 使用一个全屏三角形，相比 Quad 顶点数目更少
        a_Position: createAttribute({
          buffer: createBuffer({
            data: [-4, -4, 4, -4, 0, 4],
            type: gl.FLOAT
          }),
          size: 2
        })
      },
      // @ts-ignore
      uniforms: _objectSpread(_objectSpread({
        // @ts-ignore
        u_Texture: null
      }, uniforms), this.config && this.convertOptionsToUniforms(this.config)),
      depth: {
        enable: false
      },
      count: 3,
      blend: {
        // copy pass 需要混合
        enable: this.getName() === 'copy'
      }
    });
  }
  render(layer, tex) {
    const postProcessor = layer.multiPassRenderer.getPostProcessor();
    const {
      useFramebuffer,
      getViewportSize,
      clear
    } = this.rendererService;
    const {
      width,
      height
    } = getViewportSize();
    useFramebuffer(this.renderToScreen ? null : postProcessor.getWriteFBO(), () => {
      clear({
        framebuffer: postProcessor.getWriteFBO(),
        color: [0, 0, 0, 0],
        depth: 1,
        stencil: 0
      });
      const uniformOptions = _objectSpread({
        u_BloomFinal: 0.0,
        u_Texture: postProcessor.getReadFBO(),
        // u_Texture: tex ? tex : postProcessor.getReadFBO(),
        u_ViewportSize: [width, height]
      }, this.convertOptionsToUniforms(this.optionsToUpdate));
      if (tex) {
        uniformOptions.u_BloomFinal = 1.0;
        uniformOptions.u_Texture2 = tex;
      }
      this.model.draw({
        uniforms: uniformOptions
      });
    });
  }
  isEnabled() {
    return this.enabled;
  }
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  setRenderToScreen(renderToScreen) {
    this.renderToScreen = renderToScreen;
  }
  updateOptions(config) {
    this.optionsToUpdate = _objectSpread(_objectSpread({}, this.optionsToUpdate), config);
  }
  setupShaders() {
    throw new Error('Method not implemented.');
  }
  convertOptionsToUniforms(options) {
    const uniforms = {};
    Object.keys(options).forEach(optionName => {
      // @ts-ignore
      if (!isNil(options[optionName])) {
        uniforms[`u_${upperFirst(camelCase(optionName))}`] =
        // @ts-ignore
        options[optionName];
      }
    });
    return uniforms;
  }
}