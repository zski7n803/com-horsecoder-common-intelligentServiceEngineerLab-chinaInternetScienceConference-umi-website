import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { TextureUsage } from "../ITexture2D";
import { gl } from "../gl";

/**
 * ported from Three.js EffectComposer
 * 后处理负责 pingpong read/write framebuffer，最后一个 pass 默认输出到屏幕
 */
export default class PostProcessor {
  constructor(rendererService) {
    _defineProperty(this, "passes", []);
    _defineProperty(this, "readFBO", void 0);
    _defineProperty(this, "writeFBO", void 0);
    this.rendererService = rendererService;
    this.init();
  }
  getReadFBO() {
    return this.readFBO;
  }
  getWriteFBO() {
    return this.writeFBO;
  }

  /**
   * 从当前的 framebuffer 中获取贴图
   * @returns
   */
  getCurrentFBOTex() {
    const {
      getViewportSize,
      createTexture2D
    } = this.rendererService;
    const {
      width,
      height
    } = getViewportSize();
    return createTexture2D({
      x: 0,
      y: 0,
      width,
      height,
      copy: true
    });
  }

  /**
   * 从 readFBO 中获取贴图
   * @returns
   */
  getReadFBOTex() {
    var _this = this;
    const {
      useFramebuffer
    } = this.rendererService;
    return new Promise(resolve => {
      useFramebuffer(this.readFBO, /*#__PURE__*/_asyncToGenerator(function* () {
        resolve(_this.getCurrentFBOTex());
      }));
    });
  }
  renderBloomPass(layer, pass) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const tex = yield _this2.getReadFBOTex();
      // count 定义 bloom 交替绘制的次数
      let count = 0;
      while (count < 4) {
        yield pass.render(layer, tex);
        _this2.swap();
        count++;
      }
    })();
  }
  render(layer) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      for (let i = 0; i < _this3.passes.length; i++) {
        const pass = _this3.passes[i];
        // last pass should render to screen
        pass.setRenderToScreen(_this3.isLastEnabledPass(i));

        // await pass.render(layer);
        // // pingpong
        // if (i !== this.passes.length - 1) {
        //   this.swap();
        // }
        if (pass.getName() === 'bloom') {
          yield _this3.renderBloomPass(layer, pass);
        } else {
          yield pass.render(layer);
          // pingpong
          if (i !== _this3.passes.length - 1) {
            _this3.swap();
          }
        }
      }
    })();
  }
  resize(width, height) {
    this.readFBO.resize({
      width,
      height
    });
    this.writeFBO.resize({
      width,
      height
    });
  }
  add(pass, layer, config) {
    pass.init(layer, config);
    this.passes.push(pass);
  }
  insert(pass, index, layer, config) {
    pass.init(layer, config);
    this.passes.splice(index, 0, pass);
  }
  getPostProcessingPassByName(name) {
    return this.passes.find(p => p.getName() === name);
  }
  init() {
    const {
      createFramebuffer,
      createTexture2D
    } = this.rendererService;
    this.readFBO = createFramebuffer({
      color: createTexture2D({
        width: 1,
        height: 1,
        wrapS: gl.CLAMP_TO_EDGE,
        wrapT: gl.CLAMP_TO_EDGE,
        usage: TextureUsage.RENDER_TARGET
      })
    });
    this.writeFBO = createFramebuffer({
      color: createTexture2D({
        width: 1,
        height: 1,
        wrapS: gl.CLAMP_TO_EDGE,
        wrapT: gl.CLAMP_TO_EDGE,
        usage: TextureUsage.RENDER_TARGET
      })
    });
  }
  isLastEnabledPass(index) {
    for (let i = index + 1; i < this.passes.length; i++) {
      if (this.passes[i].isEnabled()) {
        return false;
      }
    }
    return true;
  }
  swap() {
    const tmp = this.readFBO;
    this.readFBO = this.writeFBO;
    this.writeFBO = tmp;
  }
}