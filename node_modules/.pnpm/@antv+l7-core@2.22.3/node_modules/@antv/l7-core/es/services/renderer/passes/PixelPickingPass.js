import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { decodePickingColor, DOM, encodePickingColor } from '@antv/l7-utils';
import { InteractionEvent } from "../../interaction/IInteractionService";
import { gl } from "../gl";
import { PassType } from "../IMultiPassRenderer";
import BaseNormalPass from "./BaseNormalPass";

/**
 * color-based PixelPickingPass
 * @see https://github.com/antvis/L7/blob/next/dev-docs/PixelPickingEngine.md
 * @deprecated
 * 目前未使用
 */
export default class PixelPickingPass extends BaseNormalPass {
  constructor(...args) {
    var _this;
    super(...args);
    _this = this;
    /**
     * picking framebuffer，供 attributes 颜色编码后输出
     */
    _defineProperty(this, "pickingFBO", void 0);
    /**
     * 保存 layer 引用
     */
    _defineProperty(this, "layer", void 0);
    _defineProperty(this, "width", 0);
    _defineProperty(this, "height", 0);
    /**
     * 简单的 throttle，防止连续触发 hover 时导致频繁渲染到 picking framebuffer
     */
    _defineProperty(this, "alreadyInRendering", false);
    /**
     * 拾取视口指定坐标属于的要素
     * TODO：支持区域拾取
     */
    _defineProperty(this, "pickFromPickingFBO", ({
      x,
      y,
      lngLat,
      type
    }) => {
      if (!this.layer.isVisible() || !this.layer.needPick(type)) {
        return;
      }
      const {
        getViewportSize,
        readPixelsAsync,
        useFramebuffer
      } = this.rendererService;
      const {
        width,
        height
      } = getViewportSize();
      const {
        enableHighlight,
        enableSelect
      } = this.layer.getLayerConfig();
      const xInDevicePixel = x * DOM.DPR;
      const yInDevicePixel = y * DOM.DPR;
      if (xInDevicePixel > width || xInDevicePixel < 0 || yInDevicePixel > height || yInDevicePixel < 0) {
        return;
      }
      let pickedColors;
      useFramebuffer(this.pickingFBO, /*#__PURE__*/_asyncToGenerator(function* () {
        var _pickedColors;
        // avoid realloc
        pickedColors = yield readPixelsAsync({
          x: Math.round(xInDevicePixel),
          // 视口坐标系原点在左上，而 WebGL 在左下，需要翻转 Y 轴
          y: Math.round(height - (y + 1) * DOM.DPR),
          width: 1,
          height: 1,
          data: new Uint8Array(1 * 1 * 4),
          framebuffer: _this.pickingFBO
        });
        if (pickedColors[0] !== 0 || pickedColors[1] !== 0 || pickedColors[2] !== 0) {
          const pickedFeatureIdx = decodePickingColor(pickedColors);
          const rawFeature = _this.layer.getSource().getFeatureById(pickedFeatureIdx);
          const target = {
            x,
            y,
            type,
            lngLat,
            featureId: pickedFeatureIdx,
            feature: rawFeature
          };
          if (!rawFeature) {
            // this.logger.error(
            //   '未找到颜色编码解码后的原始 feature，请检查 fragment shader 中末尾是否添加了 `gl_FragColor = filterColor(gl_FragColor);`',
            // );
          } else {
            // trigger onHover/Click callback on layer
            _this.layer.setCurrentPickId(pickedFeatureIdx);
            _this.triggerHoverOnLayer(target);
          }
        } else {
          const target = {
            x,
            y,
            lngLat,
            type: _this.layer.getCurrentPickId() === null ? 'un' + type : 'mouseout',
            featureId: null,
            feature: null
          };
          _this.triggerHoverOnLayer(_objectSpread(_objectSpread({}, target), {}, {
            type: 'unpick'
          }));
          _this.triggerHoverOnLayer(target);
          _this.layer.setCurrentPickId(null);
        }
        if (enableHighlight) {
          _this.highlightPickedFeature(pickedColors);
        }
        if (enableSelect && type === 'click' && ((_pickedColors = pickedColors) === null || _pickedColors === void 0 ? void 0 : _pickedColors.toString()) !== [0, 0, 0, 0].toString()) {
          _this.selectFeature(pickedColors);
        }
      }));
    });
  }
  getType() {
    return PassType.Normal;
  }
  getName() {
    return 'pixelPicking';
  }
  init(layer, config) {
    super.init(layer, config);
    this.layer = layer;
    const {
      createTexture2D,
      createFramebuffer,
      getViewportSize
    } = this.rendererService;
    const {
      width,
      height
    } = getViewportSize();
    // 创建 picking framebuffer，后续实时 resize
    const pickingColorTexture = createTexture2D({
      width,
      height,
      wrapS: gl.CLAMP_TO_EDGE,
      wrapT: gl.CLAMP_TO_EDGE,
      label: 'Picking Texture'
    });
    this.pickingFBO = createFramebuffer({
      color: pickingColorTexture
    });

    // 监听 hover 事件
    this.interactionService.on(InteractionEvent.Hover, this.pickFromPickingFBO);
    this.interactionService.on(InteractionEvent.Select, this.selectFeatureHandle.bind(this));
    this.interactionService.on(InteractionEvent.Active, this.highlightFeatureHandle.bind(this));
  }
  render(layer) {
    if (this.alreadyInRendering) {
      return;
    }
    const {
      getViewportSize,
      useFramebuffer,
      clear
    } = this.rendererService;
    const {
      width,
      height
    } = getViewportSize();

    // throttled
    this.alreadyInRendering = true;

    // resize first, fbo can't be resized in use
    if (this.width !== width || this.height !== height) {
      this.pickingFBO.resize({
        width,
        height
      });
      this.width = width;
      this.height = height;
    }
    useFramebuffer(this.pickingFBO, () => {
      clear({
        framebuffer: this.pickingFBO,
        color: [0, 0, 0, 0],
        stencil: 0,
        depth: 1
      });

      /**
       * picking pass 不需要 multipass，原因如下：
       * 1. 已经 clear，无需 ClearPass
       * 2. 只需要 RenderPass
       * 3. 后处理 pass 需要跳过
       */
      const originRenderFlag = this.layer.multiPassRenderer.getRenderFlag();
      this.layer.multiPassRenderer.setRenderFlag(false);
      // trigger hooks
      layer.hooks.beforePickingEncode.call();
      layer.render();
      layer.hooks.afterPickingEncode.call();
      this.layer.multiPassRenderer.setRenderFlag(originRenderFlag);
      this.alreadyInRendering = false;
    });
  }
  triggerHoverOnLayer(target) {
    this.layer.emit(target.type, target);
  }

  /**
   * highlight 如果直接修改选中 feature 的 buffer，存在两个问题：
   * 1. 鼠标移走时无法恢复
   * 2. 无法实现高亮颜色与原始原色的 alpha 混合
   * 因此高亮还是放在 shader 中做比较好
   * @example
   * this.layer.color('name', ['#000000'], {
   *  featureRange: {
   *    startIndex: pickedFeatureIdx,
   *    endIndex: pickedFeatureIdx + 1,
   *  },
   * });
   */
  highlightPickedFeature(pickedColors) {
    // @ts-ignore
    const [r, g, b] = pickedColors;
    this.layer.hooks.beforeHighlight.call([r, g, b]);
    this.layerService.renderLayers();
  }
  selectFeature(pickedColors) {
    // @ts-ignore
    const [r, g, b] = pickedColors;
    this.layer.hooks.beforeSelect.call([r, g, b]);
    this.layerService.renderLayers();
  }
  selectFeatureHandle({
    featureId
  }) {
    const pickedColors = encodePickingColor(featureId);
    this.selectFeature(new Uint8Array(pickedColors));
  }
  highlightFeatureHandle({
    featureId
  }) {
    const pickedColors = encodePickingColor(featureId);
    this.highlightPickedFeature(new Uint8Array(pickedColors));
  }
}