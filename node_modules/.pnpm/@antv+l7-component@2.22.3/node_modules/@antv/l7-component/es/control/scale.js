import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { DOM, lnglatDistance } from '@antv/l7-utils';
import { Control, PositionType } from "./baseControl";
export { Scale };
export default class Scale extends Control {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "mScale", void 0);
    _defineProperty(this, "iScale", void 0);
    _defineProperty(this, "update", () => {
      const mapsService = this.mapsService;
      const {
        maxWidth
      } = this.controlOption;
      const y = mapsService.getSize()[1] / 2;
      const p1 = mapsService.containerToLngLat([0, y]);
      const p2 = mapsService.containerToLngLat([maxWidth, y]);
      const maxMeters = lnglatDistance([p1.lng, p1.lat], [p2.lng, p2.lat]);
      this.updateScales(maxMeters);
    });
  }
  getDefault(option) {
    return _objectSpread(_objectSpread({}, super.getDefault(option)), {}, {
      name: 'scale',
      position: PositionType.BOTTOMLEFT,
      maxWidth: 100,
      metric: true,
      updateWhenIdle: false,
      imperial: false,
      lockWidth: true
    });
  }
  onAdd() {
    const className = 'l7-control-scale';
    const container = DOM.create('div', className);
    this.resetScaleLines(container);
    const {
      updateWhenIdle
    } = this.controlOption;
    this.mapsService.on(updateWhenIdle ? 'moveend' : 'mapmove', this.update);
    this.mapsService.on(updateWhenIdle ? 'zoomend' : 'zoomchange', this.update);
    return container;
  }
  onRemove() {
    const {
      updateWhenIdle
    } = this.controlOption;
    this.mapsService.off(updateWhenIdle ? 'zoomend' : 'zoomchange', this.update);
    this.mapsService.off(updateWhenIdle ? 'moveend' : 'mapmove', this.update);
  }
  setOptions(newOption) {
    super.setOptions(newOption);
    if (this.checkUpdateOption(newOption, ['lockWidth', 'maxWidth', 'metric', 'updateWhenIdle', 'imperial'])) {
      this.resetScaleLines(this.container);
    }
  }
  updateScales(maxMeters) {
    const {
      metric,
      imperial
    } = this.controlOption;
    if (metric && maxMeters) {
      this.updateMetric(maxMeters);
    }
    if (imperial && maxMeters) {
      this.updateImperial(maxMeters);
    }
  }
  resetScaleLines(container) {
    DOM.clearChildren(container);
    const {
      metric,
      imperial,
      maxWidth,
      lockWidth
    } = this.controlOption;
    if (lockWidth) {
      DOM.addStyle(container, `width: ${maxWidth}px`);
    }
    if (metric) {
      this.mScale = DOM.create('div', 'l7-control-scale-line', container);
    }
    if (imperial) {
      this.iScale = DOM.create('div', 'l7-control-scale-line', container);
    }
    this.update();
  }
  updateScale(scale, text, ratio) {
    const {
      maxWidth
    } = this.controlOption;
    scale.style.width = Math.round(maxWidth * ratio) + 'px';
    scale.innerHTML = text;
  }
  getRoundNum(num) {
    const pow10 = Math.pow(10, (Math.floor(num) + '').length - 1);
    let d = num / pow10;
    d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
    return pow10 * d;
  }
  updateMetric(maxMeters) {
    const meters = this.getRoundNum(maxMeters);
    const label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';
    this.updateScale(this.mScale, label, meters / maxMeters);
  }
  updateImperial(maxMeters) {
    const maxFeet = maxMeters * 3.2808399;
    let maxMiles;
    let miles;
    let feet;
    if (maxFeet > 5280) {
      maxMiles = maxFeet / 5280;
      miles = this.getRoundNum(maxMiles);
      this.updateScale(this.iScale, miles + ' mi', miles / maxMiles);
    } else {
      feet = this.getRoundNum(maxFeet);
      this.updateScale(this.iScale, feet + ' ft', feet / maxFeet);
    }
  }
}