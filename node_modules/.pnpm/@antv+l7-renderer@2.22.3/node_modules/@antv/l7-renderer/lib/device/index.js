var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/device/index.ts
var device_exports = {};
__export(device_exports, {
  default: () => DeviceRendererService
});
module.exports = __toCommonJS(device_exports);
var import_g_device_api = require("@antv/g-device-api");
var import_l7_utils = require("@antv/l7-utils");
var import_DeviceAttribute = __toESM(require("./DeviceAttribute"));
var import_DeviceBuffer = __toESM(require("./DeviceBuffer"));
var import_DeviceCache = require("./DeviceCache");
var import_DeviceElements = __toESM(require("./DeviceElements"));
var import_DeviceFramebuffer = __toESM(require("./DeviceFramebuffer"));
var import_DeviceModel = __toESM(require("./DeviceModel"));
var import_DeviceTexture2D = __toESM(require("./DeviceTexture2D"));
var import_webgl = require("./utils/webgl");
var { isUndefined } = import_l7_utils.lodashUtil;
var DeviceRendererService = class {
  constructor() {
    this.uniformBuffers = [];
    this.queryVerdorInfo = () => {
      return this.device.queryVendorInfo().platformString;
    };
    this.createModel = (options) => new import_DeviceModel.default(this.device, options, this);
    this.createAttribute = (options) => new import_DeviceAttribute.default(this.device, options);
    this.createBuffer = (options) => new import_DeviceBuffer.default(this.device, options);
    this.createElements = (options) => new import_DeviceElements.default(this.device, options);
    this.createTexture2D = (options) => new import_DeviceTexture2D.default(this.device, options);
    this.createFramebuffer = (options) => new import_DeviceFramebuffer.default(this.device, options);
    this.useFramebuffer = (framebuffer, drawCommands) => {
      this.currentFramebuffer = framebuffer;
      this.beginFrame();
      drawCommands();
      this.endFrame();
      this.currentFramebuffer = null;
    };
    this.useFramebufferAsync = (framebuffer, drawCommands) => __async(this, null, function* () {
      this.currentFramebuffer = framebuffer;
      this.preRenderPass = this.renderPass;
      this.beginFrame();
      yield drawCommands();
      this.endFrame();
      this.currentFramebuffer = null;
      this.renderPass = this.preRenderPass;
    });
    this.clear = (options) => {
      const { color, depth, stencil, framebuffer = null } = options;
      if (framebuffer) {
        framebuffer.clearOptions = { color, depth, stencil };
      } else {
        const platformString = this.queryVerdorInfo();
        if (platformString === "WebGL1") {
          const gl = this.getGLContext();
          if (!isUndefined(stencil)) {
            gl.clearStencil(stencil);
            gl.clear(gl.STENCIL_BUFFER_BIT);
          } else if (!isUndefined(depth)) {
            gl.clearDepth(depth);
            gl.clear(gl.DEPTH_BUFFER_BIT);
          }
        } else if (platformString === "WebGL2") {
          const gl = this.getGLContext();
          if (!isUndefined(stencil)) {
            gl.clearBufferiv(gl.STENCIL, 0, [stencil]);
          } else if (!isUndefined(depth)) {
            gl.clearBufferfv(gl.DEPTH, 0, [depth]);
          }
        }
      }
    };
    this.viewport = ({
      // x,
      // y,
      width,
      height
    }) => {
      this.swapChain.configureSwapChain(width, height);
      this.createMainColorDepthRT(width, height);
      this.width = width;
      this.height = height;
    };
    this.readPixels = (options) => {
      const { framebuffer, x, y, width, height } = options;
      const readback = this.device.createReadback();
      const texture = framebuffer["colorTexture"];
      const result = readback.readTextureSync(
        texture,
        x,
        /**
         * Origin is at lower-left corner. Width / height is already multiplied by dpr.
         * WebGPU needs flipY
         */
        this.viewportOrigin === import_g_device_api.ViewportOrigin.LOWER_LEFT ? y : this.height - y,
        width,
        height,
        new Uint8Array(width * height * 4)
      );
      if (this.viewportOrigin !== import_g_device_api.ViewportOrigin.LOWER_LEFT) {
        for (let j = 0; j < result.length; j += 4) {
          const t = result[j];
          result[j] = result[j + 2];
          result[j + 2] = t;
        }
      }
      readback.destroy();
      return result;
    };
    this.readPixelsAsync = (options) => __async(this, null, function* () {
      const { framebuffer, x, y, width, height } = options;
      const readback = this.device.createReadback();
      const texture = framebuffer["colorTexture"];
      const result = yield readback.readTexture(
        texture,
        x,
        /**
         * Origin is at lower-left corner. Width / height is already multiplied by dpr.
         * WebGPU needs flipY
         */
        this.viewportOrigin === import_g_device_api.ViewportOrigin.LOWER_LEFT ? y : this.height - y,
        width,
        height,
        new Uint8Array(width * height * 4)
      );
      if (this.viewportOrigin !== import_g_device_api.ViewportOrigin.LOWER_LEFT) {
        for (let j = 0; j < result.length; j += 4) {
          const t = result[j];
          result[j] = result[j + 2];
          result[j + 2] = t;
        }
      }
      readback.destroy();
      return result;
    });
    this.getViewportSize = () => {
      return {
        width: this.width,
        height: this.height
      };
    };
    this.getContainer = () => {
      var _a;
      return (_a = this.canvas) == null ? void 0 : _a.parentElement;
    };
    this.getCanvas = () => {
      return this.canvas;
    };
    this.getGLContext = () => {
      return this.device["gl"];
    };
    this.destroy = () => {
      var _a;
      this.canvas = null;
      (_a = this.uniformBuffers) == null ? void 0 : _a.forEach((buffer) => {
        buffer.destroy();
      });
      this.device.destroy();
      this.renderCache.destroy();
    };
  }
  init(canvas, cfg) {
    return __async(this, null, function* () {
      const { enableWebGPU, shaderCompilerPath, antialias } = cfg;
      this.canvas = canvas;
      const deviceContribution = enableWebGPU ? new import_g_device_api.WebGPUDeviceContribution({
        shaderCompilerPath
      }) : new import_g_device_api.WebGLDeviceContribution({
        // Use WebGL2 first and downgrade to WebGL1 if WebGL2 is not supported.
        targets: ["webgl2", "webgl1"],
        antialias,
        onContextLost(e) {
          console.warn("context lost", e);
        },
        onContextCreationError(e) {
          console.warn("context creation error", e);
        },
        onContextRestored(e) {
          console.warn("context restored", e);
        }
      });
      const swapChain = yield deviceContribution.createSwapChain(canvas);
      swapChain.configureSwapChain(canvas.width, canvas.height);
      this.device = swapChain.getDevice();
      this.swapChain = swapChain;
      this.renderCache = new import_DeviceCache.RenderCache(this.device);
      this.currentFramebuffer = null;
      this.viewportOrigin = this.device.queryVendorInfo().viewportOrigin;
      const gl = this.device["gl"];
      this.extensionObject = {
        // @ts-ignore
        OES_texture_float: !(0, import_webgl.isWebGL2)(gl) && this.device["OES_texture_float"]
      };
      this.createMainColorDepthRT(canvas.width, canvas.height);
    });
  }
  createMainColorDepthRT(width, height) {
    if (this.mainColorRT) {
      this.mainColorRT.destroy();
    }
    if (this.mainDepthRT) {
      this.mainDepthRT.destroy();
    }
    this.mainColorRT = this.device.createRenderTargetFromTexture(
      this.device.createTexture({
        format: import_g_device_api.Format.U8_RGBA_RT,
        width,
        height,
        usage: import_g_device_api.TextureUsage.RENDER_TARGET
      })
    );
    this.mainDepthRT = this.device.createRenderTargetFromTexture(
      this.device.createTexture({
        format: import_g_device_api.Format.D24_S8,
        width,
        height,
        usage: import_g_device_api.TextureUsage.RENDER_TARGET
      })
    );
  }
  beginFrame() {
    this.device.beginFrame();
    const { currentFramebuffer, swapChain, mainColorRT, mainDepthRT } = this;
    const colorAttachment = currentFramebuffer ? currentFramebuffer["colorRenderTarget"] : mainColorRT;
    const colorResolveTo = currentFramebuffer ? null : swapChain.getOnscreenTexture();
    const depthStencilAttachment = currentFramebuffer ? currentFramebuffer["depthRenderTarget"] : mainDepthRT;
    const { color = [0, 0, 0, 0], depth = 1, stencil = 0 } = (
      // @ts-ignore
      (currentFramebuffer == null ? void 0 : currentFramebuffer.clearOptions) || {}
    );
    const colorClearColor = colorAttachment ? (0, import_g_device_api.colorNewFromRGBA)(color[0] * 255, color[1] * 255, color[2] * 255, color[3]) : import_g_device_api.TransparentBlack;
    const depthClearValue = depthStencilAttachment ? depth : void 0;
    const stencilClearValue = depthStencilAttachment ? stencil : void 0;
    const renderPass = this.device.createRenderPass({
      colorAttachment: [colorAttachment],
      colorResolveTo: [colorResolveTo],
      colorClearColor: [colorClearColor],
      // colorStore: [!!currentFramebuffer],
      colorStore: [true],
      depthStencilAttachment,
      depthClearValue,
      stencilClearValue
    });
    this.renderPass = renderPass;
  }
  endFrame() {
    this.device.submitPass(this.renderPass);
    this.device.endFrame();
  }
  getPointSizeRange() {
    const gl = this.device["gl"];
    return gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);
  }
  testExtension(name) {
    return !!this.getGLContext().getExtension(name);
  }
  // TODO: 临时方法
  setState() {
  }
  setBaseState() {
  }
  setCustomLayerDefaults() {
  }
  setDirty(flag) {
    this.isDirty = flag;
  }
  getDirty() {
    return this.isDirty;
  }
};
