var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/device/DeviceModel.ts
var DeviceModel_exports = {};
__export(DeviceModel_exports, {
  default: () => DeviceModel
});
module.exports = __toCommonJS(DeviceModel_exports);
var import_g_device_api = require("@antv/g-device-api");
var import_l7_core = require("@antv/l7-core");
var import_l7_utils = require("@antv/l7-utils");
var import_DeviceFramebuffer = __toESM(require("./DeviceFramebuffer"));
var import_DeviceTexture2D = __toESM(require("./DeviceTexture2D"));
var import_constants = require("./constants");
var { isPlainObject, isTypedArray, isNil } = import_l7_utils.lodashUtil;
var DeviceModel = class {
  constructor(device, options, service) {
    this.device = device;
    this.options = options;
    this.service = service;
    this.destroyed = false;
    this.uniforms = {};
    this.vertexBuffers = [];
    const { vs, fs, attributes, uniforms, count, elements, diagnosticDerivativeUniformityEnabled } = options;
    this.options = options;
    const diagnosticDerivativeUniformityHeader = diagnosticDerivativeUniformityEnabled ? "" : this.service["viewportOrigin"] === import_g_device_api.ViewportOrigin.UPPER_LEFT ? "diagnostic(off,derivative_uniformity);" : "";
    this.program = service.renderCache.createProgram({
      vertex: {
        glsl: vs
      },
      fragment: {
        glsl: fs,
        postprocess: (fs2) => diagnosticDerivativeUniformityHeader + fs2
      }
    });
    if (uniforms) {
      this.uniforms = this.extractUniforms(uniforms);
    }
    const vertexBufferDescriptors = [];
    let inferredCount = 0;
    Object.keys(attributes).forEach((name) => {
      const attribute = attributes[name];
      const buffer = attribute.get();
      this.vertexBuffers.push(buffer.get());
      const {
        offset = 0,
        stride = 0,
        // TODO: normalized
        size = 1,
        divisor = 0,
        shaderLocation = 0
      } = attribute["attribute"];
      vertexBufferDescriptors.push({
        arrayStride: stride || size * 4,
        // TODO: L7 hasn't use instanced array for now.
        stepMode: import_g_device_api.VertexStepMode.VERTEX,
        attributes: [
          {
            format: import_constants.sizeFormatMap[size],
            shaderLocation,
            offset,
            divisor
          }
        ]
      });
      inferredCount = buffer["size"] / size;
    });
    if (!count) {
      this.options.count = inferredCount;
    }
    if (elements) {
      this.indexBuffer = elements.get();
    }
    const inputLayout = service.renderCache.createInputLayout({
      vertexBufferDescriptors,
      indexBufferFormat: elements ? import_g_device_api.Format.U32_R : null,
      program: this.program
    });
    this.inputLayout = inputLayout;
    this.pipeline = this.createPipeline(options);
  }
  createPipeline(options, pick) {
    var _a;
    const { primitive = import_l7_core.gl.TRIANGLES, depth, cull, blend, stencil } = options;
    const depthParams = this.initDepthDrawParams({ depth });
    const depthEnabled = !!(depthParams && depthParams.enable);
    const cullParams = this.initCullDrawParams({ cull });
    const cullEnabled = !!(cullParams && cullParams.enable);
    const blendParams = this.getBlendDrawParams({ blend });
    const blendEnabled = !!(blendParams && blendParams.enable);
    const stencilParams = this.getStencilDrawParams({ stencil });
    const stencilEnabled = !!(stencilParams && stencilParams.enable);
    const pipeline = this.device.createRenderPipeline({
      inputLayout: this.inputLayout,
      program: this.program,
      topology: import_constants.primitiveMap[primitive],
      colorAttachmentFormats: [import_g_device_api.Format.U8_RGBA_RT],
      depthStencilAttachmentFormat: import_g_device_api.Format.D24_S8,
      megaStateDescriptor: {
        attachmentsState: [
          pick ? {
            channelWriteMask: import_g_device_api.ChannelWriteMask.ALL,
            rgbBlendState: {
              blendMode: import_g_device_api.BlendMode.ADD,
              blendSrcFactor: import_g_device_api.BlendFactor.ONE,
              blendDstFactor: import_g_device_api.BlendFactor.ZERO
            },
            alphaBlendState: {
              blendMode: import_g_device_api.BlendMode.ADD,
              blendSrcFactor: import_g_device_api.BlendFactor.ONE,
              blendDstFactor: import_g_device_api.BlendFactor.ZERO
            }
          } : {
            channelWriteMask: stencilEnabled && stencilParams.opFront.zpass === import_g_device_api.StencilOp.REPLACE ? import_g_device_api.ChannelWriteMask.NONE : import_g_device_api.ChannelWriteMask.ALL,
            rgbBlendState: {
              blendMode: blendEnabled && blendParams.equation.rgb || import_g_device_api.BlendMode.ADD,
              blendSrcFactor: blendEnabled && blendParams.func.srcRGB || import_g_device_api.BlendFactor.SRC_ALPHA,
              blendDstFactor: blendEnabled && blendParams.func.dstRGB || import_g_device_api.BlendFactor.ONE_MINUS_SRC_ALPHA
            },
            alphaBlendState: {
              blendMode: blendEnabled && blendParams.equation.alpha || import_g_device_api.BlendMode.ADD,
              blendSrcFactor: blendEnabled && blendParams.func.srcAlpha || import_g_device_api.BlendFactor.ONE,
              blendDstFactor: blendEnabled && blendParams.func.dstAlpha || import_g_device_api.BlendFactor.ONE
            }
          }
        ],
        blendConstant: blendEnabled ? import_g_device_api.TransparentBlack : void 0,
        depthWrite: depthEnabled,
        depthCompare: depthEnabled && depthParams.func || import_g_device_api.CompareFunction.LESS,
        cullMode: cullEnabled && cullParams.face || import_g_device_api.CullMode.NONE,
        stencilWrite: stencilEnabled,
        stencilFront: {
          compare: stencilEnabled ? stencilParams.func.cmp : import_g_device_api.CompareFunction.ALWAYS,
          passOp: stencilParams.opFront.zpass,
          failOp: stencilParams.opFront.fail,
          depthFailOp: stencilParams.opFront.zfail,
          mask: stencilParams.opFront.mask
        },
        stencilBack: {
          compare: stencilEnabled ? stencilParams.func.cmp : import_g_device_api.CompareFunction.ALWAYS,
          passOp: stencilParams.opBack.zpass,
          failOp: stencilParams.opBack.fail,
          depthFailOp: stencilParams.opBack.zfail,
          mask: stencilParams.opBack.mask
        }
      }
    });
    if (stencilEnabled && !isNil((_a = stencil == null ? void 0 : stencil.func) == null ? void 0 : _a.ref)) {
      pipeline.stencilFuncReference = stencil.func.ref;
    }
    return pipeline;
  }
  updateAttributesAndElements() {
  }
  /**
   * No need to implement this method, you should update data on `Attribute` like this:
   *
   * @example
   * ```ts
   * attribute.updateBuffer({
   *   data: [],
   *   offset: 0,
   * });
   * ```
   */
  updateAttributes() {
  }
  addUniforms(uniforms) {
    this.uniforms = __spreadValues(__spreadValues({}, this.uniforms), this.extractUniforms(uniforms));
  }
  draw(options, pick) {
    const mergedOptions = __spreadValues(__spreadValues({}, this.options), options);
    const {
      count = 0,
      instances,
      elements,
      uniforms = {},
      uniformBuffers,
      textures
    } = mergedOptions;
    this.uniforms = __spreadValues(__spreadValues({}, this.uniforms), this.extractUniforms(uniforms));
    const { renderPass, currentFramebuffer, width, height } = this.service;
    this.pipeline = this.createPipeline(mergedOptions, pick);
    const device = this.service["device"];
    const tmpHeight = device["swapChainHeight"];
    device["swapChainHeight"] = (currentFramebuffer == null ? void 0 : currentFramebuffer["height"]) || height;
    renderPass.setViewport(
      0,
      0,
      (currentFramebuffer == null ? void 0 : currentFramebuffer["width"]) || width,
      (currentFramebuffer == null ? void 0 : currentFramebuffer["height"]) || height
    );
    device["swapChainHeight"] = tmpHeight;
    renderPass.setPipeline(this.pipeline);
    if (!isNil(this.pipeline.stencilFuncReference)) {
      renderPass.setStencilReference(this.pipeline.stencilFuncReference);
    }
    renderPass.setVertexInput(
      this.inputLayout,
      this.vertexBuffers.map((buffer) => ({
        buffer
      })),
      elements ? {
        buffer: this.indexBuffer,
        offset: 0
      } : null
    );
    if (uniformBuffers) {
      this.bindings = device.createBindings({
        pipeline: this.pipeline,
        uniformBufferBindings: uniformBuffers.map((uniformBuffer, i) => {
          const buffer = uniformBuffer;
          return {
            binding: i,
            buffer: buffer.get(),
            size: buffer["size"]
          };
        }),
        samplerBindings: textures == null ? void 0 : textures.map((t) => ({
          texture: t["texture"],
          sampler: t["sampler"]
        }))
      });
    }
    if (this.bindings) {
      renderPass.setBindings(this.bindings);
      Object.keys(this.uniforms).forEach((uniformName) => {
        const uniform = this.uniforms[uniformName];
        if (uniform instanceof import_DeviceTexture2D.default) {
          this.uniforms[uniformName] = uniform.get();
        } else if (uniform instanceof import_DeviceFramebuffer.default) {
          this.uniforms[uniformName] = uniform.get()["texture"];
        }
      });
      this.program.setUniformsLegacy(this.uniforms);
    }
    if (elements) {
      const indexCount = elements["count"];
      if (indexCount === 0) {
        renderPass.draw(count, instances);
      } else {
        renderPass.drawIndexed(indexCount, instances);
      }
    } else {
      renderPass.draw(count, instances);
    }
  }
  destroy() {
    var _a, _b, _c;
    (_a = this.vertexBuffers) == null ? void 0 : _a.forEach((buffer) => buffer.destroy());
    (_b = this.indexBuffer) == null ? void 0 : _b.destroy();
    (_c = this.bindings) == null ? void 0 : _c.destroy();
    this.pipeline.destroy();
    this.destroyed = true;
  }
  initDepthDrawParams({ depth }) {
    if (depth) {
      return {
        enable: depth.enable === void 0 ? true : !!depth.enable,
        mask: depth.mask === void 0 ? true : !!depth.mask,
        func: import_constants.depthFuncMap[depth.func || import_l7_core.gl.LESS],
        range: depth.range || [0, 1]
      };
    }
  }
  getBlendDrawParams({ blend }) {
    const { enable, func, equation, color = [0, 0, 0, 0] } = blend || {};
    return {
      enable: !!enable,
      func: {
        srcRGB: import_constants.blendFuncMap[func && func.srcRGB || import_l7_core.gl.SRC_ALPHA],
        srcAlpha: import_constants.blendFuncMap[func && func.srcAlpha || import_l7_core.gl.SRC_ALPHA],
        dstRGB: import_constants.blendFuncMap[func && func.dstRGB || import_l7_core.gl.ONE_MINUS_SRC_ALPHA],
        dstAlpha: import_constants.blendFuncMap[func && func.dstAlpha || import_l7_core.gl.ONE_MINUS_SRC_ALPHA]
      },
      equation: {
        rgb: import_constants.blendEquationMap[equation && equation.rgb || import_l7_core.gl.FUNC_ADD],
        alpha: import_constants.blendEquationMap[equation && equation.alpha || import_l7_core.gl.FUNC_ADD]
      },
      color
    };
  }
  /**
   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#stencil
   */
  getStencilDrawParams({ stencil }) {
    const {
      enable,
      mask = 4294967295,
      func = {
        cmp: import_l7_core.gl.ALWAYS,
        ref: 0,
        mask: 4294967295
      },
      opFront = {
        fail: import_l7_core.gl.KEEP,
        zfail: import_l7_core.gl.KEEP,
        zpass: import_l7_core.gl.KEEP
      },
      opBack = {
        fail: import_l7_core.gl.KEEP,
        zfail: import_l7_core.gl.KEEP,
        zpass: import_l7_core.gl.KEEP
      }
    } = stencil || {};
    return {
      enable: !!enable,
      mask,
      func: __spreadProps(__spreadValues({}, func), {
        cmp: import_constants.stencilFuncMap[func.cmp]
      }),
      opFront: {
        fail: import_constants.stencilOpMap[opFront.fail],
        zfail: import_constants.stencilOpMap[opFront.zfail],
        zpass: import_constants.stencilOpMap[opFront.zpass],
        mask: func.mask
      },
      opBack: {
        fail: import_constants.stencilOpMap[opBack.fail],
        zfail: import_constants.stencilOpMap[opBack.zfail],
        zpass: import_constants.stencilOpMap[opBack.zpass],
        mask: func.mask
      }
    };
  }
  /**
   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#culling
   */
  initCullDrawParams({ cull }) {
    if (cull) {
      const { enable, face = import_l7_core.gl.BACK } = cull;
      return {
        enable: !!enable,
        face: import_constants.cullFaceMap[face]
      };
    }
  }
  /**
   * 考虑结构体命名, eg:
   * a: { b: 1 }  ->  'a.b'
   * a: [ { b: 1 } ] -> 'a[0].b'
   */
  extractUniforms(uniforms) {
    const extractedUniforms = {};
    Object.keys(uniforms).forEach((uniformName) => {
      this.extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, "");
    });
    return extractedUniforms;
  }
  extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix) {
    if (uniformValue === null || typeof uniformValue === "number" || // u_A: 1
    typeof uniformValue === "boolean" || // u_A: false
    Array.isArray(uniformValue) && typeof uniformValue[0] === "number" || // u_A: [1, 2, 3]
    isTypedArray(uniformValue) || // u_A: Float32Array
    // @ts-ignore
    uniformValue === "" || "resize" in uniformValue) {
      uniforms[`${prefix && prefix + "."}${uniformName}`] = uniformValue;
      return;
    }
    if (isPlainObject(uniformValue)) {
      Object.keys(uniformValue).forEach((childName) => {
        this.extractUniformsRecursively(
          childName,
          // @ts-ignore
          uniformValue[childName],
          uniforms,
          `${prefix && prefix + "."}${uniformName}`
        );
      });
    }
    if (Array.isArray(uniformValue)) {
      uniformValue.forEach((child, idx) => {
        Object.keys(child).forEach((childName) => {
          this.extractUniformsRecursively(
            childName,
            // @ts-ignore
            child[childName],
            uniforms,
            `${prefix && prefix + "."}${uniformName}[${idx}]`
          );
        });
      });
    }
  }
};
