var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/device/DeviceCache.ts
var DeviceCache_exports = {};
__export(DeviceCache_exports, {
  RenderCache: () => RenderCache
});
module.exports = __toCommonJS(DeviceCache_exports);
var import_g_device_api = require("@antv/g-device-api");
var import_HashMap = require("./utils/HashMap");
function blendStateHash(hash, a) {
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.blendMode);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.blendSrcFactor);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.blendDstFactor);
  return hash;
}
function attachmentStateHash(hash, a) {
  hash = blendStateHash(hash, a.rgbBlendState);
  hash = blendStateHash(hash, a.alphaBlendState);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.channelWriteMask);
  return hash;
}
function colorHash(hash, a) {
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.r << 24 | a.g << 16 | a.b << 8 | a.a);
  return hash;
}
function megaStateDescriptorHash(hash, a) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  for (let i = 0; i < a.attachmentsState.length; i++)
    hash = attachmentStateHash(hash, a.attachmentsState[i]);
  hash = colorHash(hash, a.blendConstant || import_g_device_api.TransparentBlack);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.depthCompare);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.depthWrite ? 1 : 0);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, (_a = a.stencilFront) == null ? void 0 : _a.compare);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, (_b = a.stencilFront) == null ? void 0 : _b.passOp);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, (_c = a.stencilFront) == null ? void 0 : _c.failOp);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, (_d = a.stencilFront) == null ? void 0 : _d.depthFailOp);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, (_e = a.stencilBack) == null ? void 0 : _e.compare);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, (_f = a.stencilBack) == null ? void 0 : _f.passOp);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, (_g = a.stencilBack) == null ? void 0 : _g.failOp);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, (_h = a.stencilBack) == null ? void 0 : _h.depthFailOp);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.stencilWrite ? 1 : 0);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.cullMode);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.frontFace ? 1 : 0);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.polygonOffset ? 1 : 0);
  return hash;
}
function renderPipelineDescriptorHash(a) {
  let hash = 0;
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.program.id);
  if (a.inputLayout !== null)
    hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.inputLayout.id);
  hash = megaStateDescriptorHash(hash, a.megaStateDescriptor);
  for (let i = 0; i < a.colorAttachmentFormats.length; i++)
    hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.colorAttachmentFormats[i] || 0);
  hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, a.depthStencilAttachmentFormat || 0);
  return (0, import_HashMap.hashCodeNumberFinish)(hash);
}
function bindingsDescriptorHash(a) {
  let hash = 0;
  if (a.samplerBindings) {
    for (let i = 0; i < a.samplerBindings.length; i++) {
      const binding = a.samplerBindings[i];
      if (binding !== null && binding.texture !== null)
        hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, binding.texture.id);
    }
  }
  if (a.uniformBufferBindings) {
    for (let i = 0; i < a.uniformBufferBindings.length; i++) {
      const binding = a.uniformBufferBindings[i];
      if (binding !== null && binding.buffer !== null) {
        hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, binding.buffer.id);
        hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, binding.binding);
        hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, binding.offset);
        hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, binding.size);
      }
    }
  }
  if (a.storageBufferBindings) {
    for (let i = 0; i < a.storageBufferBindings.length; i++) {
      const binding = a.storageBufferBindings[i];
      if (binding !== null && binding.buffer !== null) {
        hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, binding.buffer.id);
        hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, binding.binding);
        hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, binding.offset);
        hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, binding.size);
      }
    }
  }
  if (a.storageTextureBindings) {
    for (let i = 0; i < a.storageTextureBindings.length; i++) {
      const binding = a.storageTextureBindings[i];
      if (binding !== null && binding.texture !== null) {
        hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, binding.texture.id);
        hash = (0, import_HashMap.hashCodeNumberUpdate)(hash, binding.binding);
      }
    }
  }
  return (0, import_HashMap.hashCodeNumberFinish)(hash);
}
function programDescriptorEquals(a, b) {
  var _a, _b, _c, _d;
  return ((_a = a.vertex) == null ? void 0 : _a.glsl) === ((_b = b.vertex) == null ? void 0 : _b.glsl) && ((_c = a.fragment) == null ? void 0 : _c.glsl) === ((_d = b.fragment) == null ? void 0 : _d.glsl);
}
function programDescriptorCopy(a) {
  var _a, _b;
  return {
    vertex: {
      glsl: (_a = a.vertex) == null ? void 0 : _a.glsl
    },
    fragment: {
      glsl: (_b = a.fragment) == null ? void 0 : _b.glsl
    }
  };
}
var RenderCache = class {
  constructor(device) {
    this.device = device;
    this.bindingsCache = new import_HashMap.HashMap(
      import_g_device_api.bindingsDescriptorEquals,
      bindingsDescriptorHash
    );
    this.renderPipelinesCache = new import_HashMap.HashMap(
      import_g_device_api.renderPipelineDescriptorEquals,
      renderPipelineDescriptorHash
    );
    this.inputLayoutsCache = new import_HashMap.HashMap(
      import_g_device_api.inputLayoutDescriptorEquals,
      import_HashMap.nullHashFunc
    );
    this.programCache = new import_HashMap.HashMap(
      programDescriptorEquals,
      import_HashMap.nullHashFunc
    );
  }
  createBindings(descriptor) {
    var _a;
    let bindings = this.bindingsCache.get(descriptor);
    if (bindings === null) {
      const descriptorCopy = (0, import_g_device_api.bindingsDescriptorCopy)(descriptor);
      descriptorCopy.uniformBufferBindings = (_a = descriptorCopy.uniformBufferBindings) == null ? void 0 : _a.filter(
        ({ size }) => size && size > 0
      );
      bindings = this.device.createBindings(descriptorCopy);
      this.bindingsCache.add(descriptorCopy, bindings);
    }
    return bindings;
  }
  createRenderPipeline(descriptor) {
    let renderPipeline = this.renderPipelinesCache.get(descriptor);
    if (renderPipeline === null) {
      const descriptorCopy = (0, import_g_device_api.renderPipelineDescriptorCopy)(descriptor);
      descriptorCopy.colorAttachmentFormats = descriptorCopy.colorAttachmentFormats.filter(
        (f) => f
      );
      renderPipeline = this.device.createRenderPipeline(descriptorCopy);
      this.renderPipelinesCache.add(descriptorCopy, renderPipeline);
    }
    return renderPipeline;
  }
  createInputLayout(descriptor) {
    descriptor.vertexBufferDescriptors = descriptor.vertexBufferDescriptors.filter((d) => !!d);
    let inputLayout = this.inputLayoutsCache.get(descriptor);
    if (inputLayout === null) {
      const descriptorCopy = (0, import_g_device_api.inputLayoutDescriptorCopy)(descriptor);
      inputLayout = this.device.createInputLayout(descriptorCopy);
      this.inputLayoutsCache.add(descriptorCopy, inputLayout);
    }
    return inputLayout;
  }
  createProgram(descriptor) {
    let program = this.programCache.get(descriptor);
    if (program === null) {
      const descriptorCopy = programDescriptorCopy(descriptor);
      program = this.device.createProgram(descriptor);
      this.programCache.add(descriptorCopy, program);
    }
    return program;
  }
  destroy() {
    for (const bindings of this.bindingsCache.values())
      bindings.destroy();
    for (const renderPipeline of this.renderPipelinesCache.values())
      renderPipeline.destroy();
    for (const inputLayout of this.inputLayoutsCache.values())
      inputLayout.destroy();
    for (const program of this.programCache.values())
      program.destroy();
    this.bindingsCache.clear();
    this.renderPipelinesCache.clear();
    this.inputLayoutsCache.clear();
    this.programCache.clear();
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  RenderCache
});
