var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/regl/index.ts
import regl from "regl";
import ReglAttribute from "./ReglAttribute";
import ReglBuffer from "./ReglBuffer";
import ReglElements from "./ReglElements";
import ReglFramebuffer from "./ReglFramebuffer";
import ReglModel from "./ReglModel";
import ReglTexture2D from "./ReglTexture2D";
var ReglRendererService = class {
  constructor() {
    this.uniformBuffers = [];
    this.queryVerdorInfo = () => {
      return "WebGL1";
    };
    this.createModel = (options) => new ReglModel(this.gl, options);
    this.createAttribute = (options) => new ReglAttribute(this.gl, options);
    this.createBuffer = (options) => new ReglBuffer(this.gl, options);
    this.createElements = (options) => new ReglElements(this.gl, options);
    this.createTexture2D = (options) => new ReglTexture2D(this.gl, options);
    this.createFramebuffer = (options) => new ReglFramebuffer(this.gl, options);
    this.useFramebuffer = (framebuffer, drawCommands) => {
      this.gl({
        framebuffer: framebuffer ? framebuffer.get() : null
      })(drawCommands);
    };
    this.useFramebufferAsync = (framebuffer, drawCommands) => __async(this, null, function* () {
      this.gl({
        framebuffer: framebuffer ? framebuffer.get() : null
      })(drawCommands);
    });
    this.clear = (options) => {
      var _a;
      const { color, depth, stencil, framebuffer = null } = options;
      const reglClearOptions = {
        color,
        depth,
        stencil
      };
      reglClearOptions.framebuffer = framebuffer === null ? framebuffer : framebuffer.get();
      (_a = this.gl) == null ? void 0 : _a.clear(reglClearOptions);
    };
    this.viewport = ({
      x,
      y,
      width,
      height
    }) => {
      this.gl._gl.viewport(x, y, width, height);
      this.width = width;
      this.height = height;
      this.gl._refresh();
    };
    this.readPixels = (options) => {
      const { framebuffer, x, y, width, height } = options;
      const readPixelsOptions = {
        x,
        y,
        width,
        height
      };
      if (framebuffer) {
        readPixelsOptions.framebuffer = framebuffer.get();
      }
      return this.gl.read(readPixelsOptions);
    };
    this.readPixelsAsync = (options) => __async(this, null, function* () {
      return this.readPixels(options);
    });
    this.getViewportSize = () => {
      return {
        width: this.gl._gl.drawingBufferWidth,
        height: this.gl._gl.drawingBufferHeight
      };
    };
    this.getContainer = () => {
      var _a;
      return (_a = this.canvas) == null ? void 0 : _a.parentElement;
    };
    this.getCanvas = () => {
      return this.canvas;
    };
    this.getGLContext = () => {
      return this.gl._gl;
    };
    this.destroy = () => {
      var _a, _b, _c;
      this.canvas = null;
      (_c = (_b = (_a = this.gl) == null ? void 0 : _a._gl) == null ? void 0 : _b.getExtension("WEBGL_lose_context")) == null ? void 0 : _c.loseContext();
      this.gl.destroy();
      this.gl = null;
    };
  }
  init(canvas, cfg, gl) {
    return __async(this, null, function* () {
      this.canvas = canvas;
      if (gl) {
        this.gl = gl;
      } else {
        this.gl = yield new Promise((resolve, reject) => {
          regl({
            canvas: this.canvas,
            attributes: {
              alpha: true,
              // use TAA instead of MSAA
              // @see https://www.khronos.org/registry/webgl/specs/1.0/#5.2.1
              antialias: cfg.antialias,
              premultipliedAlpha: true,
              preserveDrawingBuffer: cfg.preserveDrawingBuffer,
              stencil: cfg.stencil
            },
            // TODO: use extensions
            extensions: [
              "OES_element_index_uint",
              "OES_standard_derivatives",
              // wireframe
              "ANGLE_instanced_arrays"
              // VSM shadow map
            ],
            optionalExtensions: [
              "oes_texture_float_linear",
              "OES_texture_float",
              "EXT_texture_filter_anisotropic",
              "EXT_blend_minmax",
              "WEBGL_depth_texture",
              "WEBGL_lose_context"
            ],
            profile: true,
            onDone: (err, r) => {
              if (err || !r) {
                reject(err);
              }
              resolve(r);
            }
          });
        });
      }
      this.extensionObject = {
        OES_texture_float: this.testExtension("OES_texture_float")
      };
    });
  }
  getPointSizeRange() {
    return this.gl._gl.getParameter(this.gl._gl.ALIASED_POINT_SIZE_RANGE);
  }
  testExtension(name) {
    return !!this.getGLContext().getExtension(name);
  }
  // TODO: 临时方法
  setState() {
    this.gl({
      cull: {
        enable: false,
        face: "back"
      },
      viewport: {
        x: 0,
        y: 0,
        height: this.width,
        width: this.height
      },
      blend: {
        enable: true,
        equation: "add"
      },
      framebuffer: null
    });
    this.gl._refresh();
  }
  setBaseState() {
    this.gl({
      cull: {
        enable: false,
        face: "back"
      },
      viewport: {
        x: 0,
        y: 0,
        height: this.width,
        width: this.height
      },
      blend: {
        enable: false,
        equation: "add"
      },
      framebuffer: null
    });
    this.gl._refresh();
  }
  setCustomLayerDefaults() {
    const gl = this.getGLContext();
    gl.disable(gl.CULL_FACE);
  }
  setDirty(flag) {
    this.isDirty = flag;
  }
  getDirty() {
    return this.isDirty;
  }
  beginFrame() {
  }
  endFrame() {
  }
};
export {
  ReglRendererService as default
};
