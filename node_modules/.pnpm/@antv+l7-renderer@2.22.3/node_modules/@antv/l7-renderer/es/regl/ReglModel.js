var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/regl/ReglModel.ts
import { ClipSpaceNearZ, preprocessShader_GLSL, ViewportOrigin } from "@antv/g-device-api";
import { gl, removeDuplicateUniforms } from "@antv/l7-core";
import { lodashUtil } from "@antv/l7-utils";
import {
  blendEquationMap,
  blendFuncMap,
  cullFaceMap,
  depthFuncMap,
  primitiveMap,
  stencilFuncMap,
  stencilOpMap
} from "./constants";
var { isPlainObject, isTypedArray } = lodashUtil;
var ReglModel = class {
  constructor(reGl, options) {
    this.destroyed = false;
    this.uniforms = {};
    this.reGl = reGl;
    const { vs, fs, attributes, uniforms, primitive, count, elements, depth, cull, instances } = options;
    const vendorInfo = {
      platformString: "WebGL1",
      glslVersion: "#version 100",
      explicitBindingLocations: false,
      separateSamplerTextures: false,
      viewportOrigin: ViewportOrigin.LOWER_LEFT,
      clipSpaceNearZ: ClipSpaceNearZ.NEGATIVE_ONE,
      supportMRT: false
    };
    const reglUniforms = {};
    this.options = options;
    if (uniforms) {
      this.uniforms = this.extractUniforms(uniforms);
      Object.keys(uniforms).forEach((uniformName) => {
        reglUniforms[uniformName] = reGl.prop(uniformName);
      });
    }
    const reglAttributes = {};
    Object.keys(attributes).forEach((name) => {
      reglAttributes[name] = attributes[name].get();
    });
    const frag = removeDuplicateUniforms(
      preprocessShader_GLSL(vendorInfo, "frag", fs, null, false)
    );
    const vert = removeDuplicateUniforms(
      preprocessShader_GLSL(vendorInfo, "vert", vs, null, false)
    );
    const drawParams = {
      attributes: reglAttributes,
      frag,
      uniforms: reglUniforms,
      vert,
      // @ts-ignore
      colorMask: reGl.prop("colorMask"),
      lineWidth: 1,
      blend: {
        // @ts-ignore
        enable: reGl.prop("blend.enable"),
        // @ts-ignore
        func: reGl.prop("blend.func"),
        // @ts-ignore
        equation: reGl.prop("blend.equation"),
        // @ts-ignore
        color: reGl.prop("blend.color")
      },
      stencil: {
        // @ts-ignore
        enable: reGl.prop("stencil.enable"),
        // @ts-ignore
        mask: reGl.prop("stencil.mask"),
        // @ts-ignore
        func: reGl.prop("stencil.func"),
        // @ts-ignore
        opFront: reGl.prop("stencil.opFront"),
        // @ts-ignore
        opBack: reGl.prop("stencil.opBack")
      },
      primitive: primitiveMap[primitive === void 0 ? gl.TRIANGLES : primitive]
    };
    if (instances) {
      drawParams.instances = instances;
    }
    if (count) {
      drawParams.count = count;
    } else if (elements) {
      drawParams.elements = elements.get();
    }
    this.initDepthDrawParams({ depth }, drawParams);
    this.initCullDrawParams({ cull }, drawParams);
    this.drawCommand = reGl(drawParams);
    this.drawParams = drawParams;
  }
  updateAttributesAndElements(attributes, elements) {
    const reglAttributes = {};
    Object.keys(attributes).forEach((name) => {
      reglAttributes[name] = attributes[name].get();
    });
    this.drawParams.attributes = reglAttributes;
    this.drawParams.elements = elements.get();
    this.drawCommand = this.reGl(this.drawParams);
  }
  updateAttributes(attributes) {
    const reglAttributes = {};
    Object.keys(attributes).forEach((name) => {
      reglAttributes[name] = attributes[name].get();
    });
    this.drawParams.attributes = reglAttributes;
    this.drawCommand = this.reGl(this.drawParams);
  }
  addUniforms(uniforms) {
    this.uniforms = __spreadValues(__spreadValues({}, this.uniforms), this.extractUniforms(uniforms));
  }
  draw(options, pick) {
    if (this.drawParams.attributes && Object.keys(this.drawParams.attributes).length === 0) {
      return;
    }
    const uniforms = __spreadValues(__spreadValues({}, this.uniforms), this.extractUniforms(options.uniforms || {}));
    const reglDrawProps = {};
    Object.keys(uniforms).forEach((uniformName) => {
      const type = typeof uniforms[uniformName];
      if (type === "boolean" || type === "number" || Array.isArray(uniforms[uniformName]) || // @ts-ignore
      uniforms[uniformName].BYTES_PER_ELEMENT) {
        reglDrawProps[uniformName] = uniforms[uniformName];
      } else {
        reglDrawProps[uniformName] = uniforms[uniformName].get();
      }
    });
    reglDrawProps.blend = pick ? this.getBlendDrawParams({
      blend: { enable: false }
    }) : this.getBlendDrawParams(options);
    reglDrawProps.stencil = this.getStencilDrawParams(options);
    reglDrawProps.colorMask = this.getColorMaskDrawParams(options, pick);
    this.drawCommand(reglDrawProps);
  }
  destroy() {
    var _a, _b;
    (_b = (_a = this.drawParams) == null ? void 0 : _a.elements) == null ? void 0 : _b.destroy();
    if (this.options.attributes) {
      Object.values(this.options.attributes).forEach((attr) => {
        attr == null ? void 0 : attr.destroy();
      });
    }
    this.destroyed = true;
  }
  /**
   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#depth-buffer
   */
  initDepthDrawParams({ depth }, drawParams) {
    if (depth) {
      drawParams.depth = {
        enable: depth.enable === void 0 ? true : !!depth.enable,
        mask: depth.mask === void 0 ? true : !!depth.mask,
        func: depthFuncMap[depth.func || gl.LESS],
        range: depth.range || [0, 1]
      };
    }
  }
  getBlendDrawParams({ blend }) {
    const { enable, func, equation, color = [0, 0, 0, 0] } = blend || {};
    return {
      enable: !!enable,
      func: {
        srcRGB: blendFuncMap[func && func.srcRGB || gl.SRC_ALPHA],
        srcAlpha: blendFuncMap[func && func.srcAlpha || gl.SRC_ALPHA],
        dstRGB: blendFuncMap[func && func.dstRGB || gl.ONE_MINUS_SRC_ALPHA],
        dstAlpha: blendFuncMap[func && func.dstAlpha || gl.ONE_MINUS_SRC_ALPHA]
      },
      equation: {
        rgb: blendEquationMap[equation && equation.rgb || gl.FUNC_ADD],
        alpha: blendEquationMap[equation && equation.alpha || gl.FUNC_ADD]
      },
      color
    };
  }
  /**
   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#stencil
   */
  getStencilDrawParams({ stencil }) {
    const {
      enable,
      mask = -1,
      func = {
        cmp: gl.ALWAYS,
        ref: 0,
        mask: -1
      },
      opFront = {
        fail: gl.KEEP,
        zfail: gl.KEEP,
        zpass: gl.KEEP
      },
      opBack = {
        fail: gl.KEEP,
        zfail: gl.KEEP,
        zpass: gl.KEEP
      }
    } = stencil || {};
    return {
      enable: !!enable,
      mask,
      func: __spreadProps(__spreadValues({}, func), {
        cmp: stencilFuncMap[func.cmp]
      }),
      opFront: {
        fail: stencilOpMap[opFront.fail],
        zfail: stencilOpMap[opFront.zfail],
        zpass: stencilOpMap[opFront.zpass]
      },
      opBack: {
        fail: stencilOpMap[opBack.fail],
        zfail: stencilOpMap[opBack.zfail],
        zpass: stencilOpMap[opBack.zpass]
      }
    };
  }
  getColorMaskDrawParams({ stencil }, pick) {
    const colorMask = (stencil == null ? void 0 : stencil.enable) && stencil.opFront && !pick ? [false, false, false, false] : [true, true, true, true];
    return colorMask;
  }
  /**
   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#culling
   */
  initCullDrawParams({ cull }, drawParams) {
    if (cull) {
      const { enable, face = gl.BACK } = cull;
      drawParams.cull = {
        enable: !!enable,
        face: cullFaceMap[face]
      };
    }
  }
  /**
   * 考虑结构体命名, eg:
   * a: { b: 1 }  ->  'a.b'
   * a: [ { b: 1 } ] -> 'a[0].b'
   */
  extractUniforms(uniforms) {
    const extractedUniforms = {};
    Object.keys(uniforms).forEach((uniformName) => {
      this.extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, "");
    });
    return extractedUniforms;
  }
  extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix) {
    if (uniformValue === null || typeof uniformValue === "number" || // u_A: 1
    typeof uniformValue === "boolean" || // u_A: false
    Array.isArray(uniformValue) && typeof uniformValue[0] === "number" || // u_A: [1, 2, 3]
    isTypedArray(uniformValue) || // u_A: Float32Array
    // @ts-ignore
    uniformValue === "" || "resize" in uniformValue) {
      uniforms[`${prefix && prefix + "."}${uniformName}`] = uniformValue;
      return;
    }
    if (isPlainObject(uniformValue)) {
      Object.keys(uniformValue).forEach((childName) => {
        this.extractUniformsRecursively(
          childName,
          // @ts-ignore
          uniformValue[childName],
          uniforms,
          `${prefix && prefix + "."}${uniformName}`
        );
      });
    }
    if (Array.isArray(uniformValue)) {
      uniformValue.forEach((child, idx) => {
        Object.keys(child).forEach((childName) => {
          this.extractUniformsRecursively(
            childName,
            // @ts-ignore
            child[childName],
            uniforms,
            `${prefix && prefix + "."}${uniformName}[${idx}]`
          );
        });
      });
    }
  }
};
export {
  ReglModel as default
};
