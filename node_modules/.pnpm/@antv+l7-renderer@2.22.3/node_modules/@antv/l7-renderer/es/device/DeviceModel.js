var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/device/DeviceModel.ts
import {
  BlendFactor,
  BlendMode,
  ChannelWriteMask,
  CompareFunction,
  CullMode,
  Format,
  StencilOp,
  TransparentBlack,
  VertexStepMode,
  ViewportOrigin
} from "@antv/g-device-api";
import { gl } from "@antv/l7-core";
import { lodashUtil } from "@antv/l7-utils";
import DeviceFramebuffer from "./DeviceFramebuffer";
import DeviceTexture2D from "./DeviceTexture2D";
import {
  blendEquationMap,
  blendFuncMap,
  cullFaceMap,
  depthFuncMap,
  primitiveMap,
  sizeFormatMap,
  stencilFuncMap,
  stencilOpMap
} from "./constants";
var { isPlainObject, isTypedArray, isNil } = lodashUtil;
var DeviceModel = class {
  constructor(device, options, service) {
    this.device = device;
    this.options = options;
    this.service = service;
    this.destroyed = false;
    this.uniforms = {};
    this.vertexBuffers = [];
    const { vs, fs, attributes, uniforms, count, elements, diagnosticDerivativeUniformityEnabled } = options;
    this.options = options;
    const diagnosticDerivativeUniformityHeader = diagnosticDerivativeUniformityEnabled ? "" : this.service["viewportOrigin"] === ViewportOrigin.UPPER_LEFT ? "diagnostic(off,derivative_uniformity);" : "";
    this.program = service.renderCache.createProgram({
      vertex: {
        glsl: vs
      },
      fragment: {
        glsl: fs,
        postprocess: (fs2) => diagnosticDerivativeUniformityHeader + fs2
      }
    });
    if (uniforms) {
      this.uniforms = this.extractUniforms(uniforms);
    }
    const vertexBufferDescriptors = [];
    let inferredCount = 0;
    Object.keys(attributes).forEach((name) => {
      const attribute = attributes[name];
      const buffer = attribute.get();
      this.vertexBuffers.push(buffer.get());
      const {
        offset = 0,
        stride = 0,
        // TODO: normalized
        size = 1,
        divisor = 0,
        shaderLocation = 0
      } = attribute["attribute"];
      vertexBufferDescriptors.push({
        arrayStride: stride || size * 4,
        // TODO: L7 hasn't use instanced array for now.
        stepMode: VertexStepMode.VERTEX,
        attributes: [
          {
            format: sizeFormatMap[size],
            shaderLocation,
            offset,
            divisor
          }
        ]
      });
      inferredCount = buffer["size"] / size;
    });
    if (!count) {
      this.options.count = inferredCount;
    }
    if (elements) {
      this.indexBuffer = elements.get();
    }
    const inputLayout = service.renderCache.createInputLayout({
      vertexBufferDescriptors,
      indexBufferFormat: elements ? Format.U32_R : null,
      program: this.program
    });
    this.inputLayout = inputLayout;
    this.pipeline = this.createPipeline(options);
  }
  createPipeline(options, pick) {
    var _a;
    const { primitive = gl.TRIANGLES, depth, cull, blend, stencil } = options;
    const depthParams = this.initDepthDrawParams({ depth });
    const depthEnabled = !!(depthParams && depthParams.enable);
    const cullParams = this.initCullDrawParams({ cull });
    const cullEnabled = !!(cullParams && cullParams.enable);
    const blendParams = this.getBlendDrawParams({ blend });
    const blendEnabled = !!(blendParams && blendParams.enable);
    const stencilParams = this.getStencilDrawParams({ stencil });
    const stencilEnabled = !!(stencilParams && stencilParams.enable);
    const pipeline = this.device.createRenderPipeline({
      inputLayout: this.inputLayout,
      program: this.program,
      topology: primitiveMap[primitive],
      colorAttachmentFormats: [Format.U8_RGBA_RT],
      depthStencilAttachmentFormat: Format.D24_S8,
      megaStateDescriptor: {
        attachmentsState: [
          pick ? {
            channelWriteMask: ChannelWriteMask.ALL,
            rgbBlendState: {
              blendMode: BlendMode.ADD,
              blendSrcFactor: BlendFactor.ONE,
              blendDstFactor: BlendFactor.ZERO
            },
            alphaBlendState: {
              blendMode: BlendMode.ADD,
              blendSrcFactor: BlendFactor.ONE,
              blendDstFactor: BlendFactor.ZERO
            }
          } : {
            channelWriteMask: stencilEnabled && stencilParams.opFront.zpass === StencilOp.REPLACE ? ChannelWriteMask.NONE : ChannelWriteMask.ALL,
            rgbBlendState: {
              blendMode: blendEnabled && blendParams.equation.rgb || BlendMode.ADD,
              blendSrcFactor: blendEnabled && blendParams.func.srcRGB || BlendFactor.SRC_ALPHA,
              blendDstFactor: blendEnabled && blendParams.func.dstRGB || BlendFactor.ONE_MINUS_SRC_ALPHA
            },
            alphaBlendState: {
              blendMode: blendEnabled && blendParams.equation.alpha || BlendMode.ADD,
              blendSrcFactor: blendEnabled && blendParams.func.srcAlpha || BlendFactor.ONE,
              blendDstFactor: blendEnabled && blendParams.func.dstAlpha || BlendFactor.ONE
            }
          }
        ],
        blendConstant: blendEnabled ? TransparentBlack : void 0,
        depthWrite: depthEnabled,
        depthCompare: depthEnabled && depthParams.func || CompareFunction.LESS,
        cullMode: cullEnabled && cullParams.face || CullMode.NONE,
        stencilWrite: stencilEnabled,
        stencilFront: {
          compare: stencilEnabled ? stencilParams.func.cmp : CompareFunction.ALWAYS,
          passOp: stencilParams.opFront.zpass,
          failOp: stencilParams.opFront.fail,
          depthFailOp: stencilParams.opFront.zfail,
          mask: stencilParams.opFront.mask
        },
        stencilBack: {
          compare: stencilEnabled ? stencilParams.func.cmp : CompareFunction.ALWAYS,
          passOp: stencilParams.opBack.zpass,
          failOp: stencilParams.opBack.fail,
          depthFailOp: stencilParams.opBack.zfail,
          mask: stencilParams.opBack.mask
        }
      }
    });
    if (stencilEnabled && !isNil((_a = stencil == null ? void 0 : stencil.func) == null ? void 0 : _a.ref)) {
      pipeline.stencilFuncReference = stencil.func.ref;
    }
    return pipeline;
  }
  updateAttributesAndElements() {
  }
  /**
   * No need to implement this method, you should update data on `Attribute` like this:
   *
   * @example
   * ```ts
   * attribute.updateBuffer({
   *   data: [],
   *   offset: 0,
   * });
   * ```
   */
  updateAttributes() {
  }
  addUniforms(uniforms) {
    this.uniforms = __spreadValues(__spreadValues({}, this.uniforms), this.extractUniforms(uniforms));
  }
  draw(options, pick) {
    const mergedOptions = __spreadValues(__spreadValues({}, this.options), options);
    const {
      count = 0,
      instances,
      elements,
      uniforms = {},
      uniformBuffers,
      textures
    } = mergedOptions;
    this.uniforms = __spreadValues(__spreadValues({}, this.uniforms), this.extractUniforms(uniforms));
    const { renderPass, currentFramebuffer, width, height } = this.service;
    this.pipeline = this.createPipeline(mergedOptions, pick);
    const device = this.service["device"];
    const tmpHeight = device["swapChainHeight"];
    device["swapChainHeight"] = (currentFramebuffer == null ? void 0 : currentFramebuffer["height"]) || height;
    renderPass.setViewport(
      0,
      0,
      (currentFramebuffer == null ? void 0 : currentFramebuffer["width"]) || width,
      (currentFramebuffer == null ? void 0 : currentFramebuffer["height"]) || height
    );
    device["swapChainHeight"] = tmpHeight;
    renderPass.setPipeline(this.pipeline);
    if (!isNil(this.pipeline.stencilFuncReference)) {
      renderPass.setStencilReference(this.pipeline.stencilFuncReference);
    }
    renderPass.setVertexInput(
      this.inputLayout,
      this.vertexBuffers.map((buffer) => ({
        buffer
      })),
      elements ? {
        buffer: this.indexBuffer,
        offset: 0
      } : null
    );
    if (uniformBuffers) {
      this.bindings = device.createBindings({
        pipeline: this.pipeline,
        uniformBufferBindings: uniformBuffers.map((uniformBuffer, i) => {
          const buffer = uniformBuffer;
          return {
            binding: i,
            buffer: buffer.get(),
            size: buffer["size"]
          };
        }),
        samplerBindings: textures == null ? void 0 : textures.map((t) => ({
          texture: t["texture"],
          sampler: t["sampler"]
        }))
      });
    }
    if (this.bindings) {
      renderPass.setBindings(this.bindings);
      Object.keys(this.uniforms).forEach((uniformName) => {
        const uniform = this.uniforms[uniformName];
        if (uniform instanceof DeviceTexture2D) {
          this.uniforms[uniformName] = uniform.get();
        } else if (uniform instanceof DeviceFramebuffer) {
          this.uniforms[uniformName] = uniform.get()["texture"];
        }
      });
      this.program.setUniformsLegacy(this.uniforms);
    }
    if (elements) {
      const indexCount = elements["count"];
      if (indexCount === 0) {
        renderPass.draw(count, instances);
      } else {
        renderPass.drawIndexed(indexCount, instances);
      }
    } else {
      renderPass.draw(count, instances);
    }
  }
  destroy() {
    var _a, _b, _c;
    (_a = this.vertexBuffers) == null ? void 0 : _a.forEach((buffer) => buffer.destroy());
    (_b = this.indexBuffer) == null ? void 0 : _b.destroy();
    (_c = this.bindings) == null ? void 0 : _c.destroy();
    this.pipeline.destroy();
    this.destroyed = true;
  }
  initDepthDrawParams({ depth }) {
    if (depth) {
      return {
        enable: depth.enable === void 0 ? true : !!depth.enable,
        mask: depth.mask === void 0 ? true : !!depth.mask,
        func: depthFuncMap[depth.func || gl.LESS],
        range: depth.range || [0, 1]
      };
    }
  }
  getBlendDrawParams({ blend }) {
    const { enable, func, equation, color = [0, 0, 0, 0] } = blend || {};
    return {
      enable: !!enable,
      func: {
        srcRGB: blendFuncMap[func && func.srcRGB || gl.SRC_ALPHA],
        srcAlpha: blendFuncMap[func && func.srcAlpha || gl.SRC_ALPHA],
        dstRGB: blendFuncMap[func && func.dstRGB || gl.ONE_MINUS_SRC_ALPHA],
        dstAlpha: blendFuncMap[func && func.dstAlpha || gl.ONE_MINUS_SRC_ALPHA]
      },
      equation: {
        rgb: blendEquationMap[equation && equation.rgb || gl.FUNC_ADD],
        alpha: blendEquationMap[equation && equation.alpha || gl.FUNC_ADD]
      },
      color
    };
  }
  /**
   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#stencil
   */
  getStencilDrawParams({ stencil }) {
    const {
      enable,
      mask = 4294967295,
      func = {
        cmp: gl.ALWAYS,
        ref: 0,
        mask: 4294967295
      },
      opFront = {
        fail: gl.KEEP,
        zfail: gl.KEEP,
        zpass: gl.KEEP
      },
      opBack = {
        fail: gl.KEEP,
        zfail: gl.KEEP,
        zpass: gl.KEEP
      }
    } = stencil || {};
    return {
      enable: !!enable,
      mask,
      func: __spreadProps(__spreadValues({}, func), {
        cmp: stencilFuncMap[func.cmp]
      }),
      opFront: {
        fail: stencilOpMap[opFront.fail],
        zfail: stencilOpMap[opFront.zfail],
        zpass: stencilOpMap[opFront.zpass],
        mask: func.mask
      },
      opBack: {
        fail: stencilOpMap[opBack.fail],
        zfail: stencilOpMap[opBack.zfail],
        zpass: stencilOpMap[opBack.zpass],
        mask: func.mask
      }
    };
  }
  /**
   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#culling
   */
  initCullDrawParams({ cull }) {
    if (cull) {
      const { enable, face = gl.BACK } = cull;
      return {
        enable: !!enable,
        face: cullFaceMap[face]
      };
    }
  }
  /**
   * 考虑结构体命名, eg:
   * a: { b: 1 }  ->  'a.b'
   * a: [ { b: 1 } ] -> 'a[0].b'
   */
  extractUniforms(uniforms) {
    const extractedUniforms = {};
    Object.keys(uniforms).forEach((uniformName) => {
      this.extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, "");
    });
    return extractedUniforms;
  }
  extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix) {
    if (uniformValue === null || typeof uniformValue === "number" || // u_A: 1
    typeof uniformValue === "boolean" || // u_A: false
    Array.isArray(uniformValue) && typeof uniformValue[0] === "number" || // u_A: [1, 2, 3]
    isTypedArray(uniformValue) || // u_A: Float32Array
    // @ts-ignore
    uniformValue === "" || "resize" in uniformValue) {
      uniforms[`${prefix && prefix + "."}${uniformName}`] = uniformValue;
      return;
    }
    if (isPlainObject(uniformValue)) {
      Object.keys(uniformValue).forEach((childName) => {
        this.extractUniformsRecursively(
          childName,
          // @ts-ignore
          uniformValue[childName],
          uniforms,
          `${prefix && prefix + "."}${uniformName}`
        );
      });
    }
    if (Array.isArray(uniformValue)) {
      uniformValue.forEach((child, idx) => {
        Object.keys(child).forEach((childName) => {
          this.extractUniformsRecursively(
            childName,
            // @ts-ignore
            child[childName],
            uniforms,
            `${prefix && prefix + "."}${uniformName}[${idx}]`
          );
        });
      });
    }
  }
};
export {
  DeviceModel as default
};
