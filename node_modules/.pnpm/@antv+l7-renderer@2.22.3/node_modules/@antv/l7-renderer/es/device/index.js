var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/device/index.ts
import {
  Format,
  TextureUsage,
  TransparentBlack,
  ViewportOrigin,
  WebGLDeviceContribution,
  WebGPUDeviceContribution,
  colorNewFromRGBA
} from "@antv/g-device-api";
import { lodashUtil } from "@antv/l7-utils";
import DeviceAttribute from "./DeviceAttribute";
import DeviceBuffer from "./DeviceBuffer";
import { RenderCache } from "./DeviceCache";
import DeviceElements from "./DeviceElements";
import DeviceFramebuffer from "./DeviceFramebuffer";
import DeviceModel from "./DeviceModel";
import DeviceTexture2D from "./DeviceTexture2D";
import { isWebGL2 } from "./utils/webgl";
var { isUndefined } = lodashUtil;
var DeviceRendererService = class {
  constructor() {
    this.uniformBuffers = [];
    this.queryVerdorInfo = () => {
      return this.device.queryVendorInfo().platformString;
    };
    this.createModel = (options) => new DeviceModel(this.device, options, this);
    this.createAttribute = (options) => new DeviceAttribute(this.device, options);
    this.createBuffer = (options) => new DeviceBuffer(this.device, options);
    this.createElements = (options) => new DeviceElements(this.device, options);
    this.createTexture2D = (options) => new DeviceTexture2D(this.device, options);
    this.createFramebuffer = (options) => new DeviceFramebuffer(this.device, options);
    this.useFramebuffer = (framebuffer, drawCommands) => {
      this.currentFramebuffer = framebuffer;
      this.beginFrame();
      drawCommands();
      this.endFrame();
      this.currentFramebuffer = null;
    };
    this.useFramebufferAsync = (framebuffer, drawCommands) => __async(this, null, function* () {
      this.currentFramebuffer = framebuffer;
      this.preRenderPass = this.renderPass;
      this.beginFrame();
      yield drawCommands();
      this.endFrame();
      this.currentFramebuffer = null;
      this.renderPass = this.preRenderPass;
    });
    this.clear = (options) => {
      const { color, depth, stencil, framebuffer = null } = options;
      if (framebuffer) {
        framebuffer.clearOptions = { color, depth, stencil };
      } else {
        const platformString = this.queryVerdorInfo();
        if (platformString === "WebGL1") {
          const gl = this.getGLContext();
          if (!isUndefined(stencil)) {
            gl.clearStencil(stencil);
            gl.clear(gl.STENCIL_BUFFER_BIT);
          } else if (!isUndefined(depth)) {
            gl.clearDepth(depth);
            gl.clear(gl.DEPTH_BUFFER_BIT);
          }
        } else if (platformString === "WebGL2") {
          const gl = this.getGLContext();
          if (!isUndefined(stencil)) {
            gl.clearBufferiv(gl.STENCIL, 0, [stencil]);
          } else if (!isUndefined(depth)) {
            gl.clearBufferfv(gl.DEPTH, 0, [depth]);
          }
        }
      }
    };
    this.viewport = ({
      // x,
      // y,
      width,
      height
    }) => {
      this.swapChain.configureSwapChain(width, height);
      this.createMainColorDepthRT(width, height);
      this.width = width;
      this.height = height;
    };
    this.readPixels = (options) => {
      const { framebuffer, x, y, width, height } = options;
      const readback = this.device.createReadback();
      const texture = framebuffer["colorTexture"];
      const result = readback.readTextureSync(
        texture,
        x,
        /**
         * Origin is at lower-left corner. Width / height is already multiplied by dpr.
         * WebGPU needs flipY
         */
        this.viewportOrigin === ViewportOrigin.LOWER_LEFT ? y : this.height - y,
        width,
        height,
        new Uint8Array(width * height * 4)
      );
      if (this.viewportOrigin !== ViewportOrigin.LOWER_LEFT) {
        for (let j = 0; j < result.length; j += 4) {
          const t = result[j];
          result[j] = result[j + 2];
          result[j + 2] = t;
        }
      }
      readback.destroy();
      return result;
    };
    this.readPixelsAsync = (options) => __async(this, null, function* () {
      const { framebuffer, x, y, width, height } = options;
      const readback = this.device.createReadback();
      const texture = framebuffer["colorTexture"];
      const result = yield readback.readTexture(
        texture,
        x,
        /**
         * Origin is at lower-left corner. Width / height is already multiplied by dpr.
         * WebGPU needs flipY
         */
        this.viewportOrigin === ViewportOrigin.LOWER_LEFT ? y : this.height - y,
        width,
        height,
        new Uint8Array(width * height * 4)
      );
      if (this.viewportOrigin !== ViewportOrigin.LOWER_LEFT) {
        for (let j = 0; j < result.length; j += 4) {
          const t = result[j];
          result[j] = result[j + 2];
          result[j + 2] = t;
        }
      }
      readback.destroy();
      return result;
    });
    this.getViewportSize = () => {
      return {
        width: this.width,
        height: this.height
      };
    };
    this.getContainer = () => {
      var _a;
      return (_a = this.canvas) == null ? void 0 : _a.parentElement;
    };
    this.getCanvas = () => {
      return this.canvas;
    };
    this.getGLContext = () => {
      return this.device["gl"];
    };
    this.destroy = () => {
      var _a;
      this.canvas = null;
      (_a = this.uniformBuffers) == null ? void 0 : _a.forEach((buffer) => {
        buffer.destroy();
      });
      this.device.destroy();
      this.renderCache.destroy();
    };
  }
  init(canvas, cfg) {
    return __async(this, null, function* () {
      const { enableWebGPU, shaderCompilerPath, antialias } = cfg;
      this.canvas = canvas;
      const deviceContribution = enableWebGPU ? new WebGPUDeviceContribution({
        shaderCompilerPath
      }) : new WebGLDeviceContribution({
        // Use WebGL2 first and downgrade to WebGL1 if WebGL2 is not supported.
        targets: ["webgl2", "webgl1"],
        antialias,
        onContextLost(e) {
          console.warn("context lost", e);
        },
        onContextCreationError(e) {
          console.warn("context creation error", e);
        },
        onContextRestored(e) {
          console.warn("context restored", e);
        }
      });
      const swapChain = yield deviceContribution.createSwapChain(canvas);
      swapChain.configureSwapChain(canvas.width, canvas.height);
      this.device = swapChain.getDevice();
      this.swapChain = swapChain;
      this.renderCache = new RenderCache(this.device);
      this.currentFramebuffer = null;
      this.viewportOrigin = this.device.queryVendorInfo().viewportOrigin;
      const gl = this.device["gl"];
      this.extensionObject = {
        // @ts-ignore
        OES_texture_float: !isWebGL2(gl) && this.device["OES_texture_float"]
      };
      this.createMainColorDepthRT(canvas.width, canvas.height);
    });
  }
  createMainColorDepthRT(width, height) {
    if (this.mainColorRT) {
      this.mainColorRT.destroy();
    }
    if (this.mainDepthRT) {
      this.mainDepthRT.destroy();
    }
    this.mainColorRT = this.device.createRenderTargetFromTexture(
      this.device.createTexture({
        format: Format.U8_RGBA_RT,
        width,
        height,
        usage: TextureUsage.RENDER_TARGET
      })
    );
    this.mainDepthRT = this.device.createRenderTargetFromTexture(
      this.device.createTexture({
        format: Format.D24_S8,
        width,
        height,
        usage: TextureUsage.RENDER_TARGET
      })
    );
  }
  beginFrame() {
    this.device.beginFrame();
    const { currentFramebuffer, swapChain, mainColorRT, mainDepthRT } = this;
    const colorAttachment = currentFramebuffer ? currentFramebuffer["colorRenderTarget"] : mainColorRT;
    const colorResolveTo = currentFramebuffer ? null : swapChain.getOnscreenTexture();
    const depthStencilAttachment = currentFramebuffer ? currentFramebuffer["depthRenderTarget"] : mainDepthRT;
    const { color = [0, 0, 0, 0], depth = 1, stencil = 0 } = (
      // @ts-ignore
      (currentFramebuffer == null ? void 0 : currentFramebuffer.clearOptions) || {}
    );
    const colorClearColor = colorAttachment ? colorNewFromRGBA(color[0] * 255, color[1] * 255, color[2] * 255, color[3]) : TransparentBlack;
    const depthClearValue = depthStencilAttachment ? depth : void 0;
    const stencilClearValue = depthStencilAttachment ? stencil : void 0;
    const renderPass = this.device.createRenderPass({
      colorAttachment: [colorAttachment],
      colorResolveTo: [colorResolveTo],
      colorClearColor: [colorClearColor],
      // colorStore: [!!currentFramebuffer],
      colorStore: [true],
      depthStencilAttachment,
      depthClearValue,
      stencilClearValue
    });
    this.renderPass = renderPass;
  }
  endFrame() {
    this.device.submitPass(this.renderPass);
    this.device.endFrame();
  }
  getPointSizeRange() {
    const gl = this.device["gl"];
    return gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);
  }
  testExtension(name) {
    return !!this.getGLContext().getExtension(name);
  }
  // TODO: 临时方法
  setState() {
  }
  setBaseState() {
  }
  setCustomLayerDefaults() {
  }
  setDirty(flag) {
    this.isDirty = flag;
  }
  getDirty() {
    return this.isDirty;
  }
};
export {
  DeviceRendererService as default
};
