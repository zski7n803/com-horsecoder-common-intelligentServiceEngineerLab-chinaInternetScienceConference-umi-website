// src/device/DeviceCache.ts
import {
  TransparentBlack,
  bindingsDescriptorCopy,
  bindingsDescriptorEquals,
  inputLayoutDescriptorCopy,
  inputLayoutDescriptorEquals,
  renderPipelineDescriptorCopy,
  renderPipelineDescriptorEquals
} from "@antv/g-device-api";
import { HashMap, hashCodeNumberFinish, hashCodeNumberUpdate, nullHashFunc } from "./utils/HashMap";
function blendStateHash(hash, a) {
  hash = hashCodeNumberUpdate(hash, a.blendMode);
  hash = hashCodeNumberUpdate(hash, a.blendSrcFactor);
  hash = hashCodeNumberUpdate(hash, a.blendDstFactor);
  return hash;
}
function attachmentStateHash(hash, a) {
  hash = blendStateHash(hash, a.rgbBlendState);
  hash = blendStateHash(hash, a.alphaBlendState);
  hash = hashCodeNumberUpdate(hash, a.channelWriteMask);
  return hash;
}
function colorHash(hash, a) {
  hash = hashCodeNumberUpdate(hash, a.r << 24 | a.g << 16 | a.b << 8 | a.a);
  return hash;
}
function megaStateDescriptorHash(hash, a) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  for (let i = 0; i < a.attachmentsState.length; i++)
    hash = attachmentStateHash(hash, a.attachmentsState[i]);
  hash = colorHash(hash, a.blendConstant || TransparentBlack);
  hash = hashCodeNumberUpdate(hash, a.depthCompare);
  hash = hashCodeNumberUpdate(hash, a.depthWrite ? 1 : 0);
  hash = hashCodeNumberUpdate(hash, (_a = a.stencilFront) == null ? void 0 : _a.compare);
  hash = hashCodeNumberUpdate(hash, (_b = a.stencilFront) == null ? void 0 : _b.passOp);
  hash = hashCodeNumberUpdate(hash, (_c = a.stencilFront) == null ? void 0 : _c.failOp);
  hash = hashCodeNumberUpdate(hash, (_d = a.stencilFront) == null ? void 0 : _d.depthFailOp);
  hash = hashCodeNumberUpdate(hash, (_e = a.stencilBack) == null ? void 0 : _e.compare);
  hash = hashCodeNumberUpdate(hash, (_f = a.stencilBack) == null ? void 0 : _f.passOp);
  hash = hashCodeNumberUpdate(hash, (_g = a.stencilBack) == null ? void 0 : _g.failOp);
  hash = hashCodeNumberUpdate(hash, (_h = a.stencilBack) == null ? void 0 : _h.depthFailOp);
  hash = hashCodeNumberUpdate(hash, a.stencilWrite ? 1 : 0);
  hash = hashCodeNumberUpdate(hash, a.cullMode);
  hash = hashCodeNumberUpdate(hash, a.frontFace ? 1 : 0);
  hash = hashCodeNumberUpdate(hash, a.polygonOffset ? 1 : 0);
  return hash;
}
function renderPipelineDescriptorHash(a) {
  let hash = 0;
  hash = hashCodeNumberUpdate(hash, a.program.id);
  if (a.inputLayout !== null)
    hash = hashCodeNumberUpdate(hash, a.inputLayout.id);
  hash = megaStateDescriptorHash(hash, a.megaStateDescriptor);
  for (let i = 0; i < a.colorAttachmentFormats.length; i++)
    hash = hashCodeNumberUpdate(hash, a.colorAttachmentFormats[i] || 0);
  hash = hashCodeNumberUpdate(hash, a.depthStencilAttachmentFormat || 0);
  return hashCodeNumberFinish(hash);
}
function bindingsDescriptorHash(a) {
  let hash = 0;
  if (a.samplerBindings) {
    for (let i = 0; i < a.samplerBindings.length; i++) {
      const binding = a.samplerBindings[i];
      if (binding !== null && binding.texture !== null)
        hash = hashCodeNumberUpdate(hash, binding.texture.id);
    }
  }
  if (a.uniformBufferBindings) {
    for (let i = 0; i < a.uniformBufferBindings.length; i++) {
      const binding = a.uniformBufferBindings[i];
      if (binding !== null && binding.buffer !== null) {
        hash = hashCodeNumberUpdate(hash, binding.buffer.id);
        hash = hashCodeNumberUpdate(hash, binding.binding);
        hash = hashCodeNumberUpdate(hash, binding.offset);
        hash = hashCodeNumberUpdate(hash, binding.size);
      }
    }
  }
  if (a.storageBufferBindings) {
    for (let i = 0; i < a.storageBufferBindings.length; i++) {
      const binding = a.storageBufferBindings[i];
      if (binding !== null && binding.buffer !== null) {
        hash = hashCodeNumberUpdate(hash, binding.buffer.id);
        hash = hashCodeNumberUpdate(hash, binding.binding);
        hash = hashCodeNumberUpdate(hash, binding.offset);
        hash = hashCodeNumberUpdate(hash, binding.size);
      }
    }
  }
  if (a.storageTextureBindings) {
    for (let i = 0; i < a.storageTextureBindings.length; i++) {
      const binding = a.storageTextureBindings[i];
      if (binding !== null && binding.texture !== null) {
        hash = hashCodeNumberUpdate(hash, binding.texture.id);
        hash = hashCodeNumberUpdate(hash, binding.binding);
      }
    }
  }
  return hashCodeNumberFinish(hash);
}
function programDescriptorEquals(a, b) {
  var _a, _b, _c, _d;
  return ((_a = a.vertex) == null ? void 0 : _a.glsl) === ((_b = b.vertex) == null ? void 0 : _b.glsl) && ((_c = a.fragment) == null ? void 0 : _c.glsl) === ((_d = b.fragment) == null ? void 0 : _d.glsl);
}
function programDescriptorCopy(a) {
  var _a, _b;
  return {
    vertex: {
      glsl: (_a = a.vertex) == null ? void 0 : _a.glsl
    },
    fragment: {
      glsl: (_b = a.fragment) == null ? void 0 : _b.glsl
    }
  };
}
var RenderCache = class {
  constructor(device) {
    this.device = device;
    this.bindingsCache = new HashMap(
      bindingsDescriptorEquals,
      bindingsDescriptorHash
    );
    this.renderPipelinesCache = new HashMap(
      renderPipelineDescriptorEquals,
      renderPipelineDescriptorHash
    );
    this.inputLayoutsCache = new HashMap(
      inputLayoutDescriptorEquals,
      nullHashFunc
    );
    this.programCache = new HashMap(
      programDescriptorEquals,
      nullHashFunc
    );
  }
  createBindings(descriptor) {
    var _a;
    let bindings = this.bindingsCache.get(descriptor);
    if (bindings === null) {
      const descriptorCopy = bindingsDescriptorCopy(descriptor);
      descriptorCopy.uniformBufferBindings = (_a = descriptorCopy.uniformBufferBindings) == null ? void 0 : _a.filter(
        ({ size }) => size && size > 0
      );
      bindings = this.device.createBindings(descriptorCopy);
      this.bindingsCache.add(descriptorCopy, bindings);
    }
    return bindings;
  }
  createRenderPipeline(descriptor) {
    let renderPipeline = this.renderPipelinesCache.get(descriptor);
    if (renderPipeline === null) {
      const descriptorCopy = renderPipelineDescriptorCopy(descriptor);
      descriptorCopy.colorAttachmentFormats = descriptorCopy.colorAttachmentFormats.filter(
        (f) => f
      );
      renderPipeline = this.device.createRenderPipeline(descriptorCopy);
      this.renderPipelinesCache.add(descriptorCopy, renderPipeline);
    }
    return renderPipeline;
  }
  createInputLayout(descriptor) {
    descriptor.vertexBufferDescriptors = descriptor.vertexBufferDescriptors.filter((d) => !!d);
    let inputLayout = this.inputLayoutsCache.get(descriptor);
    if (inputLayout === null) {
      const descriptorCopy = inputLayoutDescriptorCopy(descriptor);
      inputLayout = this.device.createInputLayout(descriptorCopy);
      this.inputLayoutsCache.add(descriptorCopy, inputLayout);
    }
    return inputLayout;
  }
  createProgram(descriptor) {
    let program = this.programCache.get(descriptor);
    if (program === null) {
      const descriptorCopy = programDescriptorCopy(descriptor);
      program = this.device.createProgram(descriptor);
      this.programCache.add(descriptorCopy, program);
    }
    return program;
  }
  destroy() {
    for (const bindings of this.bindingsCache.values())
      bindings.destroy();
    for (const renderPipeline of this.renderPipelinesCache.values())
      renderPipeline.destroy();
    for (const inputLayout of this.inputLayoutsCache.values())
      inputLayout.destroy();
    for (const program of this.programCache.values())
      program.destroy();
    this.bindingsCache.clear();
    this.renderPipelinesCache.clear();
    this.inputLayoutsCache.clear();
    this.programCache.clear();
  }
};
export {
  RenderCache
};
