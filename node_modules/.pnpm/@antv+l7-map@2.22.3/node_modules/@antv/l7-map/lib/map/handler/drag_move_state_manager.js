"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OneFingerTouchMoveStateManager = exports.MouseMoveStateManager = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _dom = require("../util/dom");
const LEFT_BUTTON = 0;
const RIGHT_BUTTON = 2;

// the values for each button in MouseEvent.buttons
const BUTTONS_FLAGS = {
  [LEFT_BUTTON]: 1,
  [RIGHT_BUTTON]: 2
};
function buttonNoLongerPressed(e, button) {
  const flag = BUTTONS_FLAGS[button];
  return e.buttons === undefined || (e.buttons & flag) !== flag;
}

/*
 * Drag events are initiated by specific interaction which needs to be tracked until it ends.
 * This requires some state management:
 * 1. registering the initiating event,
 * 2. tracking that it was not canceled / not confusing it with another event firing.
 * 3. recognizing the ending event and cleaning up any internal state
 *
 * Concretely, we implement two state managers:
 * 1. MouseMoveStateManager
 *      Receives a functions that is used to recognize mouse events that should be registered as the
 *      relevant drag interactions - i.e. dragging with the right mouse button, or while CTRL is pressed.
 * 2. OneFingerTouchMoveStateManager
 *      Checks if a drag event is using one finger, and continuously tracking that this is the same event
 *      (i.e. to make sure not additional finger has started interacting with the screen before raising
 *      the first finger).
 */

class MouseMoveStateManager {
  constructor(options) {
    (0, _defineProperty2.default)(this, "_eventButton", void 0);
    (0, _defineProperty2.default)(this, "_correctEvent", void 0);
    this._correctEvent = options.checkCorrectEvent;
  }
  startMove(e) {
    const eventButton = _dom.DOM.mouseButton(e);
    this._eventButton = eventButton;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  endMove(_e) {
    delete this._eventButton;
  }
  isValidStartEvent(e) {
    return this._correctEvent(e);
  }
  isValidMoveEvent(e) {
    // Some browsers don't fire a `mouseup` when the mouseup occurs outside
    // the window or iframe:
    // https://github.com/mapbox/mapbox-gl-js/issues/4622
    //
    // If the button is no longer pressed during this `mousemove` it may have
    // been released outside of the window or iframe.
    return !buttonNoLongerPressed(e, this._eventButton);
  }
  isValidEndEvent(e) {
    const eventButton = _dom.DOM.mouseButton(e);
    return eventButton === this._eventButton;
  }
}
exports.MouseMoveStateManager = MouseMoveStateManager;
class OneFingerTouchMoveStateManager {
  constructor() {
    (0, _defineProperty2.default)(this, "_firstTouch", void 0);
    this._firstTouch = undefined;
  }
  _isOneFingerTouch(e) {
    return e.targetTouches.length === 1;
  }
  _isSameTouchEvent(e) {
    return e.targetTouches[0].identifier === this._firstTouch;
  }
  startMove(e) {
    const firstTouch = e.targetTouches[0].identifier;
    this._firstTouch = firstTouch;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  endMove(_e) {
    delete this._firstTouch;
  }
  isValidStartEvent(e) {
    return this._isOneFingerTouch(e);
  }
  isValidMoveEvent(e) {
    return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
  }
  isValidEndEvent(e) {
    return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
  }
}
exports.OneFingerTouchMoveStateManager = OneFingerTouchMoveStateManager;