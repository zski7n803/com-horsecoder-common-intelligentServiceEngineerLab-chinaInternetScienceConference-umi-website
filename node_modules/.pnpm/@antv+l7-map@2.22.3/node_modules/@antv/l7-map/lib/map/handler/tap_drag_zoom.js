"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TapDragZoomHandler = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _tap_recognizer = require("./tap_recognizer");
/**
 * A `TapDragZoomHandler` allows the user to zoom the map at a point by double tapping. It also allows the user pan the map by dragging.
 */
class TapDragZoomHandler {
  constructor() {
    (0, _defineProperty2.default)(this, "_enabled", void 0);
    (0, _defineProperty2.default)(this, "_active", void 0);
    (0, _defineProperty2.default)(this, "_swipePoint", void 0);
    (0, _defineProperty2.default)(this, "_swipeTouch", void 0);
    (0, _defineProperty2.default)(this, "_tapTime", void 0);
    (0, _defineProperty2.default)(this, "_tapPoint", void 0);
    (0, _defineProperty2.default)(this, "_tap", void 0);
    this._tap = new _tap_recognizer.TapRecognizer({
      numTouches: 1,
      numTaps: 1
    });
    this.reset();
  }
  reset() {
    this._active = false;
    delete this._swipePoint;
    delete this._swipeTouch;
    delete this._tapTime;
    delete this._tapPoint;
    this._tap.reset();
  }
  touchstart(e, points, mapTouches) {
    if (this._swipePoint) return;
    if (!this._tapTime) {
      this._tap.touchstart(e, points, mapTouches);
    } else {
      const swipePoint = points[0];
      const soonEnough = e.timeStamp - this._tapTime < _tap_recognizer.MAX_TAP_INTERVAL;
      const closeEnough = this._tapPoint.dist(swipePoint) < _tap_recognizer.MAX_DIST;
      if (!soonEnough || !closeEnough) {
        this.reset();
      } else if (mapTouches.length > 0) {
        this._swipePoint = swipePoint;
        this._swipeTouch = mapTouches[0].identifier;
      }
    }
  }
  touchmove(e, points, mapTouches) {
    if (!this._tapTime) {
      this._tap.touchmove(e, points, mapTouches);
    } else if (this._swipePoint) {
      if (mapTouches[0].identifier !== this._swipeTouch) {
        return;
      }
      const newSwipePoint = points[0];
      const dist = newSwipePoint.y - this._swipePoint.y;
      this._swipePoint = newSwipePoint;
      e.preventDefault();
      this._active = true;
      return {
        zoomDelta: dist / 128
      };
    }
  }
  touchend(e, points, mapTouches) {
    if (!this._tapTime) {
      const point = this._tap.touchend(e, points, mapTouches);
      if (point) {
        this._tapTime = e.timeStamp;
        this._tapPoint = point;
      }
    } else if (this._swipePoint) {
      if (mapTouches.length === 0) {
        this.reset();
      }
    }
  }
  touchcancel() {
    this.reset();
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false;
    this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
}
exports.TapDragZoomHandler = TapDragZoomHandler;