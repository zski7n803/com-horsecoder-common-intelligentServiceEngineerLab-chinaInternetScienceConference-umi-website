"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LngLatBounds = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _lng_lat = require("./lng_lat");
/**
 * A {@link LngLatBounds} object, an array of {@link LngLatLike} objects in [sw, ne] order,
 * or an array of numbers in [west, south, east, north] order.
 *
 * @group Geography and Geometry
 *
 * @example
 * ```ts
 * let v1 = new LngLatBounds(
 *   new LngLat(-73.9876, 40.7661),
 *   new LngLat(-73.9397, 40.8002)
 * );
 * let v2 = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002])
 * let v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
 * ```
 */

/**
 * A `LngLatBounds` object represents a geographical bounding box,
 * defined by its southwest and northeast points in longitude and latitude.
 *
 * If no arguments are provided to the constructor, a `null` bounding box is created.
 *
 * Note that any Mapbox GL method that accepts a `LngLatBounds` object as an argument or option
 * can also accept an `Array` of two {@link LngLatLike} constructs and will perform an implicit conversion.
 * This flexible type is documented as {@link LngLatBoundsLike}.
 *
 * @group Geography and Geometry
 *
 * @example
 * ```ts
 * let sw = new LngLat(-73.9876, 40.7661);
 * let ne = new LngLat(-73.9397, 40.8002);
 * let llb = new LngLatBounds(sw, ne);
 * ```
 */
class LngLatBounds {
  /**
   * @param sw - The southwest corner of the bounding box.
   * OR array of 4 numbers in the order of  west, south, east, north
   * OR array of 2 LngLatLike: [sw,ne]
   * @param ne - The northeast corner of the bounding box.
   * @example
   * ```ts
   * let sw = new LngLat(-73.9876, 40.7661);
   * let ne = new LngLat(-73.9397, 40.8002);
   * let llb = new LngLatBounds(sw, ne);
   * ```
   * OR
   * ```ts
   * let llb = new LngLatBounds([-73.9876, 40.7661, -73.9397, 40.8002]);
   * ```
   * OR
   * ```ts
   * let llb = new LngLatBounds([sw, ne]);
   * ```
   */
  constructor(sw, ne) {
    (0, _defineProperty2.default)(this, "_ne", void 0);
    (0, _defineProperty2.default)(this, "_sw", void 0);
    if (!sw) {
      // noop
    } else if (ne) {
      this.setSouthWest(sw).setNorthEast(ne);
    } else if (Array.isArray(sw)) {
      if (sw.length === 4) {
        // 4 element array: west, south, east, north
        this.setSouthWest([sw[0], sw[1]]).setNorthEast([sw[2], sw[3]]);
      } else {
        this.setSouthWest(sw[0]).setNorthEast(sw[1]);
      }
    }
  }

  /**
   * Set the northeast corner of the bounding box
   *
   * @param ne - a {@link LngLatLike} object describing the northeast corner of the bounding box.
   */
  setNorthEast(ne) {
    this._ne = ne instanceof _lng_lat.LngLat ? new _lng_lat.LngLat(ne.lng, ne.lat) : _lng_lat.LngLat.convert(ne);
    return this;
  }

  /**
   * Set the southwest corner of the bounding box
   *
   * @param sw - a {@link LngLatLike} object describing the southwest corner of the bounding box.
   */
  setSouthWest(sw) {
    this._sw = sw instanceof _lng_lat.LngLat ? new _lng_lat.LngLat(sw.lng, sw.lat) : _lng_lat.LngLat.convert(sw);
    return this;
  }

  /**
   * Extend the bounds to include a given LngLatLike or LngLatBoundsLike.
   *
   * @param obj - object to extend to
   */
  extend(obj) {
    const sw = this._sw,
      ne = this._ne;
    let sw2, ne2;
    if (obj instanceof _lng_lat.LngLat) {
      sw2 = obj;
      ne2 = obj;
    } else if (obj instanceof LngLatBounds) {
      sw2 = obj._sw;
      ne2 = obj._ne;
      if (!sw2 || !ne2) return this;
    } else {
      if (Array.isArray(obj)) {
        if (obj.length === 4 || obj.every(Array.isArray)) {
          const lngLatBoundsObj = obj;
          return this.extend(LngLatBounds.convert(lngLatBoundsObj));
        } else {
          const lngLatObj = obj;
          return this.extend(_lng_lat.LngLat.convert(lngLatObj));
        }
      } else if (obj && ('lng' in obj || 'lon' in obj) && 'lat' in obj) {
        return this.extend(_lng_lat.LngLat.convert(obj));
      }
      return this;
    }
    if (!sw && !ne) {
      this._sw = new _lng_lat.LngLat(sw2.lng, sw2.lat);
      this._ne = new _lng_lat.LngLat(ne2.lng, ne2.lat);
    } else {
      sw.lng = Math.min(sw2.lng, sw.lng);
      sw.lat = Math.min(sw2.lat, sw.lat);
      ne.lng = Math.max(ne2.lng, ne.lng);
      ne.lat = Math.max(ne2.lat, ne.lat);
    }
    return this;
  }

  /**
   * Returns the geographical coordinate equidistant from the bounding box's corners.
   *
   * @returns The bounding box's center.
   * @example
   * ```ts
   * let llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
   * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
   * ```
   */
  getCenter() {
    return new _lng_lat.LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
  }

  /**
   * Returns the southwest corner of the bounding box.
   *
   * @returns The southwest corner of the bounding box.
   */
  getSouthWest() {
    return this._sw;
  }

  /**
   * Returns the northeast corner of the bounding box.
   *
   * @returns The northeast corner of the bounding box.
   */
  getNorthEast() {
    return this._ne;
  }

  /**
   * Returns the northwest corner of the bounding box.
   *
   * @returns The northwest corner of the bounding box.
   */
  getNorthWest() {
    return new _lng_lat.LngLat(this.getWest(), this.getNorth());
  }

  /**
   * Returns the southeast corner of the bounding box.
   *
   * @returns The southeast corner of the bounding box.
   */
  getSouthEast() {
    return new _lng_lat.LngLat(this.getEast(), this.getSouth());
  }

  /**
   * Returns the west edge of the bounding box.
   *
   * @returns The west edge of the bounding box.
   */
  getWest() {
    return this._sw.lng;
  }

  /**
   * Returns the south edge of the bounding box.
   *
   * @returns The south edge of the bounding box.
   */
  getSouth() {
    return this._sw.lat;
  }

  /**
   * Returns the east edge of the bounding box.
   *
   * @returns The east edge of the bounding box.
   */
  getEast() {
    return this._ne.lng;
  }

  /**
   * Returns the north edge of the bounding box.
   *
   * @returns The north edge of the bounding box.
   */
  getNorth() {
    return this._ne.lat;
  }

  /**
   * Returns the bounding box represented as an array.
   *
   * @returns The bounding box represented as an array, consisting of the
   * southwest and northeast coordinates of the bounding represented as arrays of numbers.
   * @example
   * ```ts
   * let llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
   * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
   * ```
   */
  toArray() {
    return [this._sw.toArray(), this._ne.toArray()];
  }

  /**
   * Return the bounding box represented as a string.
   *
   * @returns The bounding box represents as a string of the format
   * `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.
   * @example
   * ```ts
   * let llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
   * llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
   * ```
   */
  toString() {
    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
  }

  /**
   * Check if the bounding box is an empty/`null`-type box.
   *
   * @returns True if bounds have been defined, otherwise false.
   */
  isEmpty() {
    return !(this._sw && this._ne);
  }

  /**
   * Check if the point is within the bounding box.
   *
   * @param lnglat - geographic point to check against.
   * @returns `true` if the point is within the bounding box.
   * @example
   * ```ts
   * let llb = new LngLatBounds(
   *   new LngLat(-73.9876, 40.7661),
   *   new LngLat(-73.9397, 40.8002)
   * );
   *
   * let ll = new LngLat(-73.9567, 40.7789);
   *
   * console.log(llb.contains(ll)); // = true
   * ```
   */
  contains(lnglat) {
    const {
      lng,
      lat
    } = _lng_lat.LngLat.convert(lnglat);
    const containsLatitude = this._sw.lat <= lat && lat <= this._ne.lat;
    let containsLongitude = this._sw.lng <= lng && lng <= this._ne.lng;
    if (this._sw.lng > this._ne.lng) {
      // wrapped coordinates
      containsLongitude = this._sw.lng >= lng && lng >= this._ne.lng;
    }
    return containsLatitude && containsLongitude;
  }

  /**
   * Converts an array to a `LngLatBounds` object.
   *
   * If a `LngLatBounds` object is passed in, the function returns it unchanged.
   *
   * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.
   *
   * @param input - An array of two coordinates to convert, or a `LngLatBounds` object to return.
   * @returns A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.
   * @example
   * ```ts
   * let arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
   * let llb = LngLatBounds.convert(arr); // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
   * ```
   */
  static convert(input) {
    if (input instanceof LngLatBounds) return input;
    return new LngLatBounds(input);
  }

  /**
   * Returns a `LngLatBounds` from the coordinates extended by a given `radius`. The returned `LngLatBounds` completely contains the `radius`.
   *
   * @param center - center coordinates of the new bounds.
   * @param radius - Distance in meters from the coordinates to extend the bounds.
   * @returns A new `LngLatBounds` object representing the coordinates extended by the `radius`.
   * @example
   * ```ts
   * let center = new LngLat(-73.9749, 40.7736);
   * LngLatBounds.fromLngLat(100).toArray(); // = [[-73.97501862141328, 40.77351016847229], [-73.97478137858673, 40.77368983152771]]
   * ```
   */
  static fromLngLat(center, radius = 0) {
    const earthCircumferenceInMetersAtEquator = 40075017;
    const latAccuracy = 360 * radius / earthCircumferenceInMetersAtEquator,
      lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * center.lat);
    return new LngLatBounds(new _lng_lat.LngLat(center.lng - lngAccuracy, center.lat - latAccuracy), new _lng_lat.LngLat(center.lng + lngAccuracy, center.lat + latAccuracy));
  }
}
exports.LngLatBounds = LngLatBounds;