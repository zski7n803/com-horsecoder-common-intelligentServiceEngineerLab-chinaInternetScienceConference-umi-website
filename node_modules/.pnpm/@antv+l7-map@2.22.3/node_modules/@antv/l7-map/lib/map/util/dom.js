"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DOM = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _pointGeometry = _interopRequireDefault(require("@mapbox/point-geometry"));
var _class;
class DOM {
  static testProp(props) {
    if (!DOM.docStyle) return props[0];
    for (let i = 0; i < props.length; i++) {
      if (props[i] in DOM.docStyle) {
        return props[i];
      }
    }
    return props[0];
  }
  static create(tagName, className, container) {
    const el = window.document.createElement(tagName);
    if (className !== undefined) el.className = className;
    if (container) container.appendChild(el);
    return el;
  }
  static createNS(namespaceURI, tagName) {
    const el = window.document.createElementNS(namespaceURI, tagName);
    return el;
  }
  static disableDrag() {
    if (DOM.docStyle && DOM.selectProp) {
      DOM.userSelect = DOM.docStyle[DOM.selectProp];
      DOM.docStyle[DOM.selectProp] = 'none';
    }
  }
  static enableDrag() {
    if (DOM.docStyle && DOM.selectProp) {
      DOM.docStyle[DOM.selectProp] = DOM.userSelect;
    }
  }
  static setTransform(el, value) {
    el.style[DOM.transformProp] = value;
  }
  static addEventListener(target, type, callback, options = {}) {
    if ('passive' in options) {
      target.addEventListener(type, callback, options);
    } else {
      target.addEventListener(type, callback, options.capture);
    }
  }
  static removeEventListener(target, type, callback, options = {}) {
    if ('passive' in options) {
      target.removeEventListener(type, callback, options);
    } else {
      target.removeEventListener(type, callback, options.capture);
    }
  }

  // Suppress the next click, but only if it's immediate.
  static suppressClickInternal(e) {
    e.preventDefault();
    e.stopPropagation();
    window.removeEventListener('click', DOM.suppressClickInternal, true);
  }
  static suppressClick() {
    window.addEventListener('click', DOM.suppressClickInternal, true);
    window.setTimeout(() => {
      window.removeEventListener('click', DOM.suppressClickInternal, true);
    }, 0);
  }
  static getScale(element) {
    const rect = element.getBoundingClientRect();
    return {
      x: rect.width / element.offsetWidth || 1,
      y: rect.height / element.offsetHeight || 1,
      boundingClientRect: rect
    };
  }
  static getPoint(el, scale, e) {
    const rect = scale.boundingClientRect;
    return new _pointGeometry.default(
    // rect.left/top values are in page scale (like clientX/Y),
    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
    (e.clientX - rect.left) / scale.x - el.clientLeft, (e.clientY - rect.top) / scale.y - el.clientTop);
  }
  static mousePos(el, e) {
    const scale = DOM.getScale(el);
    return DOM.getPoint(el, scale, e);
  }
  static touchPos(el, touches) {
    const points = [];
    const scale = DOM.getScale(el);
    for (let i = 0; i < touches.length; i++) {
      points.push(DOM.getPoint(el, scale, touches[i]));
    }
    return points;
  }
  static mouseButton(e) {
    return e.button;
  }
  static remove(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
}
exports.DOM = DOM;
_class = DOM;
(0, _defineProperty2.default)(DOM, "docStyle", typeof window !== 'undefined' && window.document && window.document.documentElement.style);
(0, _defineProperty2.default)(DOM, "userSelect", void 0);
(0, _defineProperty2.default)(DOM, "selectProp", _class.testProp(['userSelect', 'MozUserSelect', 'WebkitUserSelect', 'msUserSelect']));
(0, _defineProperty2.default)(DOM, "transformProp", _class.testProp(['transform', 'WebkitTransform']));