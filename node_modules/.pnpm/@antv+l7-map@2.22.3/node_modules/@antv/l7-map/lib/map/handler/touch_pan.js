"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TouchPanHandler = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _pointGeometry = _interopRequireDefault(require("@mapbox/point-geometry"));
var _handler_util = require("./handler_util");
/**
 * A `TouchPanHandler` allows the user to pan the map using touch gestures.
 */
class TouchPanHandler {
  constructor(options, map) {
    (0, _defineProperty2.default)(this, "_enabled", void 0);
    (0, _defineProperty2.default)(this, "_active", void 0);
    (0, _defineProperty2.default)(this, "_touches", void 0);
    (0, _defineProperty2.default)(this, "_clickTolerance", void 0);
    (0, _defineProperty2.default)(this, "_sum", void 0);
    (0, _defineProperty2.default)(this, "_map", void 0);
    this._clickTolerance = options.clickTolerance || 1;
    this._map = map;
    this.reset();
  }
  reset() {
    this._active = false;
    this._touches = {};
    this._sum = new _pointGeometry.default(0, 0);
  }
  minTouchs() {
    return this._map.cooperativeGestures.isEnabled() ? 2 : 1;
  }
  touchstart(e, points, mapTouches) {
    return this._calculateTransform(e, points, mapTouches);
  }
  touchmove(e, points, mapTouches) {
    if (!this._active || mapTouches.length < this.minTouchs()) return;
    e.preventDefault();
    return this._calculateTransform(e, points, mapTouches);
  }
  touchend(e, points, mapTouches) {
    this._calculateTransform(e, points, mapTouches);
    if (this._active && mapTouches.length < this.minTouchs()) {
      this.reset();
    }
  }
  touchcancel() {
    this.reset();
  }
  _calculateTransform(e, points, mapTouches) {
    if (mapTouches.length > 0) this._active = true;
    const touches = (0, _handler_util.indexTouches)(mapTouches, points);
    const touchPointSum = new _pointGeometry.default(0, 0);
    const touchDeltaSum = new _pointGeometry.default(0, 0);
    let touchDeltaCount = 0;
    for (const identifier in touches) {
      const point = touches[identifier];
      const prevPoint = this._touches[identifier];
      if (prevPoint) {
        touchPointSum._add(point);
        touchDeltaSum._add(point.sub(prevPoint));
        touchDeltaCount++;
        touches[identifier] = point;
      }
    }
    this._touches = touches;
    if (touchDeltaCount < this.minTouchs() || !touchDeltaSum.mag()) return;
    const panDelta = touchDeltaSum.div(touchDeltaCount);
    this._sum._add(panDelta);
    if (this._sum.mag() < this._clickTolerance) return;
    const around = touchPointSum.div(touchDeltaCount);
    return {
      around,
      panDelta
    };
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false;
    this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
}
exports.TouchPanHandler = TouchPanHandler;