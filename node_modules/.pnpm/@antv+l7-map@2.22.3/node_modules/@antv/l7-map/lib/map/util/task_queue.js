"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TaskQueue = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
class TaskQueue {
  constructor() {
    (0, _defineProperty2.default)(this, "_queue", void 0);
    (0, _defineProperty2.default)(this, "_id", void 0);
    (0, _defineProperty2.default)(this, "_cleared", void 0);
    (0, _defineProperty2.default)(this, "_currentlyRunning", void 0);
    this._queue = [];
    this._id = 0;
    this._cleared = false;
    this._currentlyRunning = false;
  }
  add(callback) {
    const id = ++this._id;
    const queue = this._queue;
    queue.push({
      callback,
      id,
      cancelled: false
    });
    return id;
  }
  remove(id) {
    const running = this._currentlyRunning;
    const queue = running ? this._queue.concat(running) : this._queue;
    for (const task of queue) {
      if (task.id === id) {
        task.cancelled = true;
        return;
      }
    }
  }
  run(timeStamp = 0) {
    if (this._currentlyRunning) throw new Error('Attempting to run(), but is already running.');
    const queue = this._currentlyRunning = this._queue;

    // Tasks queued by callbacks in the current queue should be executed
    // on the next run, not the current run.
    this._queue = [];
    for (const task of queue) {
      if (task.cancelled) continue;
      task.callback(timeStamp);
      if (this._cleared) break;
    }
    this._cleared = false;
    this._currentlyRunning = false;
  }
  clear() {
    if (this._currentlyRunning) {
      this._cleared = true;
    }
    this._queue = [];
  }
}
exports.TaskQueue = TaskQueue;