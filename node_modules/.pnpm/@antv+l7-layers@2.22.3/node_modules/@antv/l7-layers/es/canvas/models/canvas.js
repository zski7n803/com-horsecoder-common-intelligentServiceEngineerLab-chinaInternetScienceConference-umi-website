import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import BaseModel from "../../core/BaseModel";
import { CanvasUpdateType } from "../../core/interface";
import { CanvasContextTypeMap } from "./constants";
export class CanvasModel extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "canvas", null);
    _defineProperty(this, "ctx", void 0);
    _defineProperty(this, "ctxType", void 0);
    _defineProperty(this, "viewportSize", void 0);
    _defineProperty(this, "initCanvas", () => {
      var _this$mapService$getC, _this$mapService$getC2, _this$mapService, _this$mapService$getM, _this$mapService2;
      const {
        zIndex,
        getContext
      } = this.layerConfig;
      const canvas = document.createElement('canvas');
      const modelType = this.layer.getModelType();
      this.canvas = canvas;
      canvas.classList.add('l7-canvas-layer');
      canvas.style.position = 'absolute';
      canvas.style.top = '0';
      canvas.style.left = '0';
      canvas.style.zIndex = String(zIndex);
      this.resetCanvasSize();
      const container = (_this$mapService$getC = (_this$mapService$getC2 = (_this$mapService = this.mapService).getCanvasOverlays) === null || _this$mapService$getC2 === void 0 ? void 0 : _this$mapService$getC2.call(_this$mapService)) !== null && _this$mapService$getC !== void 0 ? _this$mapService$getC : (_this$mapService$getM = (_this$mapService2 = this.mapService).getMapCanvasContainer) === null || _this$mapService$getM === void 0 ? void 0 : _this$mapService$getM.call(_this$mapService2);
      container === null || container === void 0 || container.appendChild(canvas);
      this.ctx = getContext ? getContext(canvas) : canvas.getContext(CanvasContextTypeMap[modelType]);
      if (!this.ctx) {
        console.error('Failed to get rendering context for canvas');
      }
      this.bindListeners();
    });
    _defineProperty(this, "resetViewportSize", () => {
      const {
        width: viewWidth,
        height: viewHeight
      } = this.rendererService.getViewportSize();
      this.viewportSize = [viewWidth, viewHeight];
    });
    _defineProperty(this, "resetCanvasSize", () => {
      const canvas = this.canvas;
      if (!canvas) {
        return;
      }
      this.resetViewportSize();
      const [width, height] = this.mapService.getSize();
      const [viewWidth, viewHeight] = this.viewportSize;
      canvas.width = viewWidth;
      canvas.height = viewHeight;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
    });
    _defineProperty(this, "renderCanvas", () => {
      var _ref;
      if (!this.canvas) {
        this.initCanvas();
      }
      const {
        draw,
        drawingOnCanvas
      } = this.layerConfig;
      const [width, height] = this.viewportSize;
      const bounds = this.mapService.getBounds();
      (_ref = draw !== null && draw !== void 0 ? draw : drawingOnCanvas) === null || _ref === void 0 || _ref({
        canvas: this.canvas,
        ctx: this.ctx,
        container: {
          width,
          height,
          bounds
        },
        size: [width, height],
        utils: {
          lngLatToContainer: this.lngLatToContainer
        },
        mapService: this.mapService
      });
    });
    _defineProperty(this, "removeCanvas", () => {
      if (this.canvas) {
        var _this$canvas$parentEl;
        (_this$canvas$parentEl = this.canvas.parentElement) === null || _this$canvas$parentEl === void 0 || _this$canvas$parentEl.removeChild(this.canvas);
        this.canvas = null;
      }
      this.unbindListeners();
    });
    _defineProperty(this, "onMapResize", () => {
      requestAnimationFrame(() => {
        this.resetCanvasSize();
        this.renderCanvas();
      });
    });
    _defineProperty(this, "lngLatToContainer", lngLat => {
      const {
        x,
        y
      } = this.mapService.lngLatToContainer(lngLat);
      return {
        x: x * window.devicePixelRatio,
        y: y * window.devicePixelRatio
      };
    });
  }
  get layerConfig() {
    return this.layer.getLayerConfig();
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.renderCanvas();
      return [];
    })();
  }
  bindListeners() {
    this.mapService.on('resize', this.onMapResize);
    const {
      trigger,
      update
    } = this.layerConfig;
    if (update === CanvasUpdateType.ALWAYS || trigger === 'change') {
      this.mapService.on('mapchange', this.renderCanvas);
    } else {
      this.mapService.on('zoomstart', this.removeCanvas);
      this.mapService.on('zoomend', this.renderCanvas);
      this.mapService.on('movestart', this.removeCanvas);
      this.mapService.on('moveend', this.renderCanvas);
    }
  }
  unbindListeners() {
    this.mapService.off('resize', this.onMapResize);
    this.mapService.off('mapchange', this.renderCanvas);
    this.mapService.off('zoomstart', this.removeCanvas);
    this.mapService.off('zoomend', this.renderCanvas);
    this.mapService.off('movestart', this.removeCanvas);
    this.mapService.off('moveend', this.renderCanvas);
  }
  registerBuiltinAttributes() {}
}