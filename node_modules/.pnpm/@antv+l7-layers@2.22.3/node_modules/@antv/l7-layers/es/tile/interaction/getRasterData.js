import { DOM } from '@antv/l7-utils';
export function readRasterValue(tile, mapService, x, y) {
  var _tile$bboxPolygon, _tile$data, _tile$data2, _tile$data3;
  const bbox = (tile === null || tile === void 0 || (_tile$bboxPolygon = tile.bboxPolygon) === null || _tile$bboxPolygon === void 0 ? void 0 : _tile$bboxPolygon.bbox) || [0, 0, 10, -10];
  const [minLng = 0, minLat = 0, maxLng = 10, maxLat = -10] = bbox;
  const tileXY = mapService.lngLatToContainer([minLng, minLat]);
  const tileMaxXY = mapService.lngLatToContainer([maxLng, maxLat]);
  const tilePixelWidth = tileMaxXY.x - tileXY.x;
  const tilePixelHeight = tileXY.y - tileMaxXY.y;
  const pos = [(x - tileXY.x) / tilePixelWidth,
  // x
  (y - tileMaxXY.y) / tilePixelHeight // y
  ];
  const tileWidth = (tile === null || tile === void 0 || (_tile$data = tile.data) === null || _tile$data === void 0 ? void 0 : _tile$data.width) || 1;
  const tileHeight = (tile === null || tile === void 0 || (_tile$data2 = tile.data) === null || _tile$data2 === void 0 ? void 0 : _tile$data2.height) || 1;
  const indexX = Math.floor(pos[0] * tileWidth);
  const indexY = Math.floor(pos[1] * tileHeight);
  const index = Math.max(0, indexY - 1) * tileWidth + indexX;
  const data = tile === null || tile === void 0 || (_tile$data3 = tile.data) === null || _tile$data3 === void 0 ? void 0 : _tile$data3.data[index];
  return data;
}
export function readPixel(x, y, rendererService) {
  const {
    readPixels,
    getViewportSize
  } = rendererService;
  const xInDevicePixel = x * DOM.DPR;
  const yInDevicePixel = y * DOM.DPR;
  const {
    width,
    height
  } = getViewportSize();
  if (xInDevicePixel > width - 1 * DOM.DPR || xInDevicePixel < 0 || yInDevicePixel > height - 1 * DOM.DPR || yInDevicePixel < 0) {
    return false;
  }
  const pickedColors = readPixels({
    x: Math.floor(xInDevicePixel),
    // 视口坐标系原点在左上，而 WebGL 在左下，需要翻转 Y 轴
    y: Math.floor(height - (y + 1) * DOM.DPR),
    width: 1,
    height: 1,
    data: new Uint8Array(1 * 1 * 4)
  });
  return pickedColors;
}