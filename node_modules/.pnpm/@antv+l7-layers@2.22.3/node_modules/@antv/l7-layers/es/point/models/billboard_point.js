import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import { AttributeType, gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
import { rgb2arr } from '@antv/l7-utils';
/* babel-plugin-inline-import '../shaders/billboard/billboard_point_frag.glsl' */
const simplePointFrag = "\nlayout(std140) uniform commonUniorm {\n  vec4 u_stroke_color;\n  float u_additive;\n  float u_stroke_opacity;\n  float u_stroke_width;\n};\n\nin vec4 v_color;\nin float v_blur;\nin float v_innerRadius;\n\nout vec4 outputColor;\n\n#pragma include \"picking\"\nvoid main() {\n  vec2 center = vec2(0.5);\n\n  // Tip: \u7247\u5143\u5230\u4E2D\u5FC3\u70B9\u7684\u8DDD\u79BB 0 - 1\n  float fragmengTocenter = distance(center, gl_PointCoord) * 2.0;\n  // Tip: \u7247\u5143\u7684\u526A\u5207\u6210\u5706\u5F62\n  float circleClipOpacity = 1.0 - smoothstep(v_blur, 1.0, fragmengTocenter);\n\n\n  if(v_innerRadius < 0.99) {\n    // \u5F53\u5B58\u5728 stroke \u4E14 stroke > 0.01\n    float blurWidth = (1.0 - v_blur)/2.0;\n    vec4 stroke = vec4(u_stroke_color.rgb, u_stroke_opacity);\n    if(fragmengTocenter > v_innerRadius + blurWidth) {\n      outputColor = stroke;\n    } else if(fragmengTocenter > v_innerRadius - blurWidth){\n      float mixR = (fragmengTocenter - (v_innerRadius - blurWidth)) / (blurWidth * 2.0);\n      outputColor = mix(v_color, stroke, mixR);\n    } else {\n      outputColor = v_color;\n    }\n  } else {\n    // \u5F53\u4E0D\u5B58\u5728 stroke \u6216 stroke <= 0.01\n    outputColor = v_color;\n  }\n\n  outputColor = filterColor(outputColor);\n  \n  if(u_additive > 0.0) {\n    outputColor *= circleClipOpacity;\n  } else {\n    outputColor.a *= circleClipOpacity;\n  }\n\n}\n";
/* babel-plugin-inline-import '../shaders/billboard/billboard_point_vert.glsl' */
const simplePointVert = "\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_stroke_color;\n  float u_additive;\n  float u_stroke_opacity;\n  float u_stroke_width;\n};\n\nout vec4 v_color;\nout float v_blur;\nout float v_innerRadius;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n#pragma include \"project\"\nvoid main() {\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\n  v_blur = 1.0 - max(2.0 / a_Size, 0.05);\n  v_innerRadius = max((a_Size - u_stroke_width) / a_Size, 0.0);\n\n  vec2 offset = project_pixel(u_offsets);\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n  gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy+offset),project_pos.z,project_pos.w));\n\n  gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\n  setPickingColor(a_PickingColor);\n}\n";
export function PointTriangulation(feature) {
  const coordinates = feature.coordinates;
  return {
    vertices: [...coordinates],
    indices: [0],
    size: coordinates.length
  };
}
export default class SimplePointModel extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9
    });
  }
  getDefaultStyle() {
    return {
      blend: 'additive'
    };
  }
  getCommonUniformsInfo() {
    const {
      blend,
      strokeOpacity = 1,
      strokeWidth = 0,
      stroke = '#fff'
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_stroke_color: rgb2arr(stroke),
      u_additive: blend === 'additive' ? 1.0 : 0.0,
      u_stroke_opacity: strokeOpacity,
      u_stroke_width: strokeWidth
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.layer.triangulation = PointTriangulation;
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'pointSimple',
        vertexShader: simplePointVert,
        fragmentShader: simplePointFrag,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation: PointTriangulation,
        depth: {
          enable: false
        },
        primitive: gl.POINTS
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 22 层级以上出现数据偏移
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: 'size',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Size',
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: feature => {
          const {
            size = 1
          } = feature;
          return Array.isArray(size) ? [size[0]] : [size];
        }
      }
    });
  }
}