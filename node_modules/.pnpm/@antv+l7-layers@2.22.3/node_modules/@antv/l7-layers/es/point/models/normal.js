import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import { AttributeType, gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
/* babel-plugin-inline-import '../shaders/normal/normal_frag.glsl' */
const normalFrag = "in vec4 v_color;\nout vec4 outputColor;\nvoid main() {\n  outputColor = v_color;\n}";
/* babel-plugin-inline-import '../shaders/normal/normal_vert.glsl' */
const normalVert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\n\nlayout(std140) uniform u_Common {\n  float u_size_scale;\n};\n\nout vec4 v_color;\n\n#pragma include \"projection\"\n#pragma include \"project\"\n\nvoid main() {\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n  gl_Position = project_common_position_to_clipspace(project_pos);\n\n  gl_PointSize = a_Size * u_size_scale * 2.0 * u_DevicePixelRatio;\n}\n";
export function PointTriangulation(feature) {
  const coordinates = feature.coordinates;
  return {
    vertices: [...coordinates],
    indices: [0],
    size: coordinates.length
  };
}
export default class NormalModel extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9
    });
  }
  getDefaultStyle() {
    return {
      blend: 'additive'
    };
  }
  getCommonUniformsInfo() {
    const commonOptions = {
      u_size_scale: 0.5
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.layer.triangulation = PointTriangulation;
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'pointNormal',
        vertexShader: normalVert,
        fragmentShader: normalFrag,
        triangulation: PointTriangulation,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        depth: {
          enable: false
        },
        primitive: gl.POINTS,
        pick: false
      });
      return [model];
    })();
  }
  clearModels() {
    return;
  }
  registerBuiltinAttributes() {
    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 20层级以上出现数据偏移
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: 'size',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Size',
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: feature => {
          const {
            size = 1
          } = feature;
          return Array.isArray(size) ? [size[0]] : [size];
        }
      }
    });
  }
}