import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import { AttributeType, gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
import { GlobelPointFillTriangulation } from "../../core/triangulation";
/* babel-plugin-inline-import '../shaders/earthFill/earthFill_frag.glsl' */
const pointFillFrag = "in vec4 v_data;\nin vec4 v_color;\nin float v_radius;\n\nlayout(std140) uniform commonUniform {\n  float u_additive;\n  float u_stroke_opacity : 1;\n  float u_stroke_width : 2;\n  float u_blur : 0.0;\n};\n#pragma include \"sdf_2d\"\n#pragma include \"picking\"\n\nout vec4 outputColor;\n\nvoid main() {\n  int shape = int(floor(v_data.w + 0.5));\n\n  vec4 strokeColor = u_stroke == vec4(0.0) ? v_color : u_stroke;\n\n  lowp float antialiasblur = v_data.z;\n  float r = v_radius / (v_radius + u_stroke_width);\n\n  float outer_df;\n  float inner_df;\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\n  if (shape == 0) {\n    outer_df = sdCircle(v_data.xy, 1.0);\n    inner_df = sdCircle(v_data.xy, r);\n  } else if (shape == 1) {\n    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\n    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\n  } else if (shape == 2) {\n    outer_df = sdBox(v_data.xy, vec2(1.));\n    inner_df = sdBox(v_data.xy, vec2(r));\n  } else if (shape == 3) {\n    outer_df = sdPentagon(v_data.xy, 0.8);\n    inner_df = sdPentagon(v_data.xy, r * 0.8);\n  } else if (shape == 4) {\n    outer_df = sdHexagon(v_data.xy, 0.8);\n    inner_df = sdHexagon(v_data.xy, r * 0.8);\n  } else if (shape == 5) {\n    outer_df = sdOctogon(v_data.xy, 1.0);\n    inner_df = sdOctogon(v_data.xy, r);\n  } else if (shape == 6) {\n    outer_df = sdHexagram(v_data.xy, 0.52);\n    inner_df = sdHexagram(v_data.xy, r * 0.52);\n  } else if (shape == 7) {\n    outer_df = sdRhombus(v_data.xy, vec2(1.0));\n    inner_df = sdRhombus(v_data.xy, vec2(r));\n  } else if (shape == 8) {\n    outer_df = sdVesica(v_data.xy, 1.1, 0.8);\n    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\n  }\n\n  if(outer_df > antialiasblur + 0.018) discard;\n\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\n\n  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(\n    antialiasblur,\n    0.0,\n    inner_df\n  );\n\n  if(u_stroke_width < 0.01) {\n    outputColor = vec4(v_color.rgb, v_color.a * u_opacity);\n  } else {\n    outputColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), strokeColor * u_stroke_opacity, color_t);\n  }\n\n  if(u_additive > 0.0) {\n    outputColor *= opacity_t;\n    outputColor = filterColorAlpha(outputColor, outputColor.a);\n  } else {\n    outputColor.a *= opacity_t;\n    outputColor = filterColor(outputColor);\n  }\n}\n";
/* babel-plugin-inline-import '../shaders/earthFill/earthFill_vert.glsl' */
const pointFillVert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_SHAPE) in float a_Shape;\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\n\nlayout(std140) uniform commonUniform {\n  float u_additive;\n  float u_stroke_opacity : 1;\n  float u_stroke_width : 2;\n  float u_blur : 0.0;\n};\nout vec4 v_data;\nout vec4 v_color;\nout float v_radius;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\n\nvoid main() {\n  vec3 extrude = a_Extrude;\n  float shape_type = a_Shape;\n  /*\n  *  setPickingSize \u8BBE\u7F6E\u62FE\u53D6\u5927\u5C0F\n  */\n  float newSize = setPickingSize(a_Size);\n  // float newSize = setPickingSize(a_Size) * 0.00001038445708445579;\n\n  // unpack color(vec2)\n  v_color = a_Color;\n\n  // radius(16-bit)\n  v_radius = newSize;\n\n  // anti-alias\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / newSize, u_blur);\n\n  // TODP: /abs(extrude.x) \u662F\u4E3A\u4E86\u517C\u5BB9\u5730\u7403\u6A21\u5F0F\n  v_data = vec4(extrude.x/abs(extrude.x), extrude.y/abs(extrude.y), antialiasblur,shape_type);\n\n  gl_Position = u_ViewProjectionMatrix * vec4(a_Position + extrude * newSize * 0.1 + vec3(u_offsets,0.0), 1.0);\n\n  setPickingColor(a_PickingColor);\n}\n";
import { mat4, vec3 } from 'gl-matrix';
export default class FillModel extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      SHAPE: 10,
      EXTRUDE: 11
    });
  }
  getCommonUniformsInfo() {
    const {
      strokeOpacity = 1,
      strokeWidth = 0,
      // offsets = [0, 0],
      blend,
      blur = 0
    } = this.layer.getLayerConfig();
    this.layer.getLayerConfig();
    const commonOptions = {
      u_additive: blend === 'additive' ? 1.0 : 0.0,
      u_stroke_opacity: strokeOpacity,
      u_stroke_width: strokeWidth,
      u_blur: blur
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.initUniformsBuffer();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.layer.triangulation = GlobelPointFillTriangulation;
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'pointEarthFill',
        vertexShader: pointFillVert,
        fragmentShader: pointFillFrag,
        triangulation: GlobelPointFillTriangulation,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        depth: {
          enable: true
        },
        blend: _this2.getBlend()
      });
      return [model];
    })();
  }

  // overwrite baseModel func
  animateOption2Array(option) {
    return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: 'extrude',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Extrude',
        shaderLocation: this.attributeLocation.EXTRUDE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx) => {
          const [x, y, z] = vertex;
          const n1 = vec3.fromValues(0, 0, 1);
          const n2 = vec3.fromValues(x, 0, z);
          const xzReg = x >= 0 ? vec3.angle(n1, n2) : Math.PI * 2 - vec3.angle(n1, n2);
          const yReg = Math.PI * 2 - Math.asin(y / 100);
          const m = mat4.create();
          mat4.rotateY(m, m, xzReg);
          mat4.rotateX(m, m, yReg);
          const v1 = vec3.fromValues(1, 1, 0);
          vec3.transformMat4(v1, v1, m);
          vec3.normalize(v1, v1);
          const v2 = vec3.fromValues(-1, 1, 0);
          vec3.transformMat4(v2, v2, m);
          vec3.normalize(v2, v2);
          const v3 = vec3.fromValues(-1, -1, 0);
          vec3.transformMat4(v3, v3, m);
          vec3.normalize(v3, v3);
          const v4 = vec3.fromValues(1, -1, 0);
          vec3.transformMat4(v4, v4, m);
          vec3.normalize(v4, v4);
          const extrude = [...v1, ...v2, ...v3, ...v4];
          const extrudeIndex = attributeIdx % 4 * 3;
          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
        }
      }
    });

    // point layer size;
    this.styleAttributeService.registerStyleAttribute({
      name: 'size',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Size',
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: feature => {
          const {
            size = 5
          } = feature;
          return Array.isArray(size) ? [size[0]] : [size];
        }
      }
    });

    // point layer size;
    this.styleAttributeService.registerStyleAttribute({
      name: 'shape',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Shape',
        shaderLocation: this.attributeLocation.SHAPE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: feature => {
          const {
            shape = 2
          } = feature;
          const shape2d = this.layer.getLayerConfig().shape2d;
          const shapeIndex = shape2d.indexOf(shape);
          return [shapeIndex];
        }
      }
    });
  }
}