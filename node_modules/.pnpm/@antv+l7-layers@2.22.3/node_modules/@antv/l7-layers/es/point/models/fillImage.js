import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { AttributeType, gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
import { SizeUnitType } from "../../core/interface";
import { PointFillTriangulation } from "../../core/triangulation";
/* babel-plugin-inline-import '../shaders/fillImage/fillImage_frag.glsl' */
const pointFillFrag = "in vec2 v_uv;// \u672C\u8EAB\u7684 uv \u5750\u6807\nin vec2 v_Iconuv;\nin float v_opacity;\nout vec4 outputColor;\n\nuniform sampler2D u_texture;\nlayout(std140) uniform commonUniform {\n  vec2 u_textSize;\n  float u_heightfixed: 0.0;\n  float u_raisingHeight: 0.0;\n  float u_size_unit;\n};\n\n#pragma include \"scene_uniforms\"\n#pragma include \"sdf_2d\"\n#pragma include \"picking\"\n\nvoid main() {\n  vec2 pos = v_Iconuv / u_textSize + v_uv / u_textSize * 64.;\n  outputColor = texture(SAMPLER_2D(u_texture), pos);\n  outputColor.a *= v_opacity;\n  outputColor = filterColor(outputColor);\n}\n";
/* babel-plugin-inline-import '../shaders/fillImage/fillImage_vert.glsl' */
const pointFillVert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniform {\n  vec2 u_textSize;\n  float u_heightfixed;\n  float u_raisingHeight;\n  float u_size_unit;\n};\n\nout vec2 v_uv;\nout vec2 v_Iconuv;\nout float v_opacity;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n#pragma include \"rotation_2d\"\n\nvoid main() {\n  vec3 extrude = a_Extrude;\n  v_uv = (a_Extrude.xy + 1.0) / 2.0;\n  v_uv.y = 1.0 - v_uv.y;\n  v_Iconuv = a_Uv;\n  v_opacity = opacity;\n  float newSize = a_Size;\n  if (u_size_unit == 1.0) {\n    newSize = newSize * u_PixelsPerMeter.z;\n  }\n\n  // vec2 offset = (u_RotateMatrix * extrude.xy * (a_Size) + textrueOffsets);\n  vec2 offset = extrude.xy * newSize + offsets;\n\n  offset = rotate_matrix(offset, rotation);\n\n  offset = project_pixel(offset);\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0), a_Position64Low);\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n";
export default class FillImageModel extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "meter2coord", 1);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "isMeter", false);
    _defineProperty(this, "radian", 0);
    _defineProperty(this, "updateTexture", () => {
      const {
        createTexture2D
      } = this.rendererService;
      if (this.texture) {
        this.texture.update({
          data: this.iconService.getCanvas(),
          mag: 'linear',
          min: 'linear mipmap nearest',
          mipmap: true
        });
        // 更新完纹理后在更新的图层的时候需要更新所有的图层
        this.layerService.throttleRenderLayers();
        return;
      }
      this.texture = createTexture2D({
        data: this.iconService.getCanvas(),
        mag: gl.LINEAR,
        min: gl.LINEAR_MIPMAP_LINEAR,
        premultiplyAlpha: false,
        width: 1024,
        height: this.iconService.canvasHeight || 128,
        mipmap: true
      });
      this.textures = [this.texture];
    });
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      EXTRUDE: 10,
      UV: 11
    });
  }
  // 旋转的弧度
  getCommonUniformsInfo() {
    const {
      raisingHeight = 0.0,
      heightfixed = false,
      unit = 'pixel'
    } = this.layer.getLayerConfig();
    if (this.rendererService.getDirty()) {
      var _this$texture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();
    }
    const commonOptions = {
      u_textSize: [1024, this.iconService.canvasHeight || 128],
      u_heightfixed: Number(heightfixed),
      u_raisingHeight: Number(raisingHeight),
      u_size_unit: SizeUnitType[unit]
    }; //2+1+1+1
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  getAttribute() {
    return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), PointFillTriangulation);
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.iconService.on('imageUpdate', _this.updateTexture);
      _this.updateTexture();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'pointFillImage',
        vertexShader: pointFillVert,
        fragmentShader: pointFillFrag,
        triangulation: PointFillTriangulation,
        depth: {
          enable: false
        },
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        cull: {
          enable: true,
          face: gl.FRONT
        }
      });
      return [model];
    })();
  }
  clearModels() {
    var _this$texture2;
    this.iconService.off('imageUpdate', this.updateTexture);
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
  }

  // overwrite baseModel func
  registerBuiltinAttributes() {
    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 20层级以上出现数据偏移
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: 'uv',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Uv',
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: feature => {
          const iconMap = this.iconService.getIconMap();
          const {
            shape
          } = feature;
          const {
            x,
            y
          } = iconMap[shape] || {
            x: -64,
            y: -64
          };
          return [x, y];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'extrude',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Extrude',
        shaderLocation: this.attributeLocation.EXTRUDE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx) => {
          const extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
          const extrudeIndex = attributeIdx % 4 * 3;
          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
        }
      }
    });

    // point layer size;
    this.styleAttributeService.registerStyleAttribute({
      name: 'size',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Size',
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: feature => {
          const {
            size = 5
          } = feature;
          return Array.isArray(size) ? [size[0]] : [size];
        }
      }
    });
  }
}