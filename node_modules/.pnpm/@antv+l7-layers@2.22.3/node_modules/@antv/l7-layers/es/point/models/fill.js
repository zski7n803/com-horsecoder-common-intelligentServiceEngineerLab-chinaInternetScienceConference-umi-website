import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import { AttributeType, gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
import { PointFillTriangulation } from "../../core/triangulation";
/* babel-plugin-inline-import '../shaders/fill/fill_frag.glsl' */
const pointFillFrag = "\nlayout(std140) uniform commonUniforms {\n  vec3 u_blur_height_fixed;\n  float u_stroke_width;\n  float u_additive;\n  float u_stroke_opacity;\n  float u_size_unit;\n  float u_time;\n  vec4 u_animate;\n};\n\nin vec4 v_color;\nin vec4 v_stroke;\nin vec4 v_data;\nin float v_radius;\n\n#pragma include \"scene_uniforms\"\n#pragma include \"sdf_2d\"\n#pragma include \"picking\"\n\nout vec4 outputColor;\n\nvoid main() {\n  int shape = int(floor(v_data.w + 0.5));\n  lowp float antialiasblur = v_data.z;\n  float r = v_radius / (v_radius + u_stroke_width);\n\n  float outer_df;\n  float inner_df;\n  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\n  if (shape == 0) {\n    outer_df = sdCircle(v_data.xy, 1.0);\n    inner_df = sdCircle(v_data.xy, r);\n  } else if (shape == 1) {\n    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\n    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\n  } else if (shape == 2) {\n    outer_df = sdBox(v_data.xy, vec2(1.));\n    inner_df = sdBox(v_data.xy, vec2(r));\n  } else if (shape == 3) {\n    outer_df = sdPentagon(v_data.xy, 0.8);\n    inner_df = sdPentagon(v_data.xy, r * 0.8);\n  } else if (shape == 4) {\n    outer_df = sdHexagon(v_data.xy, 0.8);\n    inner_df = sdHexagon(v_data.xy, r * 0.8);\n  } else if (shape == 5) {\n    outer_df = sdOctogon(v_data.xy, 1.0);\n    inner_df = sdOctogon(v_data.xy, r);\n  } else if (shape == 6) {\n    outer_df = sdHexagram(v_data.xy, 0.52);\n    inner_df = sdHexagram(v_data.xy, r * 0.52);\n  } else if (shape == 7) {\n    outer_df = sdRhombus(v_data.xy, vec2(1.0));\n    inner_df = sdRhombus(v_data.xy, vec2(r));\n  } else if (shape == 8) {\n    outer_df = sdVesica(v_data.xy, 1.1, 0.8);\n    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\n  }\n\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\n\n  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(\n    antialiasblur,\n    0.0,\n    inner_df\n  );\n\n  float PI = 3.14159;\n  float N_RINGS = 3.0;\n  float FREQ = 1.0;\n\n  if(u_stroke_width < 0.01) {\n    outputColor = v_color;\n  } else {\n    outputColor = mix(v_color, v_stroke * u_stroke_opacity, color_t);\n  }\n  float intensity = 1.0;\n  if(u_time!=-1.0){\n    //wave\u76F8\u5173\u903B\u8F91\n    float d = length(v_data.xy);\n    if(d > 0.5) {\n      discard;\n    }\n    intensity = clamp(cos(d * PI), 0.0, 1.0) * clamp(cos(2.0 * PI * (d * 2.0 * u_animate.z - u_animate.y * u_time)), 0.0, 1.0);\n  }\n\n  if(u_additive > 0.0) {\n    outputColor *= opacity_t;\n    outputColor *= intensity;//wave\n    outputColor = filterColorAlpha(outputColor, outputColor.a);\n  } else {\n    outputColor.a *= opacity_t;\n    outputColor.a *= intensity;//wave \n    outputColor = filterColor(outputColor);\n  }\n   // \u4F5C\u4E3A mask \u6A21\u677F\u65F6\u9700\u8981\u4E22\u5F03\u900F\u660E\u7684\u50CF\u7D20\n  if(outputColor.a < 0.01) {\n    discard;\n  } \n}\n";
/* babel-plugin-inline-import '../shaders/fill/fill_vert.glsl' */
const pointFillVert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_SHAPE) in float a_Shape;\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\n\nlayout(std140) uniform commonUniforms {\n  vec3 u_blur_height_fixed;\n  float u_stroke_width;\n  float u_additive;\n  float u_stroke_opacity;\n  float u_size_unit;\n  float u_time;\n  vec4 u_animate;\n};\n\nout vec4 v_color;\nout vec4 v_stroke;\nout vec4 v_data;\nout float v_radius;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n#pragma include \"rotation_2d\"\n\nvoid main() {\n  // \u900F\u660E\u5EA6\u8BA1\u7B97\n   v_stroke = stroke;\n  vec3 extrude = a_Extrude;\n  float shape_type = a_Shape;\n  /*\n  *  setPickingSize \u8BBE\u7F6E\u62FE\u53D6\u5927\u5C0F\n  *  u_meter2coord \u5728\u7B49\u9762\u79EF\u5927\u5C0F\u7684\u65F6\u5019\u8BBE\u7F6E\u5355\u4F4D\n  */\n  float newSize = setPickingSize(a_Size);\n  // float newSize = setPickingSize(a_Size) * 0.00001038445708445579;\n\n\n\n  // unpack color(vec2)\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\n\n  if(u_size_unit == 1.0) {\n    newSize = newSize  * u_PixelsPerMeter.z;\n  }\n\n   v_radius = newSize;\n\n  // anti-alias\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / newSize, u_blur_height_fixed.x);\n\n  vec2 offset = (extrude.xy * (newSize + u_stroke_width) + u_offsets);\n\n  offset = project_pixel(offset);\n  offset = rotate_matrix(offset,rotation);\n\n  // TODP: /abs(extrude.x) \u662F\u4E3A\u4E86\u517C\u5BB9\u5730\u7403\u6A21\u5F0F\n  v_data = vec4(extrude.x/abs(extrude.x), extrude.y/abs(extrude.y), antialiasblur,shape_type);\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0), a_Position64Low);\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\n\n  float raisingHeight = u_blur_height_fixed.y;\n\n  if(u_blur_height_fixed.z < 1.0) { // false\n    raisingHeight = project_pixel(u_blur_height_fixed.y);\n  } else {\n     if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      raisingHeight = u_blur_height_fixed.y * mapboxZoomScale;\n    }\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, raisingHeight, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n";
import { SizeUnitType } from "../../core/interface";
export default class FillModel extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      SHAPE: 10,
      EXTRUDE: 11
    });
  }
  getCommonUniformsInfo() {
    const {
      strokeOpacity = 1,
      strokeWidth = 0,
      blend,
      blur = 0,
      raisingHeight = 0,
      heightfixed = false,
      unit = 'pixel'
    } = this.layer.getLayerConfig();
    let u_time = this.getAnimateUniforms().u_time;
    if (isNaN(u_time)) {
      u_time = -1.0;
    }
    const commonOptions = {
      u_blur_height_fixed: [blur, Number(raisingHeight), Number(heightfixed)],
      u_stroke_width: strokeWidth,
      u_additive: blend === 'additive' ? 1.0 : 0.0,
      u_stroke_opacity: strokeOpacity,
      u_size_unit: SizeUnitType[unit],
      u_time,
      u_animate: this.getAnimateUniforms().u_animate
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  getAnimateUniforms() {
    const {
      animateOption = {
        enable: false
      }
    } = this.layer.getLayerConfig();
    return {
      u_animate: this.animateOption2Array(animateOption),
      u_time: this.layer.getLayerAnimateTime()
    };
  }
  getAttribute() {
    return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), PointFillTriangulation);
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        frag,
        vert,
        type
      } = _this2.getShaders();
      _this2.layer.triangulation = PointFillTriangulation;
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation: PointFillTriangulation,
        depth: {
          enable: false
        }
      });
      return [model];
    })();
  }

  /**
   * 根据 animateOption 的值返回对应的 shader 代码
   * @returns
   */
  getShaders() {
    return {
      frag: pointFillFrag,
      vert: pointFillVert,
      type: 'pointFill'
    };
  }

  // overwrite baseModel func
  animateOption2Array(option) {
    return [option.enable ? 0 : 1.0, option.speed || 1, option.rings || 3, 0];
  }
  registerBuiltinAttributes() {
    // 注册 Style 参与数据映射的内置属性
    const shape2d = this.layer.getLayerConfig().shape2d;

    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 20层级以上出现数据偏移
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: 'extrude',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Extrude',
        shaderLocation: this.attributeLocation.EXTRUDE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx) => {
          const extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
          const extrudeIndex = attributeIdx % 4 * 3;
          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
        }
      }
    });

    // point layer size;
    this.styleAttributeService.registerStyleAttribute({
      name: 'size',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Size',
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: feature => {
          const {
            size = 5
          } = feature;
          return Array.isArray(size) ? [size[0]] : [size];
        }
      }
    });

    // point layer shape;
    this.styleAttributeService.registerStyleAttribute({
      name: 'shape',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Shape',
        shaderLocation: this.attributeLocation.SHAPE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: feature => {
          const {
            shape = 2
          } = feature;
          const shapeIndex = shape2d.indexOf(shape);
          return [shapeIndex];
        }
      }
    });
  }
}