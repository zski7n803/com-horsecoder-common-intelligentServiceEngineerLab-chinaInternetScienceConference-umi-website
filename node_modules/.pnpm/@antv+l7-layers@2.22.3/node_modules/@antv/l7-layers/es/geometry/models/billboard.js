import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { AttributeType, gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
/* babel-plugin-inline-import '../shaders/billboard_frag.glsl' */
const planeFrag = "layout(std140) uniform commonUniforms {\n vec2 u_size;\n float u_raisingHeight;\n float u_rotation;\n float u_opacity;\n};\n\nuniform sampler2D u_texture;\n\nin vec2 v_uv;\nout vec4 outputColor;\n\n#pragma include \"picking\"\nvoid main() {\n  outputColor = texture(SAMPLER_2D(u_texture), vec2(v_uv.x, 1.0 - v_uv.y));\n  outputColor.a *= u_opacity;\n  outputColor = filterColor(outputColor);\n}\n";
/* babel-plugin-inline-import '../shaders/billboard_vert.glsl' */
const planeVert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_size;\n  float u_raisingHeight;\n  float u_rotation;\n  float u_opacity;\n};\n\nout vec2 v_uv;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n#pragma include \"rotation_2d\"\nvoid main() {\n  vec3 extrude = a_Extrude;\n  v_uv = a_Uv;\n  float raiseHeight = u_raisingHeight;\n  if (\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n  ) {\n    float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\n    raiseHeight = u_raisingHeight * mapboxZoomScale;\n  }\n\n  // \u8BA1\u7B97\u7ECF\u7EAC\u5EA6\u70B9\u4F4D\u5750\u6807\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\n\n  // \u8BA1\u7B97\u7ED5 z \u8F74\u65CB\u8F6C\u540E\u7684\u504F\u79FB\n  vec2 offsetXY = project_pixel(rotate_matrix(vec2(extrude.x * u_size.x, 0.0), u_rotation));\n  // \u7ED5 z \u8F74\u65CB\u8F6C\n  float x = project_pos.x + offsetXY.x;\n  float y = project_pos.y + offsetXY.y;\n  // z \u8F74\u4E0D\u53C2\u4E0E\u65CB\u8F6C\n  float z = project_pixel(extrude.y * u_size.y + raiseHeight);\n\n  gl_Position = project_common_position_to_clipspace(vec4(x, y, z, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n";
export default class BillBoardModel extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "radian", 0);
    // 旋转的弧度
    _defineProperty(this, "planeGeometryTriangulation", () => {
      const {
        center = [120, 30]
      } = this.layer.getLayerConfig();
      return {
        size: 4,
        indices: [0, 1, 2, 2, 3, 0],
        vertices: [...center, ...[1, 1], ...center, ...[0, 1], ...center, ...[0, 0], ...center, ...[1, 0]]
      };
    });
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      EXTRUDE: 9,
      UV: 10
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity,
      width = 1,
      height = 1,
      raisingHeight = 0
    } = this.layer.getLayerConfig();

    /**
     *               rotateFlag
     * DEFAULT            1
     * MAPBOX             1
     * AMAP              -1
     */
    let rotateFlag = 1;
    if (this.mapService.getType() === 'amap') {
      rotateFlag = -1;
    }
    // 控制图标的旋转角度（绕 Z 轴旋转）
    this.radian = rotateFlag * Math.PI * (this.mapService.getRotation() % 360) / 180;
    const commonOptions = {
      u_size: [width, height],
      u_raisingHeight: Number(raisingHeight),
      u_rotation: this.radian,
      u_opacity: opacity || 1,
      u_texture: this.texture
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  clearModels() {
    var _this$texture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const {
        drawCanvas
      } = _this.layer.getLayerConfig();
      const {
        createTexture2D
      } = _this.rendererService;
      _this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      if (drawCanvas) {
        _this.updateTexture(drawCanvas);
      }
      _this.initUniformsBuffer();
      const model = yield _this.layer.buildLayerModel({
        moduleName: 'geometryBillboard',
        vertexShader: planeVert,
        fragmentShader: planeFrag,
        triangulation: _this.planeGeometryTriangulation,
        defines: _this.getDefines(),
        inject: _this.getInject(),
        primitive: gl.TRIANGLES,
        depth: {
          enable: true
        }
      });
      return [model];
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      return _this2.initModels();
    })();
  }
  updateTexture(drawCanvas) {
    const {
      createTexture2D
    } = this.rendererService;
    const {
      canvasWidth = 1,
      canvasHeight = 1
    } = this.layer.getLayerConfig();
    const canvas = document.createElement('canvas');
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    const ctx = canvas.getContext('2d');
    if (ctx) {
      drawCanvas(canvas);
      this.texture = createTexture2D({
        data: canvas,
        width: canvas.width,
        height: canvas.height,
        wrapS: gl.CLAMP_TO_EDGE,
        wrapT: gl.CLAMP_TO_EDGE
      });
      this.layerService.reRender();
    }
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: 'extrude',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Extrude',
        shaderLocation: this.attributeLocation.EXTRUDE,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx) => {
          const extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
          const extrudeIndex = attributeIdx % 4 * 3;
          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'uv',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Uv',
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[2], vertex[3]];
        }
      }
    });
  }
}