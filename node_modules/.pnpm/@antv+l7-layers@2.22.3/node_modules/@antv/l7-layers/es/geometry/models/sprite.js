import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
/* babel-plugin-inline-import '../shaders/sprite_frag.glsl' */
const spriteFrag = "\nlayout(std140) uniform commonUniforms {\n  float u_opacity;\n  float u_mapFlag;\n  float u_Scale;\n};\nuniform sampler2D u_texture;\n\nin vec3 v_Color;\nin float v_d;\nout vec4 outputColor;\n\nvoid main() {\n\n  if(v_d < 0.0) {\n    discard;\n  }\n\n  if(u_mapFlag > 0.0) {\n    outputColor = texture(SAMPLER_2D(u_texture), gl_PointCoord);\n    outputColor.a *= u_opacity;\n  } else {\n    outputColor = vec4(v_Color, u_opacity);\n  }\n}\n";
/* babel-plugin-inline-import '../shaders/sprite_vert.glsl' */
const spriteVert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec3 a_Color;\n\nlayout(std140) uniform commonUniforms {\n  float u_opacity;\n  float u_mapFlag;\n  float u_Scale;\n};\n\nout vec3 v_Color;\nout float v_d;\n\n#pragma include \"projection\"\nvoid main() {\n  v_Color = a_Color.xyz;\n  v_d = a_Position.z;\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, a_Position.z, 1.0));\n  gl_PointSize = pow(u_Zoom - 1.0, 2.0) * u_Scale;\n}\n";
var SPRITE_ANIMATE_DIR = /*#__PURE__*/function (SPRITE_ANIMATE_DIR) {
  SPRITE_ANIMATE_DIR["UP"] = "up";
  SPRITE_ANIMATE_DIR["DOWN"] = "down";
  return SPRITE_ANIMATE_DIR;
}(SPRITE_ANIMATE_DIR || {});
export default class SpriteModel extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "mapTexture", void 0);
    _defineProperty(this, "positions", void 0);
    _defineProperty(this, "indices", void 0);
    _defineProperty(this, "timer", void 0);
    _defineProperty(this, "spriteTop", void 0);
    _defineProperty(this, "spriteUpdate", void 0);
    _defineProperty(this, "spriteAnimate", void 0);
    _defineProperty(this, "planeGeometryUpdateTriangulation", () => {
      const {
        spriteBottom = -10
      } = this.layer.getLayerConfig();
      const updateZ = this.spriteUpdate;
      const bottomZ = spriteBottom;
      const topZ = this.spriteTop;
      for (let i = 0; i < this.positions.length; i += 5) {
        if (this.spriteAnimate === SPRITE_ANIMATE_DIR.UP) {
          this.positions[i + 2] += updateZ;
          if (this.positions[i + 2] > topZ) {
            this.positions[i + 2] = bottomZ;
          }
        } else {
          this.positions[i + 2] -= updateZ;
          if (this.positions[i + 2] < bottomZ) {
            this.positions[i + 2] = topZ;
          }
        }
      }
      return {
        vertices: this.positions,
        indices: this.indices,
        size: 5
      };
    });
    /**
     * Recalculate and update position attribute.
     */
    _defineProperty(this, "updatePosition", () => {
      var _this$styleAttributeS;
      this.planeGeometryUpdateTriangulation();
      const vertexAttribute = (_this$styleAttributeS = this.styleAttributeService.getLayerStyleAttribute('position')) === null || _this$styleAttributeS === void 0 ? void 0 : _this$styleAttributeS.vertexAttribute;
      if (vertexAttribute) {
        // [x1, y1, z1, x2, y2, z2...]
        const updated = [];
        for (let i = 0; i < this.positions.length; i += 5) {
          updated.push(this.positions[i], this.positions[i + 1], this.positions[i + 2]);
        }
        vertexAttribute.updateBuffer({
          data: updated,
          offset: 0
        });
      }
      this.layerService.throttleRenderLayers();
      this.timer = requestAnimationFrame(this.updatePosition);
    });
    _defineProperty(this, "planeGeometryTriangulation", () => {
      const {
        center = [120, 30],
        spriteCount = 100,
        spriteRadius = 10
      } = this.layer.getLayerConfig();
      const {
        indices,
        positions
      } = this.initSprite(spriteRadius, spriteCount, ...center);
      this.positions = positions;
      this.indices = indices;
      return {
        vertices: positions,
        indices,
        size: 5
      };
    });
  }
  initSprite(radius = 10, spriteCount = 100, lng = 120, lat = 30) {
    const indices = [];
    const positions = [];
    const heightLimit = this.spriteAnimate === SPRITE_ANIMATE_DIR.UP ? -this.spriteTop : this.spriteTop;
    for (let i = 0; i < spriteCount; i++) {
      const height = Math.random() * heightLimit;
      positions.push(...getPos(height));
    }
    for (let i = 0; i < spriteCount; i++) {
      indices.push(i);
    }
    function getPos(z) {
      const randomX = radius * Math.random();
      const randomY = radius * Math.random();
      const x = -radius / 2 + randomX;
      const y = -radius / 2 + randomY;
      return [x + lng, -y + lat, z, 0, 0];
    }
    return {
      indices,
      positions
    };
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity,
      mapTexture,
      spriteScale = 1
    } = this.layer.getLayerConfig();
    if (this.mapTexture !== mapTexture) {
      var _this$texture;
      this.mapTexture = mapTexture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
      this.textures = [];
      this.updateTexture(mapTexture);
    }
    const commonOptions = {
      u_opacity: opacity || 1,
      u_mapFlag: mapTexture ? 1 : 0,
      u_Scale: spriteScale,
      u_texture: this.texture
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  clearModels() {
    var _this$texture2;
    cancelAnimationFrame(this.timer);
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    this.textures = [];
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const {
        mapTexture,
        spriteTop = 300,
        spriteUpdate = 10,
        spriteAnimate = SPRITE_ANIMATE_DIR.DOWN
      } = _this.layer.getLayerConfig();
      _this.initUniformsBuffer();
      _this.mapTexture = mapTexture;
      _this.spriteTop = spriteTop;
      _this.spriteUpdate = spriteUpdate;
      spriteAnimate === 'up' ? _this.spriteAnimate = SPRITE_ANIMATE_DIR.UP : _this.spriteAnimate = SPRITE_ANIMATE_DIR.DOWN;
      const {
        createTexture2D
      } = _this.rendererService;
      _this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      _this.updateTexture(mapTexture);
      setTimeout(() => {
        _this.updatePosition();
      }, 100);
      const model = yield _this.layer.buildLayerModel({
        moduleName: 'geometrySprite',
        vertexShader: spriteVert,
        fragmentShader: spriteFrag,
        triangulation: _this.planeGeometryTriangulation,
        defines: _this.getDefines(),
        inject: _this.getInject(),
        primitive: gl.POINTS,
        depth: {
          enable: false
        },
        blend: _this.getBlend()
      });
      return [model];
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      return _this2.initModels();
    })();
  }
  updateTexture(mapTexture) {
    const {
      createTexture2D
    } = this.rendererService;
    if (mapTexture) {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        this.texture = createTexture2D({
          data: img,
          width: img.width,
          height: img.height,
          wrapS: gl.CLAMP_TO_EDGE,
          wrapT: gl.CLAMP_TO_EDGE
        });
        this.layerService.reRender();
      };
      img.src = mapTexture;
    } else {
      this.texture = createTexture2D({
        width: 1,
        height: 1
      });
    }
  }
  registerBuiltinAttributes() {
    return '';
  }
}