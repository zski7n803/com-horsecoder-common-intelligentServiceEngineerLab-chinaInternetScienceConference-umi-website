import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import { AttributeType, gl } from '@antv/l7-core';
import { rgb2arr } from '@antv/l7-utils';
import BaseModel from "../../core/BaseModel";
import { SimpleLineTriangulation } from "../../core/triangulation";
/* babel-plugin-inline-import '../shaders/simple/simpleline_frag.glsl' */
const simple_line_frag = "\nlayout(std140) uniform commonUniorm {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec4 u_dash_array;\n  float u_vertexScale: 1.0;\n  float u_linearColor: 0;\n};\nin float v_distanceScale;\nin vec4 v_color;\n//dash\nin vec4 v_dash_array;\n\nout vec4 outputColor;\nvoid main() {\n  if(u_dash_array!=vec4(0.0)){\n    float dashLength = mod(v_distanceScale, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(!(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z))) {\n      // \u865A\u7EBF\u90E8\u5206\n      discard;\n    };\n  }\n  if(u_linearColor==1.0){\n    outputColor = mix(u_sourceColor, u_targetColor, v_distanceScale);\n    outputColor.a *= v_color.a; // \u5168\u5C40\u900F\u660E\u5EA6\n  }\n  else{\n    outputColor = v_color;\n  }\n}\n";
/* babel-plugin-inline-import '../shaders/simple/simpleline_vert.glsl' */
const simple_line_vert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec4 a_SizeDistanceAndTotalDistance;\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec4 u_dash_array;\n  float u_vertexScale: 1.0;\n  float u_linearColor: 0;\n};\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nout vec4 v_color;\nout float v_distanceScale;\nout vec4 v_dash_array;\n\nvoid main() {\n  //dash\u8F93\u51FA\n  v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / a_SizeDistanceAndTotalDistance.a;\n\n  v_color = a_Color;\n  v_distanceScale = a_SizeDistanceAndTotalDistance.b / a_SizeDistanceAndTotalDistance.a;\n  v_color.a = v_color.a * opacity;\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0), a_Position64Low);\n\n  float h = float(a_Position.z) * u_vertexScale; // \u7EBF\u9876\u70B9\u7684\u9AD8\u5EA6 - \u517C\u5BB9\u4E0D\u5B58\u5728\u7B2C\u4E09\u4E2A\u6570\u503C\u7684\u60C5\u51B5\n\n  float lineHeight = a_SizeDistanceAndTotalDistance.y;\n  // \u517C\u5BB9 mapbox \u5728\u7EBF\u9AD8\u5EA6\u4E0A\u7684\u6548\u679C\u8868\u73B0\u57FA\u672C\u4E00\u81F4\n  if (\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n  ) {\n    // \u4FDD\u6301\u9AD8\u5EA6\u76F8\u5BF9\u4E0D\u53D8\n    h *= 2.0 / pow(2.0, 20.0 - u_Zoom);\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, lineHeight + h, 1.0));\n  gl_PointSize = 10.0;\n\n}\n";
export default class SimpleLineModel extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9
    });
  }
  getCommonUniformsInfo() {
    const {
      sourceColor,
      targetColor,
      lineType = 'solid',
      dashArray = [10, 5, 0, 0],
      vertexHeightScale = 20.0
    } = this.layer.getLayerConfig();
    let u_dash_array = dashArray;
    if (lineType !== 'dash') {
      u_dash_array = [0, 0, 0, 0];
    }
    if (u_dash_array.length === 2) {
      u_dash_array.push(0, 0);
    }
    // 转化渐变色
    let useLinearColor = 0; // 默认不生效
    let sourceColorArr = [0, 0, 0, 0];
    let targetColorArr = [0, 0, 0, 0];
    if (sourceColor && targetColor) {
      sourceColorArr = rgb2arr(sourceColor);
      targetColorArr = rgb2arr(targetColor);
      useLinearColor = 1;
    }
    const commonOptions = {
      u_sourceColor: sourceColorArr,
      u_targetColor: targetColorArr,
      u_dash_array,
      // 顶点高度 scale
      u_vertexScale: vertexHeightScale,
      // 渐变色支持参数
      u_linearColor: useLinearColor
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  getShaders() {
    return {
      frag: simple_line_frag,
      vert: simple_line_vert,
      type: 'lineSimpleNormal'
    };
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const {
        frag,
        vert,
        type
      } = _this2.getShaders();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: SimpleLineTriangulation,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        primitive: gl.LINES,
        depth: {
          enable: false
        },
        pick: false
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 20层级以上出现数据偏移
    this.registerPosition64LowAttribute();

    //size.x,size,y,distance,totalDistance
    this.styleAttributeService.registerStyleAttribute({
      name: 'sizeDistanceAndTotalDistance',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_SizeDistanceAndTotalDistance',
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          const {
            size = 1
          } = feature;
          const a_Size = Array.isArray(size) ? [size[0], size[1]] : [size, 0];
          return [a_Size[0], a_Size[1], vertex[3], vertex[5]];
        }
      }
    });
  }
}