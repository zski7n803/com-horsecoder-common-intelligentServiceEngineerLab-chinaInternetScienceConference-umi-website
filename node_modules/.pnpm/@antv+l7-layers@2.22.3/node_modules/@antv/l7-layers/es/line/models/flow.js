import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import { AttributeType, gl } from '@antv/l7-core';
import { fp64LowPart } from '@antv/l7-utils';
import BaseModel from "../../core/BaseModel";
import { FlowLineTriangulation } from "../../core/line_trangluation";
/* babel-plugin-inline-import '../shaders/flow/flow_line_frag.glsl' */
const flow_line_frag = "// #extension GL_OES_standard_derivatives : enable\n\nin vec4 v_color;\nout vec4 outputColor;\n\n\n// line texture\n\n#pragma include \"picking\"\n\nvoid main() {\n  outputColor = v_color;\n  outputColor = filterColor(outputColor);\n}\n";
/* babel-plugin-inline-import '../shaders/flow/flow_line_vert.glsl' */
const flow_line_vert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec2 a_Size;\nlayout(location = ATTRIBUTE_LOCATION_INSTANCE) in vec4 a_Instance;\nlayout(location = ATTRIBUTE_LOCATION_INSTANCE_64LOW) in vec4 a_Instance64Low;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\n\nlayout(std140) uniform commonUniorm {\n  float u_gap_width: 1.0;\n  float u_stroke_width: 1.0;\n  float u_stroke_opacity: 1.0;\n};\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"picking\"\n\nout vec4 v_color;\n\nvec2 project_pixel_offset(vec2 offsets) {\n  vec2 data = project_pixel(offsets);\n\n  return vec2(data.x, -data.y);\n}\n\nvec2 line_dir(vec2 target, vec2 source) {\n  return normalize(ProjectFlat(target) - ProjectFlat(source));\n}\n\n\nvoid main() {\n  // \u900F\u660E\u5EA6\u8BA1\u7B97\n  vec2 source_world = a_Instance.rg; // \u8D77\u70B9\n  vec2 target_world = a_Instance.ba; // \u7EC8\u70B9\n  vec2 flowlineDir = line_dir(target_world, source_world);\n  vec2 perpendicularDir = vec2(-flowlineDir.y, flowlineDir.x);\n\n  vec2 position = mix(source_world, target_world, a_Position.x);\n  vec2 position64Low = mix(a_Instance64Low.rg, a_Instance64Low.ba, a_Position.x);\n\n  float lengthCommon = length(\n    project_position(vec4(target_world, 0, 1)) - project_position(vec4(source_world, 0, 1))\n  );\n  vec2 offsetDistances = a_Size.x * project_pixel_offset(vec2(a_Position.y, a_Position.z)); // Mapbox || \u9AD8\u5FB7\n  vec2 limitedOffsetDistances = clamp(\n    offsetDistances,\n    project_pixel(-lengthCommon * 0.2),\n    project_pixel(lengthCommon * 0.2)\n  );\n\n  float startOffsetCommon = project_pixel(offsets[0]);\n  float endOffsetCommon = project_pixel(offsets[1]);\n  float endpointOffset = mix(\n    clamp(startOffsetCommon, 0.0, lengthCommon * 0.2),\n    -clamp(endOffsetCommon, 0.0, lengthCommon * 0.2),\n    a_Position.x\n  );\n\n  vec2 normalsCommon = u_stroke_width * project_pixel_offset(vec2(a_Normal.x, a_Normal.y));\n\n  float gapCommon = -1. * project_pixel(u_gap_width);\n  vec3 offsetCommon = vec3(\n    flowlineDir * (limitedOffsetDistances[1] + normalsCommon.y + endpointOffset * 1.05) -\n      perpendicularDir * (limitedOffsetDistances[0] + gapCommon + normalsCommon.x),\n    0.0\n  );\n\n  vec4 project_pos = project_position(vec4(position.xy, 0, 1.0), position64Low);\n\n  vec4 fillColor = vec4(a_Color.rgb, a_Color.a * opacity);\n  v_color = mix(fillColor, vec4(u_stroke.xyz, u_stroke.w * fillColor.w * u_stroke_opacity), a_Normal.z);\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy +  offsetCommon.xy, 0., 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n";
export default class FlowLineModel extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      INSTANCE: 10,
      INSTANCE_64LOW: 11,
      NORMAL: 12
    });
  }
  getCommonUniformsInfo() {
    const {
      gapWidth = 2,
      strokeWidth = 1,
      strokeOpacity = 1
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_gap_width: gapWidth,
      u_stroke_width: strokeWidth,
      u_stroke_opacity: strokeOpacity
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.initUniformsBuffer();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const modelFill = yield _this2.layer.buildLayerModel({
        moduleName: 'flow_line',
        vertexShader: flow_line_vert,
        fragmentShader: flow_line_frag,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation: FlowLineTriangulation,
        styleOption: _this2.layer.getLayerConfig().symbol,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        },
        pick: false
      });
      return [modelFill];
    })();
  }
  registerBuiltinAttributes() {
    // 注册 Style 参与数据映射的内置属性
    this.styleAttributeService.registerStyleAttribute({
      name: 'size',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Size',
        // 宽度
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: feature => {
          const {
            size = 1
          } = feature;
          return Array.isArray(size) ? [size[0], size[1]] : [size, 0];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'instance',
      // 弧线起始点信息
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Instance',
        shaderLocation: this.attributeLocation.INSTANCE,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4], vertex[5], vertex[6]];
        }
      }
    });

    // save low part for enabled double precision INSTANCE attribute
    this.styleAttributeService.registerStyleAttribute({
      name: 'instance64Low',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Instance64Low',
        shaderLocation: this.attributeLocation.INSTANCE_64LOW,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          return [fp64LowPart(vertex[3]), fp64LowPart(vertex[4]), fp64LowPart(vertex[5]), fp64LowPart(vertex[6])];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'normal',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Normal',
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
  }
}