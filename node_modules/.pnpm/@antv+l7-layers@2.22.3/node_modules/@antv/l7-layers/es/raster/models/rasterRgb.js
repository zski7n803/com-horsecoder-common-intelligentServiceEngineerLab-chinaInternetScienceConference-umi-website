import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
const _excluded = ["data"],
  _excluded2 = ["rasterData"];
import { AttributeType, gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
import { RasterImageTriangulation } from "../../core/triangulation";
/* babel-plugin-inline-import '../shaders/rgb/raster_rgb_frag.glsl' */
const rasterFrag = "uniform sampler2D u_texture;\nlayout(std140) uniform commonUniforms {\n vec2 u_rminmax;\n vec2 u_gminmax;\n vec2 u_bminmax;\n float u_opacity;\n float u_noDataValue;\n};\n\nin vec2 v_texCoord;\n\nout vec4 outputColor;\n\nvoid main() {\n\n  vec3 rgb = texture(SAMPLER_2D(u_texture),vec2(v_texCoord.x,v_texCoord.y)).rgb;\n\n  if(rgb == vec3(u_noDataValue)) {\n    outputColor = vec4(0.0, 0, 0, 0.0);\n  } else {\n    outputColor = vec4(rgb.r / (u_rminmax.y -u_rminmax.x), rgb.g /(u_gminmax.y -u_gminmax.x), rgb.b/ (u_bminmax.y - u_bminmax.x), u_opacity);\n  }\n\n  if(outputColor.a < 0.01)\n    discard;\n \n}";
/* babel-plugin-inline-import '../shaders/rgb/raster_rgb_vert.glsl' */
const rasterVert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_rminmax;\n  vec2 u_gminmax;\n  vec2 u_bminmax;\n  float u_opacity;\n  float u_noDataValue;\n};\n\nout vec2 v_texCoord;\n\n#pragma include \"projection\"\n\nvoid main() {\n  v_texCoord = a_Uv;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0.0, 1.0));\n}\n";
export default class RasterModel extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "dataOption", {});
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      UV: 9
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity = 1,
      noDataValue = 0
    } = this.layer.getLayerConfig();
    const {
      rMinMax = [0, 255],
      gMinMax = [0, 255],
      bMinMax = [0, 255]
    } = this.dataOption;
    const commonOptions = {
      u_rminmax: rMinMax,
      u_gminmax: gMinMax,
      u_bminmax: bMinMax,
      u_opacity: opacity || 1,
      u_noDataValue: noDataValue,
      u_texture: this.texture
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  getRasterData(parserDataItem) {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (Array.isArray(parserDataItem.data)) {
        const {
            data
          } = parserDataItem,
          rescfg = _objectWithoutProperties(parserDataItem, _excluded);
        _this.dataOption = rescfg;
        return _objectSpread({
          data
        }, rescfg);
      }
      const _yield$parserDataItem = yield parserDataItem.data,
        {
          rasterData
        } = _yield$parserDataItem,
        rest = _objectWithoutProperties(_yield$parserDataItem, _excluded2);
      _this.dataOption = rest;
      if (Array.isArray(rasterData)) {
        // 直接传入波段数据
        return _objectSpread({
          data: rasterData
        }, rest);
      } else {
        // 多波段形式、需要进行处理
        // 支持彩色栅格（多通道）
        return _objectSpread({
          data: Array.from(rasterData)
        }, rest);
      }
    })();
  }
  initModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const source = _this2.layer.getSource();
      const {
        createTexture2D
      } = _this2.rendererService;
      const parserDataItem = source.data.dataArray[0];
      const {
        data,
        width,
        height
      } = yield _this2.getRasterData(parserDataItem);
      _this2.texture = createTexture2D({
        // @ts-ignore
        data: new Float32Array(data),
        width,
        height,
        format: gl.RGB,
        type: gl.FLOAT
      });
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'rasterImageDataRGBA',
        vertexShader: rasterVert,
        fragmentShader: rasterFrag,
        defines: _this2.getDefines(),
        triangulation: RasterImageTriangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        },
        pickingEnabled: false
      });
      return [model];
    })();
  }
  buildModels() {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      return _this3.initModels();
    })();
  }
  clearModels() {
    var _this$texture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
  }
  registerBuiltinAttributes() {
    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 22 层级以上出现数据偏移
    this.registerPosition64LowAttribute();

    // point layer size;
    this.styleAttributeService.registerStyleAttribute({
      name: 'uv',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Uv',
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
}