import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { AttributeType, gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
import { polygonTriangulation } from "../../core/triangulation";
/* babel-plugin-inline-import '../shaders/water/polygon_water_frag.glsl' */
const water_frag = "uniform sampler2D u_texture;\nlayout(std140) uniform commonUniforms {\n  float u_speed;\n  float u_time;\n};\n\nout vec4 outputColor;\n\n\nin vec4 v_Color;\nin vec2 v_uv;\n\nfloat rand(vec2 n) { return 0.5 + 0.5 * fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453); }\n\nfloat water(vec3 p) {\n  float t = u_time * u_speed;\n  p.z += t * 2.; p.x += t * 2.;\n  vec3 c1 = texture(SAMPLER_2D(u_texture), p.xz / 30.).xyz;\n  p.z += t * 3.; p.x += t * 0.52;\n  vec3 c2 = texture(SAMPLER_2D(u_texture), p.xz / 30.).xyz;\n  p.z += t * 4.; p.x += t * 0.8;\n  vec3 c3 = texture(SAMPLER_2D(u_texture), p.xz / 30.).xyz;\n  c1 += c2 - c3;\n  float z = (c1.x + c1.y + c1.z) / 3.;\n  return p.y + z / 4.;\n}\n\nfloat map(vec3 p) {\n  float d = 100.0;\n  d = water(p);\n  return d;\n}\n\nfloat intersect(vec3 ro, vec3 rd) {\n  float d = 0.0;\n  for (int i = 0; i <= 100; i++) {\n    float h = map(ro + rd * d);\n    if (h < 0.1) return  d;\n    d += h;\n  }\n  return 0.0;\n}\n\nvec3 norm(vec3 p) {\n  float eps = .1;\n  return normalize(vec3(\n    map(p + vec3(eps, 0, 0)) - map(p + vec3(-eps, 0, 0)),\n    map(p + vec3(0, eps, 0)) - map(p + vec3(0, -eps, 0)),\n    map(p + vec3(0, 0, eps)) - map(p + vec3(0, 0, -eps))\n  ));\n} \n\nfloat calSpc() {\n  vec3 l1 = normalize(vec3(1, 1, 1));\n  vec3 ro = vec3(-3, 20, -8);\n  vec3 rc = vec3(0, 0, 0);\n  vec3 ww = normalize(rc - ro);\n  vec3 uu = normalize(cross(vec3(0,1,0), ww));\n  vec3 vv = normalize(cross(rc - ro, uu));\n  vec3 rd = normalize(uu * v_uv.x + vv * v_uv.y + ww);\n  float d = intersect(ro, rd);\n  vec3 p = ro + rd * d;\n  vec3 n = norm(p);\n  float spc = pow(max(0.0, dot(reflect(l1, n), rd)), 30.0);\n  return spc;\n}\n\nvoid main() {\n\n  outputColor = v_Color;\n  float spc = calSpc();\n  outputColor += spc * 0.4;\n}\n";
/* babel-plugin-inline-import '../shaders/water/polygon_water_vert.glsl' */
const water_vert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_uv;\n\nlayout(std140) uniform commonUniforms {\n  float u_speed;\n  float u_time;\n};\nout vec4 v_Color;\nout vec2 v_uv;\n\n#pragma include \"projection\"\n\nvoid main() {\n  v_uv = a_uv;\n  v_Color = a_Color;\n  v_Color.a *= opacity;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n}\n\n";
export default class WaterModel extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      UV: 9
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      speed = 0.5
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_speed: speed,
      u_time: this.layer.getLayerAnimateTime(),
      u_texture: this.texture
    };

    // u_opacity: isNumber(opacity) ? opacity : 1.0,
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  getAnimateUniforms() {
    return {
      u_time: this.layer.getLayerAnimateTime()
    };
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.loadTexture();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'polygonWater',
        vertexShader: water_vert,
        fragmentShader: water_frag,
        triangulation: polygonTriangulation,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        },
        pickingEnabled: false,
        diagnosticDerivativeUniformityEnabled: false
      });
      return [model];
    })();
  }
  clearModels() {
    var _this$texture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
  }
  registerBuiltinAttributes() {
    const bbox = this.layer.getSource().extent;
    const [minLng, minLat, maxLng, maxLat] = bbox;
    const lngLen = maxLng - minLng;
    const latLen = maxLat - minLat;
    this.styleAttributeService.registerStyleAttribute({
      name: 'waterUv',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_uv',
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          const [lng, lat] = vertex;
          return [(lng - minLng) / lngLen, (lat - minLat) / latLen];
        }
      }
    });
  }
  loadTexture() {
    const {
      waterTexture
    } = this.layer.getLayerConfig();
    const {
      createTexture2D
    } = this.rendererService;
    this.texture = createTexture2D({
      height: 1,
      width: 1
    });
    const image = new Image();
    image.crossOrigin = '';
    if (waterTexture) {
      // custom texture
      console.warn('L7 recommendï¼šhttps://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ');
      image.src = waterTexture;
    } else {
      // default texture
      image.src = 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ';
    }
    image.onload = () => {
      this.texture = createTexture2D({
        data: image,
        width: image.width,
        height: image.height,
        wrapS: gl.MIRRORED_REPEAT,
        wrapT: gl.MIRRORED_REPEAT,
        min: gl.LINEAR,
        mag: gl.LINEAR
      });
      this.layerService.reRender();
    };
  }
}