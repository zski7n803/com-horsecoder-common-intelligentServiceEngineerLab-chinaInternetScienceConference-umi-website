import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { AttributeType, gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
import { PolygonExtrudeTriangulation } from "../../core/triangulation";
/* babel-plugin-inline-import '../shaders/extrusion/polygon_extrusion_frag.glsl' */
const polygonExtrudeFrag = "\nin vec4 v_Color;\n#pragma include \"scene_uniforms\"\n#pragma include \"picking\"\nout vec4 outputColor;\nvoid main() {\n\n  outputColor = v_Color;\n  outputColor = filterColor(outputColor);\n}\n";
/* babel-plugin-inline-import '../shaders/extrusion/polygon_extrusion_vert.glsl' */
const polygonExtrudeVert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\n\nout vec4 v_Color;\n\n#pragma include \"projection\"\n#pragma include \"light\"\n#pragma include \"picking\"\n\nvoid main() {\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size + (1.0 - a_Position.z) * extrusionBase, 1.0);\n\n  vec4 project_pos = project_position(pos, a_Position64Low);\n  float lightWeight = calc_lighting(project_pos);\n  v_Color = a_Color;\n  v_Color = vec4(v_Color.rgb * lightWeight, v_Color.w * opacity);\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n";
export default class ExtrusionModel extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      NORMAL: 10,
      EXTRUSION_BASE: 11
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const commonOptions = {};
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        frag,
        vert,
        type
      } = _this2.getShaders();
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation: PolygonExtrudeTriangulation,
        depth: {
          enable: true
        }
      });
      return [model];
    })();
  }
  getShaders() {
    return {
      frag: polygonExtrudeFrag,
      vert: polygonExtrudeVert,
      type: 'polygonExtrude'
    };
  }
  clearModels() {
    var _this$texture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
  }
  registerBuiltinAttributes() {
    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 22 层级以上出现数据偏移
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: 'normal',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Normal',
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'size',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Size',
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: feature => {
          const {
            size = 10
          } = feature;
          return Array.isArray(size) ? [size[0]] : [size];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'extrusionBase',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_ExtrusionBase',
        shaderLocation: this.attributeLocation.EXTRUSION_BASE,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: feature => {
          const {
            extrusionBase: op = 0
          } = feature;
          return [op];
        }
      }
    });
  }
}