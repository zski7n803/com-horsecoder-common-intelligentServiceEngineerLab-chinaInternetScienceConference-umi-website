import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import { AttributeType, gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
import { polygonTriangulation, polygonTriangulationWithCenter } from "../../core/triangulation";
/* babel-plugin-inline-import '../shaders/fill/fill_frag.glsl' */
const polygon_frag = "in vec4 v_color;\n#pragma include \"scene_uniforms\"\n#pragma include \"picking\"\nout vec4 outputColor;\nvoid main() {\n  outputColor = v_color;\n  outputColor = filterColor(outputColor);\n}\n";
/* babel-plugin-inline-import '../shaders/fill/fill_linear_frag.glsl' */
const polygon_linear_frag = "\nlayout(std140) uniform commonUniforms {\n  float u_raisingHeight;\n  float u_opacitylinear;\n  float u_dir;\n};\n\nin vec4 v_color;\nin vec3 v_linear;\nin vec2 v_pos;\nout vec4 outputColor;\n#pragma include \"scene_uniforms\"\n#pragma include \"picking\"\n\nvoid main() {\n  outputColor = v_color;\n  if (u_opacitylinear > 0.0) {\n    outputColor.a *= u_dir == 1.0 ? 1.0 - length(v_pos - v_linear.xy)/v_linear.z : length(v_pos - v_linear.xy)/v_linear.z;\n  }\n  outputColor = filterColor(outputColor);\n}\n";
/* babel-plugin-inline-import '../shaders/fill/fill_linear_vert.glsl' */
const polygon_linear_vert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_LINEAR) in vec3 a_linear;\n\nlayout(std140) uniform commonUniforms {\n  float u_raisingHeight;\n  float u_opacitylinear;\n  float u_dir;\n};\n\nout vec4 v_color;\nout vec3 v_linear;\nout vec2 v_pos;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  if (u_opacitylinear > 0.0) {\n    v_linear = a_linear;\n    v_pos = a_Position.xy;\n  }\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n  project_pos.z += u_raisingHeight;\n\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n    project_pos.z *= mapboxZoomScale;\n    project_pos.z += u_raisingHeight * mapboxZoomScale;\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  setPickingColor(a_PickingColor);\n}\n";
/* babel-plugin-inline-import '../shaders/fill/fill_vert.glsl' */
const polygon_vert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\n\nlayout(std140) uniform commonUniforms {\n  float u_raisingHeight;\n};\n\nout vec4 v_color;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n\n  project_pos.z += u_raisingHeight;\n\n  if (\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n  ) {\n    float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\n    project_pos.z *= mapboxZoomScale;\n    project_pos.z += u_raisingHeight * mapboxZoomScale;\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n\n";
export default class FillModel extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      LINEAR: 9
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread(_objectSpread({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      raisingHeight = 0,
      opacityLinear = {
        enable: false,
        dir: 'in'
      }
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_raisingHeight: Number(raisingHeight),
      u_opacitylinear: Number(opacityLinear.enable),
      u_dir: opacityLinear.dir === 'in' ? 1.0 : 0.0
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        frag,
        vert,
        triangulation,
        type
      } = _this2.getModelParams();
      _this2.initUniformsBuffer();
      _this2.layer.triangulation = triangulation;
      const model = yield _this2.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        }
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 22 层级以上出现数据偏移
    this.registerPosition64LowAttribute();
    const {
      opacityLinear = {
        enable: false,
        dir: 'in'
      }
    } = this.layer.getLayerConfig();
    if (opacityLinear.enable) {
      this.styleAttributeService.registerStyleAttribute({
        name: 'linear',
        type: AttributeType.Attribute,
        descriptor: {
          name: 'a_linear',
          shaderLocation: this.attributeLocation.LINEAR,
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: gl.STATIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 3,
          update: (feature, featureIdx, vertex) => {
            return [vertex[3], vertex[4], vertex[5]];
          }
        }
      });
    }
  }
  getModelParams() {
    const {
      opacityLinear = {
        enable: false
      }
    } = this.layer.getLayerConfig();
    if (opacityLinear.enable) {
      return {
        frag: polygon_linear_frag,
        vert: polygon_linear_vert,
        type: 'polygonLinear',
        triangulation: polygonTriangulationWithCenter
      };
    } else {
      return {
        frag: polygon_frag,
        vert: polygon_vert,
        type: 'polygonFill',
        triangulation: polygonTriangulation
      };
    }
  }
}