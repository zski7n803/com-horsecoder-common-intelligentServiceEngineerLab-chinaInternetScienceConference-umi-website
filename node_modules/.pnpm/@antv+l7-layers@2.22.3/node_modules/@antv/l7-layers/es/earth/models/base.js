import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { AttributeType, gl } from '@antv/l7-core';
import BaseModel from "../../core/BaseModel";
import { earthTriangulation } from "../../core/triangulation";
/* babel-plugin-inline-import '../shaders/base/base_frag.glsl' */
const baseFrag = "uniform sampler2D u_texture;\n\nin vec2 v_texCoord;\nin float v_lightWeight;\nout vec4 outputColor;\n\nvoid main() {\n    vec4 color = texture(SAMPLER_2D(u_texture),vec2(v_texCoord.x,v_texCoord.y));\n    color.xyz = color.xyz * v_lightWeight;\n    outputColor = color;\n}\n";
/* babel-plugin-inline-import '../shaders/base/base_vert.glsl' */
const baseVert = "// attribute vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\n// attribute vec2 a_Extrude;\n// attribute float a_Size;\n// attribute float a_Shape;\n\nlayout(std140) uniform commonUniforms {\n\tvec4 u_sunLight: [1.0, -10.5, 12.0,0.0];\n\tfloat u_ambientRatio : 0.5;\n\tfloat u_diffuseRatio : 0.3;\n\tfloat u_specularRatio : 0.2;\n};\n\n#pragma include \"scene_uniforms\"\n\nout vec2 v_texCoord;\nout float v_lightWeight;\n\nfloat calc_lighting(vec4 pos) {\n\n\tvec3 worldPos = vec3(pos * u_ModelMatrix);\n\n\tvec3 worldNormal = a_Normal;\n\n\t// cal light weight\n\tvec3 viewDir = normalize(u_CameraPosition - worldPos);\n\n\tvec3 lightDir = normalize(u_sunLight.xyz);\n\n\tvec3 halfDir = normalize(viewDir+lightDir);\n\t// lambert\n\tfloat lambert = dot(worldNormal, lightDir);\n\t// specular\n\tfloat specular = pow(max(0.0, dot(worldNormal, halfDir)), 32.0);\n\t//sum to light weight\n\tfloat lightWeight = u_ambientRatio + u_diffuseRatio * lambert + u_specularRatio * specular;\n\n\treturn lightWeight;\n}\n\nvoid main() {\n\n\tv_texCoord = a_Uv;\n\n\tfloat lightWeight = calc_lighting(vec4(a_Position, 1.0));\n\tv_lightWeight = lightWeight;\n\n\tgl_Position = u_ViewProjectionMatrix * u_ModelMatrix * vec4(a_Position, 1.0);\n}\n";
export default class BaseEarthModel extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    // T: 当前的地球时间 - 控制太阳的方位
    _defineProperty(this, "earthTime", 3.4);
    _defineProperty(this, "sunX", 1000);
    _defineProperty(this, "sunY", 1000);
    _defineProperty(this, "sunZ", 1000);
    _defineProperty(this, "sunRadius", Math.sqrt(this.sunX * this.sunX + this.sunY * this.sunY + this.sunZ * this.sunZ));
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      NORMAL: 9,
      UV: 10
    });
  }
  getCommonUniformsInfo() {
    const {
      animateOption,
      globalOptions
    } = this.layer.getLayerConfig();
    if (animateOption !== null && animateOption !== void 0 && animateOption.enable) {
      // @ts-ignore
      // T: rotateY 方法只有在地球模式下存在
      this.mapService.rotateY({
        reg: 0.002
      });
      this.earthTime += 0.02;
      this.sunY = 10;
      this.sunX = Math.cos(this.earthTime) * (this.sunRadius - this.sunY);
      this.sunZ = Math.sin(this.earthTime) * (this.sunRadius - this.sunY);
    }
    const commonOptions = {
      u_sunLight: [this.sunX, this.sunY, this.sunZ, 0.0],
      u_ambientRatio: (globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.ambientRatio) || 0.6,
      // 环境光
      u_diffuseRatio: (globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.diffuseRatio) || 0.4,
      // 漫反射
      u_specularRatio: (globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.specularRatio) || 0.1 // 高光反射
      // u_texture: this.texture,
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  setEarthTime(time) {
    this.earthTime = time;
    this.sunY = 10;
    this.sunX = Math.cos(this.earthTime) * (this.sunRadius - this.sunY);
    this.sunZ = Math.sin(this.earthTime) * (this.sunRadius - this.sunY);
    this.layerService.throttleRenderLayers();
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const {
        globalOptions
      } = _this.layer.getLayerConfig();
      if ((globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.earthTime) !== undefined) {
        _this.setEarthTime(globalOptions.earthTime);
      }
      const source = _this.layer.getSource();
      const {
        createTexture2D
      } = _this.rendererService;
      _this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      source.data.images.then(imageData => {
        _this.texture = createTexture2D({
          data: imageData[0],
          width: imageData[0].width,
          height: imageData[0].height
        });
        _this.textures = [_this.texture];
        _this.layerService.reRender();
      });
      _this.initUniformsBuffer();
      return _this.buildModels();
    })();
  }
  clearModels() {
    return '';
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      // Tip: 调整图层的绘制顺序 地球大气层
      _this2.layer.zIndex = -998;
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'earthBase',
        vertexShader: baseVert,
        fragmentShader: baseFrag,
        defines: _this2.getDefines(),
        triangulation: earthTriangulation,
        depth: {
          enable: true
        },
        blend: _this2.getBlend()
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    // this.styleAttributeService.registerStyleAttribute({
    //   name: 'size',
    //   type: AttributeType.Attribute,
    //   descriptor: {
    //     name: 'a_Size',
    //     shaderLocation: this.attributeLocation.SIZE,
    //     buffer: {
    //       usage: gl.DYNAMIC_DRAW,
    //       data: [],
    //       type: gl.FLOAT,
    //     },
    //     size: 1,
    //     update: (feature: IEncodeFeature) => {
    //       const { size = 1 } = feature;
    //       return Array.isArray(size) ? [size[0]] : [size as number];
    //     },
    //   },
    // });

    this.styleAttributeService.registerStyleAttribute({
      name: 'normal',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Normal',
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'uv',
      type: AttributeType.Attribute,
      descriptor: {
        name: 'a_Uv',
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
}