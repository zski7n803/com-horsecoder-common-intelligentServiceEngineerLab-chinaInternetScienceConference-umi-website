"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _l7Core = require("@antv/l7-core");
var _BaseModel = _interopRequireDefault(require("../../core/BaseModel"));
var _triangulation = require("../../core/triangulation");
/* babel-plugin-inline-import '../shaders/grid3d/grid_3d_frag.glsl' */
const grid_3d_frag = "in vec4 v_color;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_radius;\n  float u_opacity;\n  float u_coverage;\n  float u_angle;\n};\n\n#pragma include \"scene_uniforms\"\n#pragma include \"picking\"\n\nout vec4 outputColor;\nvoid main() {\n  outputColor = v_color;\n  outputColor = filterColor(outputColor);\n}\n";
/* babel-plugin-inline-import '../shaders/grid3d/grid_3d_vert.glsl' */
const grid_3d_vert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_POS) in vec3 a_Pos;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_radius;\n  float u_opacity;\n  float u_coverage;\n  float u_angle;\n};\n\nout vec4 v_color;\n\n#pragma include \"projection\"\n#pragma include \"project\"\n#pragma include \"light\"\n#pragma include \"picking\"\n\nvoid main() {\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\n  vec2 offset = vec2(a_Position.xy * u_radius * rotationMatrix * u_coverage);\n\n  vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // \u5B9E\u9645\u7684\u7ECF\u7EAC\u5EA6\n  vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\n\n  float lightWeight = calc_lighting(project_pos);\n  v_color = vec4(a_Color.rgb * lightWeight, a_Color.w);\n\n  gl_Position = project_common_position_to_clipspace(project_pos);\n\n  setPickingColor(a_PickingColor);\n}\n";
class Grid3DModel extends _BaseModel.default {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      POS: 10,
      NORMAL: 11
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity,
      coverage,
      angle
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset],
      u_opacity: opacity || 1.0,
      u_coverage: coverage || 0.9,
      u_angle: angle || 0
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'heatmapGrid3d',
        vertexShader: grid_3d_vert,
        fragmentShader: grid_3d_frag,
        defines: _this2.getDefines(),
        triangulation: _triangulation.PointExtrudeTriangulation,
        primitive: _l7Core.gl.TRIANGLES,
        depth: {
          enable: true
        }
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: 'size',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        shaderLocation: this.attributeLocation.SIZE,
        name: 'a_Size',
        buffer: {
          usage: _l7Core.gl.DYNAMIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 1,
        update: feature => {
          const {
            size
          } = feature;
          return Array.isArray(size) ? [size[0]] : [size];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'normal',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Normal',
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          usage: _l7Core.gl.STATIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'pos',
      // 顶点经纬度位置
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Pos',
        shaderLocation: this.attributeLocation.POS,
        buffer: {
          usage: _l7Core.gl.DYNAMIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 3,
        update: feature => {
          const coordinates = feature.coordinates;
          return [coordinates[0], coordinates[1], 0];
        }
      }
    });
  }
}
exports.default = Grid3DModel;