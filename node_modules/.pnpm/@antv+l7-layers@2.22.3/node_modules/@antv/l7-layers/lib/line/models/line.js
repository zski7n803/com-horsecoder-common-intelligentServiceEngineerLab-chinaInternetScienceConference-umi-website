"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Core = require("@antv/l7-core");
var _l7Utils = require("@antv/l7-utils");
var _BaseModel = _interopRequireDefault(require("../../core/BaseModel"));
var _interface = require("../../core/interface");
var _triangulation = require("../../core/triangulation");
/* babel-plugin-inline-import '../shaders/line/line_frag.glsl' */
const line_frag = "// #extension GL_OES_standard_derivatives : enable\n#define Animate 0.0\n#define LineTexture 1.0\n\nuniform sampler2D u_texture;\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_dash_array;\n  vec4 u_blur;\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float u_icon_step: 100;\n  float u_heightfixed: 0.0;\n  float u_vertexScale: 1.0;\n  float u_raisingHeight: 0.0;\n  float u_strokeWidth: 0.0;\n  float u_textureBlend;\n  float u_line_texture;\n  float u_linearDir: 1.0;\n  float u_linearColor: 0;\n  float u_time;\n};\n\nin vec4 v_color;\nin vec4 v_stroke;\n// dash\nin vec4 v_dash_array;\nin float v_d_distance_ratio;\nin vec2 v_iconMapUV;\nin vec4 v_texture_data;\n\nout vec4 outputColor;\n#pragma include \"picking\"\n\n// [animate, duration, interval, trailLength],\nvoid main() {\n  if(u_dash_array!=vec4(0.0)){\n    float dashLength = mod(v_d_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(!(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z))) {\n      // \u865A\u7EBF\u90E8\u5206\n      discard;\n    };\n  }\n  float animateSpeed = 0.0; // \u8FD0\u52A8\u901F\u5EA6\n  float d_distance_ratio = v_texture_data.r; // \u5F53\u524D\u70B9\u4F4D\u8DDD\u79BB\u5360\u7EBF\u603B\u957F\u7684\u6BD4\u4F8B\n  if(u_linearDir < 1.0) {\n    d_distance_ratio = v_texture_data.a;\n  }\n  if(u_linearColor == 1.0) { // \u4F7F\u7528\u6E10\u53D8\u989C\u8272\n    outputColor = mix(u_sourceColor, u_targetColor, d_distance_ratio);\n    outputColor.a *= v_color.a;\n  } else { // \u4F7F\u7528 color \u65B9\u6CD5\u4F20\u5165\u7684\u989C\u8272\n     outputColor = v_color;\n  }\n  // anti-alias\n  // float blur = 1.0 - smoothstep(u_blur, 1., length(v_normal.xy));\n  if(u_animate.x == Animate) {\n      animateSpeed = u_time / u_animate.y;\n       float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_animate.z)* (1.0/ u_animate.z) + animateSpeed);\n      alpha = (alpha + u_animate.w -1.0) / u_animate.w;\n      alpha = smoothstep(0., 1., alpha);\n      outputColor.a *= alpha;\n  }\n\n  if(u_line_texture == LineTexture) { // while load texture\n    float aDistance = v_texture_data.g;      // \u5F53\u524D\u9876\u70B9\u7684\u8DDD\u79BB\n    float d_texPixelLen = v_texture_data.b;  // \u8D34\u56FE\u7684\u50CF\u7D20\u957F\u5EA6\uFF0C\u6839\u636E\u5730\u56FE\u5C42\u7EA7\u7F29\u653E\n    float u = fract(mod(aDistance, d_texPixelLen)/d_texPixelLen - animateSpeed);\n    float v = v_texture_data.a;  // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n    // v = max(smoothstep(0.95, 1.0, v), v);\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n     vec4 pattern = texture(SAMPLER_2D(u_texture), uv);\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      outputColor += pattern;\n    } else { // replace\n        pattern.a *= v_color.a;\n        if(outputColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        outputColor = pattern;\n    }\n  } \n\n  float v = v_texture_data.a;\n  float strokeWidth = min(0.5, u_strokeWidth);\n  // \u7ED8\u5236 border\n  if(strokeWidth > 0.01) {\n    float borderOuterWidth = strokeWidth / 2.0;\n\n\n    if(v >= 1.0 - strokeWidth || v <= strokeWidth) {\n      if(v > strokeWidth) { // \u5916\u4FA7\n        float linear = smoothstep(0.0, 1.0, (v - (1.0 - strokeWidth))/strokeWidth);\n        //  float linear = step(0.0, (v - (1.0 - borderWidth))/borderWidth);\n        outputColor.rgb = mix(outputColor.rgb, v_stroke.rgb, linear);\n      } else if(v <= strokeWidth) {\n        float linear = smoothstep(0.0, 1.0, v/strokeWidth);\n        outputColor.rgb = mix(v_stroke.rgb, outputColor.rgb, linear);\n      }\n    }\n\n    if(v < borderOuterWidth) {\n      outputColor.a = mix(0.0, outputColor.a, v/borderOuterWidth);\n    } else if(v > 1.0 - borderOuterWidth) {\n      outputColor.a = mix(outputColor.a, 0.0, (v - (1.0 - borderOuterWidth))/borderOuterWidth);\n    }\n  }\n\n  // blur\n  float blurV = v_texture_data.a;\n  if(blurV < 0.5) {\n    outputColor.a *= mix(u_blur.r, u_blur.g, blurV/0.5);\n  } else {\n    outputColor.a *= mix(u_blur.g, u_blur.b, (blurV - 0.5)/0.5);\n  }\n  \n  outputColor = filterColor(outputColor);\n}\n";
/* babel-plugin-inline-import '../shaders/line/line_vert.glsl' */
const line_vert = "#define Animate (0.0)\n\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec2 a_Size;\nlayout(location = ATTRIBUTE_LOCATION_DISTANCE_INDEX) in vec3 a_DistanceAndIndexAndMiter;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec4 a_Normal_Total_Distance;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_iconMapUV;\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_dash_array;\n  vec4 u_blur;\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float u_icon_step: 100;\n  float u_heightfixed: 0.0;\n  float u_vertexScale: 1.0;\n  float u_raisingHeight: 0.0;\n  float u_strokeWidth: 0.0;\n  float u_textureBlend;\n  float u_line_texture;\n  float u_linearDir: 1.0;\n  float u_linearColor: 0;\n  float u_time;\n};\n\nout vec4 v_color;\nout vec4 v_stroke;\n//dash\nout vec4 v_dash_array;\nout float v_d_distance_ratio;\n// texV \u7EBF\u56FE\u5C42 - \u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\uFF08\u7EBF\u7684\u5BBD\u5EA6\u65B9\u5411\uFF09\nout vec2 v_iconMapUV;\nout vec4 v_texture_data;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  vec2 a_DistanceAndIndex = a_DistanceAndIndexAndMiter.xy;\n  float a_Miter = a_DistanceAndIndexAndMiter.z;\n  vec3 a_Normal = a_Normal_Total_Distance.xyz;\n  float a_Total_Distance = a_Normal_Total_Distance.w;\n  //dash\u8F93\u51FA\n  v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / a_Total_Distance;\n  v_d_distance_ratio = a_DistanceAndIndex.x / a_Total_Distance;\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  float d_texPixelLen; // \u8D34\u56FE\u7684\u50CF\u7D20\u957F\u5EA6\uFF0C\u6839\u636E\u5730\u56FE\u5C42\u7EA7\u7F29\u653E\n  v_iconMapUV = a_iconMapUV;\n  d_texPixelLen = project_float_pixel(u_icon_step);\n\n  v_color = a_Color;\n  v_color.a *= opacity;\n  v_stroke = stroke;\n\n  vec3 size = a_Miter * setPickingSize(a_Size.x) * a_Normal;\n\n  vec2 offset = project_pixel(size.xy);\n\n  float lineDistance = a_DistanceAndIndex.x;\n  float currentLinePointRatio = lineDistance / a_Total_Distance;\n\n  float lineOffsetWidth = length(offset + offset * sign(a_Miter)); // \u7EBF\u6A2A\u5411\u504F\u79FB\u7684\u8DDD\u79BB\uFF08\u5411\u4E24\u4FA7\u504F\u79FB\u7684\u548C\uFF09\n  float linePixelSize = project_pixel(a_Size.x) * 2.0; // \u5B9A\u70B9\u4F4D\u7F6E\u504F\u79FB\uFF0C\u6309\u5730\u56FE\u7B49\u7EA7\u7F29\u653E\u540E\u7684\u8DDD\u79BB \u5355\u4FA7 * 2\n  float texV = lineOffsetWidth / linePixelSize; // \u7EBF\u56FE\u5C42\u8D34\u56FE\u90E8\u5206\u7684 v \u5750\u6807\u503C\n\n  v_texture_data = vec4(currentLinePointRatio, lineDistance, d_texPixelLen, texV);\n  // \u8BBE\u7F6E\u6570\u636E\u96C6\u7684\u53C2\u6570\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0), a_Position64Low);\n\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, a_Size.y, 1.0));\n\n  float h = float(a_Position.z) * u_vertexScale; // \u7EBF\u9876\u70B9\u7684\u9AD8\u5EA6 - \u517C\u5BB9\u4E0D\u5B58\u5728\u7B2C\u4E09\u4E2A\u6570\u503C\u7684\u60C5\u51B5 vertex height\n  float lineHeight = a_Size.y; // size \u7B2C\u4E8C\u4E2A\u53C2\u6570\u4EE3\u8868\u7684\u9AD8\u5EA6 [linewidth, lineheight]\n\n  // \u517C\u5BB9 mapbox \u5728\u7EBF\u9AD8\u5EA6\u4E0A\u7684\u6548\u679C\u8868\u73B0\u57FA\u672C\u4E00\u81F4\n  if (\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n  ) {\n    // mapbox\n    // \u4FDD\u6301\u9AD8\u5EA6\u76F8\u5BF9\u4E0D\u53D8\n    float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\n    h *= mapboxZoomScale;\n    h += u_raisingHeight * mapboxZoomScale;\n    if (u_heightfixed > 0.0) {\n      lineHeight *= mapboxZoomScale;\n    }\n  }\n\n  gl_Position = project_common_position_to_clipspace(\n    vec4(project_pos.xy + offset, lineHeight + h, 1.0)\n  );\n\n  setPickingColor(a_PickingColor);\n}\n";
class LineModel extends _BaseModel.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "textureEventFlag", false);
    (0, _defineProperty2.default)(this, "texture", this.createTexture2D({
      data: new Uint8Array([0, 0, 0, 0]),
      width: 1,
      height: 1
    }));
    (0, _defineProperty2.default)(this, "updateTexture", () => {
      const {
        createTexture2D
      } = this.rendererService;
      if (this.textures.length === 0) {
        this.textures = [this.texture];
      }
      if (this.texture) {
        this.texture.update({
          data: this.iconService.getCanvas()
        });
        this.layer.render();
        return;
      }
      this.texture = createTexture2D({
        data: this.iconService.getCanvas(),
        mag: _l7Core.gl.NEAREST,
        min: _l7Core.gl.NEAREST,
        premultiplyAlpha: false,
        width: 1024,
        height: this.iconService.canvasHeight || 128
      });
    });
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      DISTANCE_INDEX: 10,
      NORMAL: 11,
      UV: 12
    });
  }
  getCommonUniformsInfo() {
    const {
      sourceColor,
      targetColor,
      textureBlend = 'normal',
      lineType = 'solid',
      dashArray = [10, 5, 0, 0],
      lineTexture = false,
      iconStep = 100,
      vertexHeightScale = 20.0,
      strokeWidth = 0.0,
      raisingHeight = 0,
      heightfixed = false,
      linearDir = _interface.LinearDir.VERTICAL,
      // 默认纵向
      blur = [1, 1, 1, 0]
    } = this.layer.getLayerConfig();
    let u_dash_array = dashArray;
    if (lineType !== 'dash') {
      u_dash_array = [0, 0, 0, 0];
    }
    if (u_dash_array.length === 2) {
      u_dash_array.push(0, 0);
    }
    if (this.rendererService.getDirty() && this.texture) {
      var _this$texture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();
    }
    const {
      animateOption
    } = this.layer.getLayerConfig();
    // 转化渐变色
    let useLinearColor = 0; // 默认不生效
    let sourceColorArr = [0, 0, 0, 0];
    let targetColorArr = [0, 0, 0, 0];
    if (sourceColor && targetColor) {
      sourceColorArr = (0, _l7Utils.rgb2arr)(sourceColor);
      targetColorArr = (0, _l7Utils.rgb2arr)(targetColor);
      useLinearColor = 1;
    }
    const commonOptions = {
      u_animate: this.animateOption2Array(animateOption),
      u_dash_array,
      u_blur: blur,
      u_sourceColor: sourceColorArr,
      u_targetColor: targetColorArr,
      u_textSize: [1024, this.iconService.canvasHeight || 128],
      u_icon_step: iconStep,
      // 是否固定高度
      u_heightfixed: Number(heightfixed),
      // 顶点高度 scale
      u_vertexScale: vertexHeightScale,
      u_raisingHeight: Number(raisingHeight),
      // line border 参数
      u_strokeWidth: strokeWidth,
      u_textureBlend: textureBlend === _interface.TextureBlend.NORMAL ? 0.0 : 1.0,
      u_line_texture: lineTexture ? 1.0 : 0.0,
      // 传入线的标识
      u_linearDir: linearDir === _interface.LinearDir.VERTICAL ? 1.0 : 0.0,
      u_linearColor: useLinearColor,
      u_time: this.layer.getLayerAnimateTime() || 0
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  // public getAnimateUniforms(): IModelUniform {
  //   const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;
  //   return {
  //     u_animate: this.animateOption2Array(animateOption as IAnimateOption),
  //     u_time: this.layer.getLayerAnimateTime(),
  //   };
  // }
  initModels() {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      _this.initUniformsBuffer();
      // this.updateTexture();
      // this.iconService.on('imageUpdate', this.updateTexture);
      if (!_this.textureEventFlag) {
        _this.textureEventFlag = true;
        _this.updateTexture();
        _this.iconService.on('imageUpdate', _this.updateTexture);
      }
      return _this.buildModels();
    })();
  }
  clearModels() {
    var _this$texture2;
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    this.iconService.off('imageUpdate', this.updateTexture);
  }
  buildModels() {
    var _this2 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      const {
        depth = false
      } = _this2.layer.getLayerConfig();
      const {
        frag,
        vert,
        type
      } = _this2.getShaders();
      _this2.layer.triangulation = _triangulation.LineTriangulation;
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'line' + type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: _triangulation.LineTriangulation,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        depth: {
          enable: depth
        }
      });
      return [model];
    })();
  }

  /**
   * 根据参数获取不同的 shader 代码
   * @returns
   */
  getShaders() {
    return {
      frag: line_frag,
      vert: line_vert,
      type: ''
    };
  }
  registerBuiltinAttributes() {
    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 20层级以上出现数据偏移
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: 'distanceAndIndex',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_DistanceAndIndexAndMiter',
        shaderLocation: this.attributeLocation.DISTANCE_INDEX,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: _l7Core.gl.STATIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal, vertexIndex) => {
          return vertexIndex === undefined ? [vertex[3], 10, vertex[4]] : [vertex[3], vertexIndex, vertex[4]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'size',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Size',
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: _l7Core.gl.DYNAMIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 2,
        update: feature => {
          const {
            size = 1
          } = feature;
          return Array.isArray(size) ? [size[0], size[1]] : [size, 0];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'normal_total_distance',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Normal_Total_Distance',
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: _l7Core.gl.STATIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return [...normal, vertex[5]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'uv',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_iconMapUV',
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: _l7Core.gl.DYNAMIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 2,
        update: feature => {
          const iconMap = this.iconService.getIconMap();
          const {
            texture
          } = feature;
          const {
            x,
            y
          } = iconMap[texture] || {
            x: 0,
            y: 0
          };
          return [x, y];
        }
      }
    });
  }
}
exports.default = LineModel;