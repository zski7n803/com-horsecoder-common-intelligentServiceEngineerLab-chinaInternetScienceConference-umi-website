"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Core = require("@antv/l7-core");
var _BaseModel = _interopRequireDefault(require("../../core/BaseModel"));
var _triangulation = require("../../core/triangulation");
const _excluded = ["data"],
  _excluded2 = ["rasterData"];
/* babel-plugin-inline-import '../shaders/rgb/raster_rgb_frag.glsl' */
const rasterFrag = "uniform sampler2D u_texture;\nlayout(std140) uniform commonUniforms {\n vec2 u_rminmax;\n vec2 u_gminmax;\n vec2 u_bminmax;\n float u_opacity;\n float u_noDataValue;\n};\n\nin vec2 v_texCoord;\n\nout vec4 outputColor;\n\nvoid main() {\n\n  vec3 rgb = texture(SAMPLER_2D(u_texture),vec2(v_texCoord.x,v_texCoord.y)).rgb;\n\n  if(rgb == vec3(u_noDataValue)) {\n    outputColor = vec4(0.0, 0, 0, 0.0);\n  } else {\n    outputColor = vec4(rgb.r / (u_rminmax.y -u_rminmax.x), rgb.g /(u_gminmax.y -u_gminmax.x), rgb.b/ (u_bminmax.y - u_bminmax.x), u_opacity);\n  }\n\n  if(outputColor.a < 0.01)\n    discard;\n \n}";
/* babel-plugin-inline-import '../shaders/rgb/raster_rgb_vert.glsl' */
const rasterVert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_rminmax;\n  vec2 u_gminmax;\n  vec2 u_bminmax;\n  float u_opacity;\n  float u_noDataValue;\n};\n\nout vec2 v_texCoord;\n\n#pragma include \"projection\"\n\nvoid main() {\n  v_texCoord = a_Uv;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0.0, 1.0));\n}\n";
class RasterModel extends _BaseModel.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "texture", void 0);
    (0, _defineProperty2.default)(this, "dataOption", {});
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      UV: 9
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity = 1,
      noDataValue = 0
    } = this.layer.getLayerConfig();
    const {
      rMinMax = [0, 255],
      gMinMax = [0, 255],
      bMinMax = [0, 255]
    } = this.dataOption;
    const commonOptions = {
      u_rminmax: rMinMax,
      u_gminmax: gMinMax,
      u_bminmax: bMinMax,
      u_opacity: opacity || 1,
      u_noDataValue: noDataValue,
      u_texture: this.texture
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  getRasterData(parserDataItem) {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      if (Array.isArray(parserDataItem.data)) {
        const {
            data
          } = parserDataItem,
          rescfg = (0, _objectWithoutProperties2.default)(parserDataItem, _excluded);
        _this.dataOption = rescfg;
        return (0, _objectSpread2.default)({
          data
        }, rescfg);
      }
      const _yield$parserDataItem = yield parserDataItem.data,
        {
          rasterData
        } = _yield$parserDataItem,
        rest = (0, _objectWithoutProperties2.default)(_yield$parserDataItem, _excluded2);
      _this.dataOption = rest;
      if (Array.isArray(rasterData)) {
        // 直接传入波段数据
        return (0, _objectSpread2.default)({
          data: rasterData
        }, rest);
      } else {
        // 多波段形式、需要进行处理
        // 支持彩色栅格（多通道）
        return (0, _objectSpread2.default)({
          data: Array.from(rasterData)
        }, rest);
      }
    })();
  }
  initModels() {
    var _this2 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      _this2.initUniformsBuffer();
      const source = _this2.layer.getSource();
      const {
        createTexture2D
      } = _this2.rendererService;
      const parserDataItem = source.data.dataArray[0];
      const {
        data,
        width,
        height
      } = yield _this2.getRasterData(parserDataItem);
      _this2.texture = createTexture2D({
        // @ts-ignore
        data: new Float32Array(data),
        width,
        height,
        format: _l7Core.gl.RGB,
        type: _l7Core.gl.FLOAT
      });
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'rasterImageDataRGBA',
        vertexShader: rasterVert,
        fragmentShader: rasterFrag,
        defines: _this2.getDefines(),
        triangulation: _triangulation.RasterImageTriangulation,
        primitive: _l7Core.gl.TRIANGLES,
        depth: {
          enable: false
        },
        pickingEnabled: false
      });
      return [model];
    })();
  }
  buildModels() {
    var _this3 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      return _this3.initModels();
    })();
  }
  clearModels() {
    var _this$texture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
  }
  registerBuiltinAttributes() {
    // 注册 Position 属性 64 位地位部分，经纬度数据开启双精度，避免大于 22 层级以上出现数据偏移
    this.registerPosition64LowAttribute();

    // point layer size;
    this.styleAttributeService.registerStyleAttribute({
      name: 'uv',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Uv',
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: _l7Core.gl.DYNAMIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
}
exports.default = RasterModel;