"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Core = require("@antv/l7-core");
var _l7Utils = require("@antv/l7-utils");
var _CommonStyleAttribute = require("../core/CommonStyleAttribute");
const {
  isNumber
} = _l7Utils.lodashUtil;
const PickingStage = {
  NONE: 0.0,
  ENCODE: 1.0,
  HIGHLIGHT: 2.0
};
class PixelPickingPlugin {
  constructor() {
    /**
     * Use map to keep order of insertion.
     * @see https://stackoverflow.com/questions/5525795/does-javascript-guarantee-object-property-order
     */
    (0, _defineProperty2.default)(this, "pickingUniformMap", void 0);
  }
  pickOption2Array() {
    const array = [];
    this.pickingUniformMap.forEach(value => {
      if (isNumber(value)) {
        array.push(value);
      } else {
        array.push(...value);
      }
    });
    return array;
  }
  updatePickOption(options, layer) {
    Object.keys(options).forEach(key => {
      this.pickingUniformMap.set(key, options[key]);
    });
    const u_PickingBuffer = layer.getLayerConfig().pickingBuffer || 0;
    // Tip: 当前地图是否在拖动
    const u_shaderPick = Number(layer.getShaderPickStat());
    this.pickingUniformMap.set('u_PickingBuffer', u_PickingBuffer);
    this.pickingUniformMap.set('u_shaderPick', u_shaderPick);
    const uniformBuffer = layer.getPickingUniformBuffer();
    uniformBuffer.subData({
      offset: 0,
      data: this.pickOption2Array()
    });
  }
  apply(layer, {
    styleAttributeService
  }) {
    this.pickingUniformMap = new Map([['u_HighlightColor', [1, 0, 0, 1]], ['u_SelectColor', [1, 0, 0, 1]], ['u_PickingColor', [0, 0, 0]], ['u_PickingStage', 0], ['u_CurrentSelectedId', [0, 0, 0]], ['u_PickingThreshold', 10], ['u_PickingBuffer', 0], ['u_shaderPick', 0], ['u_activeMix', 0]]);

    // TODO: 由于 Shader 目前无法根据是否开启拾取进行内容修改，因此即使不开启也需要生成 a_PickingColor
    layer.hooks.init.tapPromise('PixelPickingPlugin', () => {
      const {
        enablePicking
      } = layer.getLayerConfig();
      styleAttributeService.registerStyleAttribute({
        name: 'pickingColor',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_PickingColor',
          shaderLocation: _CommonStyleAttribute.COMMON_ATTRIBUTE_LOCATION.PICKING_COLOR,
          buffer: {
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 3,
          // TODO: 固定 feature range 范围内的 pickingColor 都是固定的，可以生成 cache
          update: feature => {
            // 只有开启拾取才需要 encode
            const {
              id
            } = feature;
            return enablePicking ? (0, _l7Utils.encodePickingColor)(id) : [0, 0, 0];
          }
        }
      });
    });
    // 必须要与 PixelPickingPass 结合使用，因此必须开启 multiPassRenderer
    layer.hooks.beforePickingEncode.tap('PixelPickingPlugin', () => {
      const {
        enablePicking
      } = layer.getLayerConfig();
      if (enablePicking && layer.isVisible()) {
        this.updatePickOption({
          u_PickingStage: PickingStage.ENCODE
        }, layer);
        layer.models.forEach(model => model.addUniforms({
          u_PickingStage: PickingStage.ENCODE
        }));
      }
    });
    layer.hooks.afterPickingEncode.tap('PixelPickingPlugin', () => {
      const {
        enablePicking
      } = layer.getLayerConfig();
      // 区分选中高亮 和滑过高亮
      if (enablePicking && layer.isVisible()) {
        this.updatePickOption({
          u_PickingStage: PickingStage.HIGHLIGHT
        }, layer);
        layer.models.forEach(model => model.addUniforms({
          u_PickingStage: PickingStage.HIGHLIGHT
        }));
      }
    });
    layer.hooks.beforeHighlight.tap('PixelPickingPlugin', pickedColor => {
      const {
        highlightColor,
        activeMix = 0
      } = layer.getLayerConfig();
      const highlightColorInArray = typeof highlightColor === 'string' ? (0, _l7Utils.rgb2arr)(highlightColor) : highlightColor || [1, 0, 0, 1];
      layer.updateLayerConfig({
        pickedFeatureID: (0, _l7Utils.decodePickingColor)(new Uint8Array(pickedColor))
      });
      const option = {
        u_PickingStage: PickingStage.HIGHLIGHT,
        u_PickingColor: pickedColor,
        u_HighlightColor: highlightColorInArray.map(c => c * 255),
        u_activeMix: activeMix
      };
      this.updatePickOption(option, layer);
      layer.models.forEach(model => model.addUniforms(option));
    });
    layer.hooks.beforeSelect.tap('PixelPickingPlugin', pickedColor => {
      const {
        selectColor,
        selectMix = 0
      } = layer.getLayerConfig();
      const highlightColorInArray = typeof selectColor === 'string' ? (0, _l7Utils.rgb2arr)(selectColor) : selectColor || [1, 0, 0, 1];
      layer.updateLayerConfig({
        pickedFeatureID: (0, _l7Utils.decodePickingColor)(new Uint8Array(pickedColor))
      });
      const option = {
        u_PickingStage: PickingStage.HIGHLIGHT,
        u_PickingColor: pickedColor,
        u_HighlightColor: highlightColorInArray.map(c => c * 255),
        u_activeMix: selectMix,
        u_CurrentSelectedId: pickedColor,
        u_SelectColor: highlightColorInArray.map(c => c * 255)
      };
      this.updatePickOption(option, layer);
      layer.models.forEach(model => model.addUniforms(option));
    });
  }
}
exports.default = PixelPickingPlugin;