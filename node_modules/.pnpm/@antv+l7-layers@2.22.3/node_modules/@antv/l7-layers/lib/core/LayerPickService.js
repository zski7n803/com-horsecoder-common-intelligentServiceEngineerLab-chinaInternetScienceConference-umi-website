"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Utils = require("@antv/l7-utils");
class BaseLayerPickService {
  constructor(layer) {
    (0, _defineProperty2.default)(this, "layer", void 0);
    this.layer = layer;
  }
  pickRender(target) {
    const container = this.layer.getContainer();
    const layerService = container.layerService;
    const layer = this.layer;
    // 瓦片图层的拾取绘制
    if (layer.tileLayer) {
      return layer.tileLayer.pickRender(target);
    }
    // 渲染瓦片图层的拾取
    layer.hooks.beforePickingEncode.call();
    layerService.renderTileLayerMask(layer);
    layer.renderModels({
      ispick: true
    });
    layer.hooks.afterPickingEncode.call();
  }
  pick(layer, target) {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      const container = _this.layer.getContainer();
      const pickingService = container.pickingService;
      if (layer.type === 'RasterLayer') {
        return _this.pickRasterLayer(layer, target);
      }
      _this.pickRender(target);
      return pickingService.pickFromPickingFBO(layer, target);
    })();
  }
  pickRasterLayer(layer, target, parent) {
    const container = this.layer.getContainer();
    const pickingService = container.pickingService;
    const mapService = container.mapService;
    const extent = this.layer.getSource().extent;
    const isPick = (0, _l7Utils.lngLatInExtent)(target.lngLat, extent);
    const layerTarget = {
      x: target.x,
      y: target.y,
      type: target.type,
      lngLat: target.lngLat,
      target,
      rasterValue: null
    };
    const adviceTarget = parent ? parent : layer;
    if (isPick) {
      const rasterValue = this.readRasterValue(layer, extent, mapService, target.x, target.y);
      layerTarget.rasterValue = rasterValue;
      pickingService.triggerHoverOnLayer(adviceTarget, layerTarget);
      return true;
    } else {
      layerTarget.type = target.type === 'mousemove' ? 'mouseout' : 'un' + target.type;
      pickingService.triggerHoverOnLayer(adviceTarget, (0, _objectSpread2.default)((0, _objectSpread2.default)({}, layerTarget), {}, {
        type: 'unpick'
      }));
      pickingService.triggerHoverOnLayer(adviceTarget, layerTarget);
      return false;
    }
  }
  readRasterValue(layer, bbox, mapService, x, y) {
    const rasterData = layer.getSource().data.dataArray[0];
    const [minLng = 0, minLat = 0, maxLng = 10, maxLat = -10] = bbox;
    const tileXY = mapService.lngLatToContainer([minLng, minLat]);
    const tileMaxXY = mapService.lngLatToContainer([maxLng, maxLat]);
    const tilePixelWidth = tileMaxXY.x - tileXY.x;
    const tilePixelHeight = tileXY.y - tileMaxXY.y;
    const pos = [(x - tileXY.x) / tilePixelWidth,
    // x
    (y - tileMaxXY.y) / tilePixelHeight // y
    ];
    const tileWidth = rasterData.width || 1;
    const tileHeight = rasterData.height || 1;
    const indexX = Math.floor(pos[0] * tileWidth);
    const indexY = Math.floor(pos[1] * tileHeight);
    const index = Math.max(0, indexY - 1) * tileWidth + indexX;
    const data = rasterData.data[index];
    return data;
  }
  selectFeature(pickedColors) {
    const layer = this.layer;
    // @ts-ignore
    const [r, g, b] = pickedColors;
    layer.hooks.beforeSelect.call([r, g, b]);
  }
  highlightPickedFeature(pickedColors) {
    // @ts-ignore
    const [r, g, b] = pickedColors;
    this.layer.hooks.beforeHighlight.call([r, g, b]);
  }
  getFeatureById(pickedFeatureIdx) {
    return this.layer.getSource().getFeatureById(pickedFeatureIdx);
  }
}
exports.default = BaseLayerPickService;