"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _glMatrix = require("gl-matrix");
var _gridIndex = _interopRequireDefault(require("./grid-index"));
// @mapbox/grid-index 并没有类似 hitTest 的单纯获取碰撞检测结果的方法，query 将导致计算大量多余的包围盒结果，因此使用改良版

/**
 * 基于网格实现文本避让，大幅提升包围盒碰撞检测效率
 * @see https://zhuanlan.zhihu.com/p/74373214
 */
class CollisionIndex {
  constructor(width, height) {
    (0, _defineProperty2.default)(this, "width", void 0);
    (0, _defineProperty2.default)(this, "height", void 0);
    (0, _defineProperty2.default)(this, "grid", void 0);
    (0, _defineProperty2.default)(this, "viewportPadding", 100);
    (0, _defineProperty2.default)(this, "screenRightBoundary", void 0);
    (0, _defineProperty2.default)(this, "screenBottomBoundary", void 0);
    (0, _defineProperty2.default)(this, "gridRightBoundary", void 0);
    (0, _defineProperty2.default)(this, "gridBottomBoundary", void 0);
    this.width = width;
    this.height = height;
    this.viewportPadding = Math.max(width, height);
    // 创建网格索引
    this.grid = new _gridIndex.default(width + this.viewportPadding, height + this.viewportPadding, 25);
    this.screenRightBoundary = width + this.viewportPadding;
    this.screenBottomBoundary = height + this.viewportPadding;
    this.gridRightBoundary = width + 2 * this.viewportPadding;
    this.gridBottomBoundary = height + 2 * this.viewportPadding;
  }
  placeCollisionBox(collisionBox) {
    // const projectedPoint = this.project(
    //   mvpMatrix,
    //   collisionBox.anchorPointX,
    //   collisionBox.anchorPointY,
    // );

    const tlX = collisionBox.x1 + collisionBox.anchorPointX + this.viewportPadding;
    const tlY = collisionBox.y1 + collisionBox.anchorPointY + this.viewportPadding;
    const brX = collisionBox.x2 + collisionBox.anchorPointX + this.viewportPadding;
    const brY = collisionBox.y2 + collisionBox.anchorPointY + this.viewportPadding;
    if (!this.isInsideGrid(tlX, tlY, brX, brY) || this.grid.hitTest(tlX, tlY, brX, brY)) {
      return {
        box: []
      };
    }
    return {
      box: [tlX, tlY, brX, brY]
    };
  }
  insertCollisionBox(box, featureIndex) {
    const key = {
      featureIndex
    };
    this.grid.insert(key, box[0], box[1], box[2], box[3]);
  }

  /**
   * 后续碰撞检测都需要投影到 viewport 坐标系
   * @param {THREE.Matrix4} mvpMatrix mvp矩阵
   * @param {number} x P20 平面坐标X
   * @param {number} y P20 平面坐标Y
   * @return {Point} projectedPoint
   */
  project(mvpMatrix, x, y) {
    const point = _glMatrix.vec4.fromValues(x, y, 0, 1);
    const out = _glMatrix.vec4.create();
    // @ts-ignore
    const mat = _glMatrix.mat4.fromValues(...mvpMatrix);
    _glMatrix.vec4.transformMat4(out, point, mat);
    // GL 坐标系[-1, 1] -> viewport 坐标系[width, height]
    return {
      x: (out[0] / out[3] + 1) / 2 * this.width + this.viewportPadding,
      y: (-out[1] / out[3] + 1) / 2 * this.height + this.viewportPadding
    };
  }

  /**
   * 判断包围盒是否在整个网格内，需要加上 buffer
   * @param {number} x1 x1
   * @param {number} y1 y1
   * @param {number} x2 x2
   * @param {number} y2 y2
   * @return {Point} isInside
   */
  isInsideGrid(x1, y1, x2, y2) {
    return x2 >= 0 && x1 < this.gridRightBoundary && y2 >= 0 && y1 < this.gridBottomBoundary;
  }
}
exports.default = CollisionIndex;