"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Core = require("@antv/l7-core");
var _l7Utils = require("@antv/l7-utils");
var _BaseModel = _interopRequireDefault(require("../../core/BaseModel"));
var _triangulation = require("../../core/triangulation");
/* babel-plugin-inline-import '../shaders/build_frag.glsl' */
const buildFrag = "precision highp float;\nlayout(std140) uniform commonUniforms {\n  vec4 u_baseColor: [ 1.0, 0, 0, 1.0 ];\n  vec4 u_brightColor: [ 1.0, 0, 0, 1.0 ];\n  vec4 u_windowColor: [ 1.0, 0, 0, 1.0 ];\n  vec4 u_circleSweepColor;\n  vec2 u_cityCenter;\n  float u_circleSweep;\n  float u_cityMinSize;\n  float u_circleSweepSpeed;\n  float u_opacity: 1.0;\n  float u_near: 0;\n  float u_far: 1;\n  float u_time;\n};\nin vec4 v_Color;\nin vec2 v_texCoord;\nin float v_worldDis;\nout vec4 outputColor;\n\n#pragma include \"picking\"\n#pragma include \"scene_uniforms\"\n\nvec3 getWindowColor(float n, float hot, vec3 brightColor, vec3 darkColor) {\n    float s = step(hot, n);\n    vec3 color = mix(brightColor,vec3(0.9,0.9,1.0),n);\n\n    return mix(darkColor, color, s);\n}\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat LinearizeDepth()\n{\n    float z = gl_FragCoord.z * 2.0 - 1.0;\n    return (2.0 * u_near * u_far) / (u_far + u_near - z * (u_far - u_near));\n}\n\nvec3 fog(vec3 color, vec3 fogColor, float depth){\n    float fogFactor=clamp(depth,0.0,1.0);\n    vec3 output_color=mix(fogColor,color,fogFactor);\n    return output_color;\n}\n\nfloat sdRect(vec2 p, vec2 sz) {\n  vec2 d = abs(p) - sz;\n  float outside = length(max(d, 0.));\n  float inside = min(max(d.x, d.y), 0.);\n  return outside + inside;\n}\n\nvoid main() {\n  outputColor = v_Color;\n  vec3 baseColor = u_baseColor.xyz;\n  vec3 brightColor = u_brightColor.xyz;\n  vec3 windowColor = u_windowColor.xyz;\n  float targetColId = 5.;\n  float depth = 1.0 - LinearizeDepth() / u_far * u_Zoom;\n  vec3 fogColor = vec3(23.0/255.0,31.0/255.0,51.0/255.0);\n  if(v_texCoord.x < 0.) { //\u9876\u90E8\u989C\u8272\n       vec3 foggedColor = fog(baseColor.xyz + vec3(0.12*0.9,0.2*0.9,0.3*0.9),fogColor,depth);\n       outputColor = vec4( foggedColor, v_Color.w);\n  }else { // \u4FA7\u9762\u989C\u8272\n        vec2 st = v_texCoord;\n        vec2  UvScale = v_texCoord;\n        float tStep = min(0.08,max(0.05* (18.0-u_Zoom),0.02));\n        float tStart = 0.25 * tStep;\n        float tEnd = 0.75 * tStep;\n        float u = mod(UvScale.x, tStep);\n        float v = mod(UvScale.y, tStep);\n        float ux = floor(UvScale.x/tStep);\n        float uy = floor(UvScale.y/tStep);\n        float n = random(vec2(ux,uy));\n        float lightP = u_time;\n        float head = 1.0- step(0.005,st.y);\n        /*step3*/\n        // \u5C06\u7A97\u6237\u989C\u8272\u548C\u5899\u9762\u989C\u8272\u533A\u522B\u5F00\u6765\n        float sU = step(tStart, u) - step(tEnd, u);\n        float sV = step(tStart, v) - step(tEnd, v);\n        vec2 windowSize = vec2(abs(tEnd-tStart),abs(tEnd-tStart));\n        float dist = sdRect(vec2(u,v), windowSize);\n        float s = sU * sV;\n\n        float curColId = floor(UvScale.x / tStep);\n        float sCol = step(targetColId - 0.2, curColId) - step(targetColId + 0.2, curColId);\n\n        float mLightP = mod(lightP, 2.);\n        float sRow = step(mLightP - 0.2, st.y) - step(mLightP, st.y);\n        if(ux == targetColId){\n            n =0.;\n        }\n        float timeP = min(0.75, abs ( sin(u_time/3.0) ) );\n        float hot = smoothstep(1.0,0.0,timeP);\n        vec3 color = mix(baseColor, getWindowColor(n,hot,brightColor,windowColor), s);\n        //vec3 color = mix(baseColor, getWindowColor(n,hot,brightColor,windowColor), 1.0);\n        float sFinal = s * sCol * sRow;\n        color += mix(baseColor, brightColor, sFinal*n);\n        if (st.y<0.01){\n        color = baseColor;\n         }\n        if(head ==1.0) { // \u9876\u90E8\u4EAE\u7EBF\n            color = brightColor;\n        }\n        color = color * v_Color.rgb;\n\n        vec3 foggedColor = fog(color,fogColor,depth);\n\n        outputColor = vec4(foggedColor,1.0);\n  }\n\n\n  if(u_circleSweep > 0.0 && v_worldDis < u_cityMinSize) {\n    float r = fract(((v_worldDis/u_cityMinSize) - u_time * u_circleSweepSpeed) * 2.0);\n    outputColor.rgb += r * r * u_circleSweepColor.rgb;\n  }\n\n  outputColor.a *= u_opacity;\n  outputColor = filterColor(outputColor);\n}\n";
/* babel-plugin-inline-import '../shaders/build_vert.glsl' */
const buildVert = "precision highp float;\n\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nout vec2 v_texCoord;\nout vec4 v_Color;\nout float v_worldDis;\n\nlayout(std140) uniform commonUniforms {\n  vec4 u_baseColor : [ 1.0, 0, 0, 1.0 ];\n  vec4 u_brightColor : [ 1.0, 0, 0, 1.0 ];\n  vec4 u_windowColor : [ 1.0, 0, 0, 1.0 ];\n  vec4 u_circleSweepColor;\n  vec2 u_cityCenter;\n  float u_circleSweep;\n  float u_cityMinSize;\n  float u_circleSweepSpeed;\n  float u_opacity: 1.0;\n  float u_near : 0;\n  float u_far : 1;\n  float u_time;\n};\n#pragma include \"projection\"\n#pragma include \"light\"\n#pragma include \"picking\"\n\n\nvoid main() {\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  vec4 project_pos = project_position(pos);\n\n   v_texCoord = a_Uv;\n\n  if(u_circleSweep > 0.0) {\n     vec2 lnglatscale = vec2(0.0);\n    lnglatscale = (a_Position.xy - u_cityCenter) * vec2(0.0, 0.135);\n    v_worldDis = length(a_Position.xy + lnglatscale - u_cityCenter);\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  float lightWeight = calc_lighting(pos);\n  // v_Color = a_Color;\n  v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w);\n\n  setPickingColor(a_PickingColor);\n}\n";
class CityBuildModel extends _BaseModel.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "cityCenter", void 0);
    (0, _defineProperty2.default)(this, "cityMinSize", void 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      NORMAL: 10,
      UV: 11
    });
  }
  getCommonUniformsInfo() {
    const {
      opacity = 1,
      baseColor = 'rgb(16,16,16)',
      brightColor = 'rgb(255,176,38)',
      windowColor = 'rgb(30,60,89)',
      time = 0,
      sweep = {
        enable: false,
        sweepRadius: 1,
        sweepColor: 'rgb(255, 255, 255)',
        sweepSpeed: 0.4,
        sweepCenter: this.cityCenter
      }
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_baseColor: (0, _l7Utils.rgb2arr)(baseColor),
      u_brightColor: (0, _l7Utils.rgb2arr)(brightColor),
      u_windowColor: (0, _l7Utils.rgb2arr)(windowColor),
      u_circleSweepColor: [...(0, _l7Utils.rgb2arr)(sweep.sweepColor).slice(0, 3), 1.0],
      u_cityCenter: sweep.sweepCenter || this.cityCenter,
      u_circleSweep: sweep.enable ? 1.0 : 0.0,
      u_cityMinSize: this.cityMinSize * sweep.sweepRadius,
      u_circleSweepSpeed: sweep.sweepSpeed,
      u_opacity: opacity,
      u_near: 0,
      u_far: 1,
      u_time: this.layer.getLayerAnimateTime() || time
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  calCityGeo() {
    // @ts-ignore
    const [minLng, minLat, maxLng, maxLat] = this.layer.getSource().extent;
    const w = maxLng - minLng;
    const h = maxLat - minLat;
    this.cityCenter = [(maxLng + minLng) / 2, (maxLat + minLat) / 2];
    this.cityMinSize = Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2)) / 4;
  }
  initModels() {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      _this.calCityGeo();
      _this.initUniformsBuffer();
      _this.startModelAnimate();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      const model = yield _this2.layer.buildLayerModel({
        moduleName: 'cityBuilding',
        vertexShader: buildVert,
        fragmentShader: buildFrag,
        triangulation: _triangulation.PolygonExtrudeTriangulation,
        depth: {
          enable: true
        },
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        cull: {
          enable: true,
          face: _l7Core.gl.BACK
        }
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    // point layer size;
    this.styleAttributeService.registerStyleAttribute({
      name: 'normal',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Normal',
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: _l7Core.gl.STATIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'size',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Size',
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: _l7Core.gl.DYNAMIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 1,
        update: feature => {
          const {
            size = 10
          } = feature;
          return Array.isArray(size) ? [size[0]] : [size];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: 'uv',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Uv',
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: _l7Core.gl.DYNAMIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
}
exports.default = CityBuildModel;