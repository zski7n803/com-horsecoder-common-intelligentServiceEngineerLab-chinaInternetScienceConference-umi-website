"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Core = require("@antv/l7-core");
var _BaseModel = _interopRequireDefault(require("../../core/BaseModel"));
/* babel-plugin-inline-import '../shaders/plane_frag.glsl' */
const planeFrag = "uniform sampler2D u_texture;\nlayout(std140) uniform commonUniforms {\n  float u_opacity;\n  float u_mapFlag;\n  float u_terrainClipHeight;\n};\n\nin vec3 v_Color;\nin vec2 v_uv;\nin float v_clip;\nout vec4 outputColor;\n\n#pragma include \"picking\"\nvoid main() {\n  if (u_mapFlag > 0.0) {\n    outputColor = texture(SAMPLER_2D(u_texture), vec2(v_uv.x, 1.0 - v_uv.y));\n    outputColor.a *= u_opacity;\n  } else {\n    outputColor = vec4(v_Color, u_opacity);\n  }\n  outputColor.a *= v_clip;\n  outputColor = filterColor(outputColor);\n}\n";
/* babel-plugin-inline-import '../shaders/plane_vert.glsl' */
const planeVert = "layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec3 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  float u_opacity;\n  float u_mapFlag;\n  float u_terrainClipHeight;\n};\n\nout vec3 v_Color;\nout vec2 v_uv;\nout float v_clip;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\nvoid main() {\n  v_Color = a_Color;\n  v_uv = a_Uv;\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n  v_clip = 1.0;\n  if (a_Position.z < u_terrainClipHeight) {\n    v_clip = 0.0;\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, a_Position.z, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n";
class PlaneModel extends _BaseModel.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "texture", void 0);
    (0, _defineProperty2.default)(this, "terrainImage", void 0);
    (0, _defineProperty2.default)(this, "terrainImageLoaded", false);
    (0, _defineProperty2.default)(this, "mapTexture", void 0);
    (0, _defineProperty2.default)(this, "planeGeometryTriangulation", () => {
      const {
        width = 1,
        height = 1,
        widthSegments = 1,
        heightSegments = 1,
        center = [120, 30],
        terrainTexture,
        rgb2height = (r, g, b) => r + g + b
      } = this.layer.getLayerConfig();
      const {
        indices,
        positions
      } = this.initPlane(width, height, widthSegments, heightSegments, ...center);
      if (terrainTexture) {
        // 存在地形贴图的时候会根据地形贴图对顶点进行偏移
        return this.translateVertex(positions, indices, this.terrainImage, widthSegments, heightSegments, rgb2height);
      }
      return {
        vertices: positions,
        indices,
        size: 5
      };
    });
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      UV: 10
    });
  }
  initPlane(width = 1, height = 1, widthSegments = 1, heightSegments = 1, lng = 120, lat = 30) {
    // https://github.com/mrdoob/three.js/blob/dev/src/geometries/PlaneGeometry.js
    const widthHalf = width / 2;
    const heightHalf = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segmentWidth = width / gridX;
    const segmentHeight = height / gridY;
    const indices = [];
    const positions = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segmentHeight - heightHalf;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segmentWidth - widthHalf;
        positions.push(x + lng, -y + lat, 0);
        positions.push(ix / gridX);
        positions.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    return {
      indices,
      positions
    };
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity,
      mapTexture,
      terrainClipHeight = 0,
      terrainTexture
    } = this.layer.getLayerConfig();
    if (this.mapTexture !== mapTexture) {
      var _this$texture;
      this.mapTexture = mapTexture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
      this.updateTexture(mapTexture);
    }
    const commonOptions = {
      u_opacity: opacity || 1,
      u_mapFlag: mapTexture ? 1 : 0,
      u_terrainClipHeight: terrainTexture ? terrainClipHeight : -1,
      u_texture: this.texture
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  clearModels() {
    var _this$texture2;
    // @ts-ignore
    this.terrainImage = null;
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    this.textures = [];
  }
  initModels() {
    var _this = this;
    return (0, _asyncToGenerator2.default)(function* () {
      const {
        mapTexture,
        terrainTexture
      } = _this.layer.getLayerConfig();
      _this.mapTexture = mapTexture;
      const {
        createTexture2D
      } = _this.rendererService;
      _this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      _this.updateTexture(mapTexture);
      _this.initUniformsBuffer();
      if (terrainTexture) {
        _this.terrainImage = yield _this.loadTerrainImage(terrainTexture);
      }
      const model = yield _this.layer.buildLayerModel({
        moduleName: 'geometryPlane',
        vertexShader: planeVert,
        fragmentShader: planeFrag,
        triangulation: _this.planeGeometryTriangulation,
        defines: _this.getDefines(),
        inject: _this.getInject(),
        primitive: _l7Core.gl.TRIANGLES,
        depth: {
          enable: true
        },
        cull: {
          enable: true,
          face: _l7Core.gl.BACK // gl.FRONT | gl.BACK;
        }
      });
      return [model];
    })();
  }
  buildModels() {
    var _this2 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      return _this2.initModels();
    })();
  }
  createModelData(options) {
    if (options) {
      const {
        widthSegments: oldwidthSegments,
        heightSegments: oldheightSegments,
        width: oldwidth,
        height: oldheight
      } = this.layer.getLayerConfig();
      const {
        widthSegments,
        heightSegments,
        width,
        height
      } = options;
      this.layer.style({
        widthSegments: widthSegments !== undefined ? widthSegments : oldwidthSegments,
        heightSegments: heightSegments !== undefined ? heightSegments : oldheightSegments,
        width: width !== undefined ? width : oldwidth,
        height: height !== undefined ? height : oldheight
      });
    }
    const oldFeatures = this.layer.getEncodedData();
    const res = this.styleAttributeService.createAttributesAndIndices(oldFeatures, this.planeGeometryTriangulation);
    return res;
  }
  updateTexture(mapTexture) {
    const {
      createTexture2D
    } = this.rendererService;
    if (mapTexture) {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        this.texture = createTexture2D({
          data: img,
          width: img.width,
          height: img.height,
          wrapS: _l7Core.gl.CLAMP_TO_EDGE,
          wrapT: _l7Core.gl.CLAMP_TO_EDGE
        });
        this.layerService.reRender();
      };
      img.src = mapTexture;
    } else {
      this.texture = createTexture2D({
        width: 0,
        height: 0
      });
    }
  }
  getImageData(img) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const {
      width,
      height
    } = img;
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img, 0, 0, width, height);
    const imageData = ctx.getImageData(0, 0, width, height);
    return imageData;
  }
  translateVertex(positions, indices, image, widthSegments, heightSegments, rgb2height) {
    const imgWidth = image.width;
    const imgHeight = image.height;
    const imageData = this.getImageData(image).data;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const widthStep = imgWidth / gridX;
    const heightStep = imgHeight / gridY;
    for (let iy = 0; iy < gridY1; iy++) {
      const imgIndexY = Math.floor(iy * heightStep);
      const imgLen = imgIndexY * imgWidth;
      for (let ix = 0; ix < gridX1; ix++) {
        const imgIndexX = Math.floor(ix * widthStep);
        const imgDataIndex = (imgLen + imgIndexX) * 4;
        const r = imageData[imgDataIndex];
        const g = imageData[imgDataIndex + 1];
        const b = imageData[imgDataIndex + 2];
        const z = (iy * gridX1 + ix) * 5 + 2;
        positions[z] = rgb2height(r, g, b);
      }
    }
    return {
      vertices: positions,
      indices,
      size: 5
    };
  }
  loadTerrainImage(terrainTexture) {
    var _this3 = this;
    return (0, _asyncToGenerator2.default)(function* () {
      if (_this3.terrainImage) {
        // 若当前已经存在 image，直接进行偏移计算（LOD）
        if (_this3.terrainImageLoaded) {
          return _this3.terrainImage;
        } else {
          return new Promise(resolve => {
            _this3.terrainImage.onload = () => {
              resolve(_this3.terrainImage);
            };
          });
        }
      } else {
        // 加载地形贴图、根据地形贴图对 planeGeometry 进行偏移
        const terrainImage = new Image();
        terrainImage.crossOrigin = 'anonymous';
        return new Promise(resolve => {
          terrainImage.onload = () => {
            _this3.terrainImageLoaded = true;
            resolve(terrainImage);
            // 图片加载完，触发事件，可以进行地形图的顶点计算存储
            setTimeout(() => _this3.layer.emit('terrainImageLoaded', null));
          };
          terrainImage.src = terrainTexture;
        });
      }
    })();
  }
  registerBuiltinAttributes() {
    // point layer size;
    this.styleAttributeService.registerStyleAttribute({
      name: 'uv',
      type: _l7Core.AttributeType.Attribute,
      descriptor: {
        name: 'a_Uv',
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: _l7Core.gl.DYNAMIC_DRAW,
          data: [],
          type: _l7Core.gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
}
exports.default = PlaneModel;