var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/parser/raster-tile.ts
import { RasterTileType } from "@antv/l7-core";
import { getCustomData, getCustomImageData } from "../utils/tile/getCustomData";
import { defaultFormat, getTileBuffer, getTileImage } from "../utils/tile/getRasterTile";
import { extentToCoord } from "../utils/util";
var DEFAULT_CONFIG = {
  tileSize: 256,
  minZoom: 0,
  maxZoom: Infinity,
  zoomOffset: 0,
  warp: true
};
var rasterDataTypes = [RasterTileType.ARRAYBUFFER, RasterTileType.RGB];
function isUrlError(url) {
  if (Array.isArray(url) && url.length === 0) {
    return true;
  }
  if (!Array.isArray(url) && typeof url !== "string") {
    return true;
  }
  return false;
}
function rasterTile(data, cfg = {}) {
  if (isUrlError(data)) {
    throw new Error("tile server url is error");
  }
  const { extent = [Infinity, Infinity, -Infinity, -Infinity], coordinates } = cfg;
  let tileDataType = (cfg == null ? void 0 : cfg.dataType) || RasterTileType.IMAGE;
  if (tileDataType === RasterTileType.RGB) {
    tileDataType = RasterTileType.ARRAYBUFFER;
  }
  const getTileData = (tileParams, tile) => {
    switch (tileDataType) {
      case RasterTileType.IMAGE:
        return getTileImage(data, tileParams, tile, cfg);
      case RasterTileType.CUSTOMIMAGE:
      case RasterTileType.CUSTOMTERRAINRGB:
        return getCustomImageData(
          // 自定义地形请求方式数据
          tile,
          // @ts-ignore
          cfg == null ? void 0 : cfg.getCustomData
        );
      case RasterTileType.ARRAYBUFFER:
        return getTileBuffer(data, tileParams, tile, cfg);
      case RasterTileType.CUSTOMARRAYBUFFER:
      case RasterTileType.CUSTOMRGB:
        return getCustomData(
          tile,
          // @ts-ignore
          cfg == null ? void 0 : cfg.getCustomData,
          (cfg == null ? void 0 : cfg.format) || defaultFormat,
          cfg == null ? void 0 : cfg.operation
        );
      default:
        return getTileImage(data, tileParams, tile, cfg);
    }
  };
  const tilesetOptions = __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_CONFIG), cfg), { getTileData });
  const rasterTileCoord = extentToCoord(coordinates, extent);
  return {
    data,
    dataArray: [
      {
        _id: 1,
        coordinates: rasterTileCoord
      }
    ],
    tilesetOptions,
    isTile: true
  };
}
export {
  rasterTile as default,
  rasterDataTypes
};
