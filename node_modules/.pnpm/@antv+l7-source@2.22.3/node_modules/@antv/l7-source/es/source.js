var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/source.ts
import { SyncHook } from "@antv/async-hook";
import { TilesetManager, bBoxToBounds, extent, lodashUtil, padBounds } from "@antv/l7-utils";
import { EventEmitter } from "eventemitter3";
import { getParser, getTransform } from "./factory";
import { cluster } from "./transform/cluster";
import { statMap } from "./utils/statistics";
import { getColumn } from "./utils/util";
var { cloneDeep, isFunction, isString, mergeWith } = lodashUtil;
function mergeCustomizer(objValue, srcValue) {
  if (Array.isArray(srcValue)) {
    return srcValue;
  }
}
var Source = class extends EventEmitter {
  constructor(data, cfg) {
    super();
    this.type = "source";
    this.isTile = false;
    this.inited = false;
    // 生命周期钩子
    this.hooks = {
      init: new SyncHook()
    };
    this.parser = { type: "geojson" };
    this.transforms = [];
    this.cluster = false;
    this.clusterOptions = {
      enable: false,
      radius: 40,
      maxZoom: 20,
      zoom: -99,
      method: "count"
    };
    // 是否有效范围
    this.invalidExtent = false;
    this.dataArrayChanged = false;
    this.cfg = {
      autoRender: true
    };
    this.originData = data;
    this.initCfg(cfg);
    this.init().then(() => {
      this.inited = true;
      this.emit("update", {
        type: "inited"
      });
    });
  }
  getSourceCfg() {
    return this.cfg;
  }
  getClusters(zoom) {
    return this.clusterIndex.getClusters(this.caculClusterExtent(2), zoom);
  }
  getClustersLeaves(id) {
    return this.clusterIndex.getLeaves(id, Infinity);
  }
  getParserType() {
    return this.parser.type;
  }
  updateClusterData(zoom) {
    const { method = "sum", field } = this.clusterOptions;
    let data = this.clusterIndex.getClusters(this.caculClusterExtent(2), Math.floor(zoom));
    this.clusterOptions.zoom = zoom;
    data.forEach((p) => {
      if (!p.id) {
        p.properties.point_count = 1;
      }
    });
    if (field || isFunction(method)) {
      data = data.map((item) => {
        const id = item.id;
        if (id) {
          const points = this.clusterIndex.getLeaves(id, Infinity);
          const properties = points.map((d) => d.properties);
          let statNum;
          if (isString(method) && field) {
            const column = getColumn(properties, field);
            statNum = statMap[method](column);
          }
          if (isFunction(method)) {
            statNum = method(properties);
          }
          item.properties.stat = statNum;
        } else {
          item.properties.point_count = 1;
        }
        return item;
      });
    }
    this.data = getParser("geojson")({
      type: "FeatureCollection",
      features: data
    });
    this.executeTrans();
  }
  getFeatureById(id) {
    const { type = "geojson", geometry } = this.parser;
    if (type === "geojson" && !this.cluster) {
      const feature = id < this.originData.features.length ? this.originData.features[id] : "null";
      const newFeature = cloneDeep(feature);
      if ((newFeature == null ? void 0 : newFeature.properties) && (this.transforms.length !== 0 || this.dataArrayChanged)) {
        const item = this.data.dataArray.find((dataItem) => {
          return dataItem._id === id;
        });
        newFeature.properties = item;
      }
      return newFeature;
    } else if (type === "json" && geometry) {
      return this.data.dataArray.find((dataItem) => dataItem._id === id);
    } else {
      return id < this.data.dataArray.length ? this.data.dataArray[id] : "null";
    }
  }
  updateFeaturePropertiesById(id, properties) {
    this.data.dataArray = this.data.dataArray.map((dataItem) => {
      if (dataItem._id === id) {
        return __spreadValues(__spreadValues({}, dataItem), properties);
      }
      return dataItem;
    });
    this.dataArrayChanged = true;
    this.emit("update", {
      type: "update"
    });
  }
  getFeatureId(field, value) {
    const feature = this.data.dataArray.find((dataItem) => {
      return dataItem[field] === value;
    });
    return feature == null ? void 0 : feature._id;
  }
  setData(data, options) {
    this.originData = data;
    this.dataArrayChanged = false;
    this.initCfg(options);
    this.init().then(() => {
      this.emit("update", {
        type: "update"
      });
    });
  }
  reloadAllTile() {
    var _a;
    (_a = this.tileset) == null ? void 0 : _a.reloadAll();
  }
  reloadTilebyId(z, x, y) {
    var _a;
    (_a = this.tileset) == null ? void 0 : _a.reloadTileById(z, x, y);
  }
  reloadTileByLnglat(lng, lat, z) {
    var _a;
    (_a = this.tileset) == null ? void 0 : _a.reloadTileByLnglat(lng, lat, z);
  }
  getTileExtent(e, zoom) {
    var _a;
    return (_a = this.tileset) == null ? void 0 : _a.getTileExtent(e, zoom);
  }
  getTileByZXY(z, x, y) {
    var _a;
    return (_a = this.tileset) == null ? void 0 : _a.getTileByZXY(z, x, y);
  }
  reloadTileByExtent(bounds, z) {
    var _a;
    (_a = this.tileset) == null ? void 0 : _a.reloadTileByExtent(bounds, z);
  }
  destroy() {
    var _a;
    this.removeAllListeners();
    this.originData = null;
    this.clusterIndex = null;
    this.data = null;
    (_a = this.tileset) == null ? void 0 : _a.destroy();
  }
  processData() {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => {
        try {
          this.excuteParser();
          this.initCluster();
          this.executeTrans();
          resolve({});
        } catch (err) {
          reject(err);
        }
      });
    });
  }
  initCfg(option) {
    this.cfg = mergeWith(this.cfg, option, mergeCustomizer);
    const cfg = this.cfg;
    if (cfg) {
      if (cfg.parser) {
        this.parser = cfg.parser;
      }
      if (cfg.transforms) {
        this.transforms = cfg.transforms;
      }
      this.cluster = cfg.cluster || false;
      if (cfg.clusterOptions) {
        this.cluster = true;
        this.clusterOptions = __spreadValues(__spreadValues({}, this.clusterOptions), cfg.clusterOptions);
      }
    }
  }
  init() {
    return __async(this, null, function* () {
      this.inited = false;
      yield this.processData();
      this.inited = true;
    });
  }
  /**
   * 数据解析
   */
  excuteParser() {
    const parser = this.parser;
    const type = parser.type || "geojson";
    const sourceParser = getParser(type);
    this.data = sourceParser(this.originData, parser);
    this.tileset = this.initTileset();
    if (parser.cancelExtent) {
      return;
    }
    this.extent = extent(this.data.dataArray);
    this.setCenter(this.extent);
    this.invalidExtent = this.extent[0] === this.extent[2] || this.extent[1] === this.extent[3];
  }
  setCenter(bbox) {
    this.center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];
    if (isNaN(this.center[0]) || isNaN(this.center[1])) {
      this.center = [108.92361111111111, 34.54083333333333];
    }
  }
  /**
   * 瓦片数据管理器
   */
  initTileset() {
    const { tilesetOptions } = this.data;
    if (!tilesetOptions) {
      return;
    }
    this.isTile = true;
    if (this.tileset) {
      this.tileset.updateOptions(tilesetOptions);
      return this.tileset;
    }
    const tileset = new TilesetManager(__spreadValues({}, tilesetOptions));
    return tileset;
  }
  /**
   * 数据统计
   */
  executeTrans() {
    const trans = this.transforms;
    trans.forEach((tran) => {
      const { type } = tran;
      const data = getTransform(type)(this.data, tran);
      Object.assign(this.data, data);
    });
  }
  /**
   * 数据聚合
   */
  initCluster() {
    if (!this.cluster) {
      return;
    }
    const clusterOptions = this.clusterOptions || {};
    this.clusterIndex = cluster(this.data, clusterOptions);
  }
  caculClusterExtent(bufferRatio) {
    let newBounds = [
      [-Infinity, -Infinity],
      [Infinity, Infinity]
    ];
    if (!this.invalidExtent) {
      newBounds = padBounds(bBoxToBounds(this.extent), bufferRatio);
    }
    return newBounds[0].concat(newBounds[1]);
  }
};
export {
  Source as default
};
