var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/transform/cluster.ts
import Supercluster from "supercluster/dist/supercluster";
function cluster(data, option) {
  const { radius = 40, maxZoom = 18, minZoom = 0, zoom = 2 } = option;
  if (data.pointIndex) {
    const clusterData = data.pointIndex.getClusters(data.extent, Math.floor(zoom));
    data.dataArray = formatData(clusterData);
    return data;
  }
  const pointIndex = new Supercluster({
    radius,
    minZoom,
    maxZoom
  });
  const geojson = {
    type: "FeatureCollection",
    features: []
  };
  geojson.features = data.dataArray.map((item) => {
    return {
      type: "Feature",
      geometry: {
        type: "Point",
        coordinates: item.coordinates
      },
      properties: __spreadValues({}, item)
    };
  });
  pointIndex.load(geojson.features);
  return pointIndex;
}
function formatData(clusterPoint) {
  return clusterPoint.map((point, index) => {
    return __spreadValues({
      coordinates: point.geometry.coordinates,
      _id: index + 1
    }, point.properties);
  });
}
export {
  cluster,
  formatData
};
