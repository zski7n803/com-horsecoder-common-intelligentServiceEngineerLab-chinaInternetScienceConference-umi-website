var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/transform/hexagon.ts
var hexagon_exports = {};
__export(hexagon_exports, {
  pointToHexbin: () => pointToHexbin
});
module.exports = __toCommonJS(hexagon_exports);
var import_l7_utils = require("@antv/l7-utils");
var import_d3_hexbin = require("d3-hexbin");
var R_EARTH = 6378e3;
function pointToHexbin(data, option) {
  const dataArray = data.dataArray;
  const { size = 10, method = "sum" } = option;
  const pixlSize = size / (2 * Math.PI * R_EARTH) * (256 << 20) / 2;
  const screenPoints = dataArray.map((point) => {
    const [x, y] = (0, import_l7_utils.aProjectFlat)(point.coordinates);
    return __spreadProps(__spreadValues({}, point), {
      coordinates: [x, y]
    });
  });
  const newHexbin = (0, import_d3_hexbin.hexbin)().radius(pixlSize).x((d) => d.coordinates[0]).y((d) => d.coordinates[1]);
  const hexbinBins = newHexbin(screenPoints);
  const result = {
    dataArray: hexbinBins.map((hex, index) => {
      if (option.field && method) {
        const columns = import_l7_utils.Satistics.getColumn(hex, option.field);
        hex[method] = import_l7_utils.Satistics.statMap[method](columns);
      }
      return {
        [option.method]: hex[method],
        count: hex.length,
        rawData: hex,
        coordinates: [hex.x, hex.y],
        _id: index
      };
    }),
    radius: pixlSize,
    xOffset: pixlSize,
    yOffset: pixlSize,
    type: "hexagon"
  };
  return result;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  pointToHexbin
});
