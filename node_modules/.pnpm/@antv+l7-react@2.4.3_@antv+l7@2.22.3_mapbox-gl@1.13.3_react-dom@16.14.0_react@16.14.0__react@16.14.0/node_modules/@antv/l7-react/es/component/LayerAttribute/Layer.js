function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
import { CityBuildingLayer, HeatmapLayer, ImageLayer, LineLayer, PointLayer, PolygonLayer, RasterLayer } from '@antv/l7';
import * as React from 'react';
import { LayerContext } from '../LayerContext';
import { useSceneValue } from '../SceneContext';
import { Active, Animate, Color, Filter, Scale, Select, Shape, Size, Source, Style } from './';
var useEffect = React.useEffect,
  useState = React.useState;
export default function BaseLayer(type, props) {
  var source = props.source,
    color = props.color,
    shape = props.shape,
    style = props.style,
    size = props.size,
    scale = props.scale,
    active = props.active,
    select = props.select,
    filter = props.filter,
    animate = props.animate,
    options = props.options,
    onLayerLoaded = props.onLayerLoaded;
  var mapScene = useSceneValue();
  var _useState = useState(function () {
      var l;
      switch (type) {
        case 'polygonLayer':
          l = new PolygonLayer(options);
          break;
        case 'lineLayer':
          l = new LineLayer(options);
          break;
        case 'pointLayer':
          l = new PointLayer(options);
          break;
        case 'heatmapLayer':
          l = new HeatmapLayer(options);
          break;
        case 'rasterLayer':
          l = new RasterLayer(options);
          break;
        case 'imageLayer':
          l = new ImageLayer(options);
          break;
        case 'citybuildingLayer':
          l = new CityBuildingLayer(options);
          break;
        default:
          l = new PolygonLayer(options);
      }
      l.on('inited', function () {
        if (onLayerLoaded) {
          onLayerLoaded(l, mapScene);
        }
      });
      return l;
    }),
    _useState2 = _slicedToArray(_useState, 1),
    layer = _useState2[0];
  useEffect(function () {
    mapScene.addLayer(layer);
    return function () {
      mapScene.removeLayer(layer);
    };
  }, []);
  useEffect(function () {
    if (layer.inited && options) {
      layer.updateLayerConfig(options);
    }
  }, [options === null || options === void 0 ? void 0 : options.minZoom, options === null || options === void 0 ? void 0 : options.maxZoom, options === null || options === void 0 ? void 0 : options.visible]);
  useEffect(function () {
    if (layer.inited && (options === null || options === void 0 ? void 0 : options.zIndex)) {
      layer.setIndex(options.zIndex);
    }
  }, [options === null || options === void 0 ? void 0 : options.zIndex]);
  useEffect(function () {
    if (layer.inited && (options === null || options === void 0 ? void 0 : options.blend)) {
      layer.setBlend(options.blend);
    }
  }, [options === null || options === void 0 ? void 0 : options.blend]);
  useEffect(function () {
    // 重绘layer
    mapScene.render();
  });
  return /*#__PURE__*/React.createElement(LayerContext.Provider, {
    value: layer
  }, /*#__PURE__*/React.createElement(Source, {
    layer: layer,
    source: source
  }), scale && /*#__PURE__*/React.createElement(Scale, {
    layer: layer,
    scale: scale
  }), color && /*#__PURE__*/React.createElement(Color, {
    layer: layer,
    color: color
  }), size && /*#__PURE__*/React.createElement(Size, {
    layer: layer,
    size: size
  }), shape && /*#__PURE__*/React.createElement(Shape, {
    layer: layer,
    shape: shape
  }), style && /*#__PURE__*/React.createElement(Style, {
    layer: layer,
    style: style
  }), active && /*#__PURE__*/React.createElement(Active, {
    layer: layer,
    active: active
  }), select && /*#__PURE__*/React.createElement(Select, {
    layer: layer,
    select: select
  }), filter && /*#__PURE__*/React.createElement(Filter, {
    layer: layer,
    filter: filter
  }), animate && /*#__PURE__*/React.createElement(Animate, {
    layer: layer,
    animate: animate
  }), props.children);
}