var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/ajax.ts
var ajax_exports = {};
__export(ajax_exports, {
  AJAXError: () => AJAXError,
  formatImage: () => formatImage,
  getArrayBuffer: () => getArrayBuffer,
  getData: () => getData,
  getImage: () => getImage,
  getJSON: () => getJSON,
  getProtocolAction: () => getProtocolAction,
  makeXMLHttpRequestPromise: () => makeXMLHttpRequestPromise,
  postData: () => postData,
  sameOrigin: () => sameOrigin
});
module.exports = __toCommonJS(ajax_exports);
var import_config = require("./config");
var getProtocolAction = (url) => import_config.SceneConifg.REGISTERED_PROTOCOLS[url.substring(0, url.indexOf("://"))];
var AJAXError = class extends Error {
  constructor(status, statusText, url, body) {
    super(`AJAXError: ${statusText} (${status}): ${url}`);
    this.status = status;
    this.statusText = statusText;
    this.url = url;
    this.body = body;
  }
};
function makeXMLHttpRequest(requestParameters, callback) {
  const xhr = new XMLHttpRequest();
  const url = Array.isArray(requestParameters.url) ? requestParameters.url[0] : requestParameters.url;
  xhr.open(requestParameters.method || "GET", url, true);
  if (requestParameters.type === "arrayBuffer") {
    xhr.responseType = "arraybuffer";
  }
  for (const k in requestParameters.headers) {
    if (requestParameters.headers.hasOwnProperty(k)) {
      xhr.setRequestHeader(k, requestParameters.headers[k]);
    }
  }
  if (requestParameters.type === "json") {
    xhr.responseType = "text";
    xhr.setRequestHeader("Accept", "application/json");
  }
  xhr.withCredentials = requestParameters.credentials === "include";
  xhr.onerror = () => {
    callback(new Error(xhr.statusText));
  };
  xhr.onload = () => {
    if ((xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) && xhr.response !== null) {
      let data = xhr.response;
      if (requestParameters.type === "json") {
        try {
          data = JSON.parse(xhr.response);
        } catch (err) {
          return callback(err);
        }
      }
      callback(
        null,
        data,
        xhr.getResponseHeader("Cache-Control"),
        xhr.getResponseHeader("Expires"),
        xhr
      );
    } else {
      const body = new Blob([xhr.response], {
        type: xhr.getResponseHeader("Content-Type")
      });
      callback(new AJAXError(xhr.status, xhr.statusText, url.toString(), body));
    }
  };
  xhr.cancel = xhr.abort;
  xhr.send(requestParameters.body);
  return xhr;
}
function makeXMLHttpRequestPromise(requestParameters) {
  return new Promise((resolve, reject) => {
    makeXMLHttpRequest(requestParameters, (error, data, cacheControl, expires, xhr) => {
      if (error) {
        reject({
          err: error,
          data: null,
          xhr
        });
      } else {
        resolve({
          err: null,
          data,
          cacheControl,
          expires,
          xhr
        });
      }
    });
  });
}
function makeRequest(requestParameters, callback) {
  return makeXMLHttpRequest(requestParameters, callback);
}
var getJSON = (requestParameters, callback) => {
  const action = getProtocolAction(requestParameters.url) || makeRequest;
  return action(__spreadProps(__spreadValues({}, requestParameters), { type: "json" }), callback);
};
var getArrayBuffer = (requestParameters, callback) => {
  const action = getProtocolAction(requestParameters.url) || makeRequest;
  return action(__spreadProps(__spreadValues({}, requestParameters), { type: "arrayBuffer" }), callback);
};
var postData = (requestParameters, callback) => {
  return makeRequest(__spreadProps(__spreadValues({}, requestParameters), { method: "POST" }), callback);
};
var getData = (requestParameters, callback) => {
  return makeRequest(__spreadProps(__spreadValues({}, requestParameters), { method: "GET" }), callback);
};
function sameOrigin(url) {
  const a = window.document.createElement("a");
  a.href = url;
  return a.protocol === window.document.location.protocol && a.host === window.document.location.host;
}
var transparentPngUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
function arrayBufferToImage(data, callback) {
  const img = new window.Image();
  const URL = window.URL || window.webkitURL;
  img.crossOrigin = "anonymous";
  img.onload = () => {
    callback(null, img);
    URL.revokeObjectURL(img.src);
    img.onload = null;
    window.requestAnimationFrame(() => {
      img.src = transparentPngUrl;
    });
  };
  img.onerror = () => callback(
    new Error(
      "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."
    )
  );
  const blob = new Blob([new Uint8Array(data)], { type: "image/png" });
  img.src = data.byteLength ? URL.createObjectURL(blob) : transparentPngUrl;
}
function arrayBufferToImageBitmap(data, callback) {
  const blob = new Blob([new Uint8Array(data)], { type: "image/png" });
  createImageBitmap(blob).then((imgBitmap) => {
    callback(null, imgBitmap);
  }).catch((e) => {
    callback(
      new Error(
        `Could not load image because of ${e.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`
      )
    );
  });
}
var getImage = (requestParameters, callback, transformResponse) => {
  const optionFunc = (err, imgData) => {
    if (err) {
      callback(err);
    } else if (imgData) {
      const imageBitmapSupported = typeof createImageBitmap === "function";
      const transformImgData = transformResponse ? transformResponse(imgData) : imgData;
      if (imageBitmapSupported) {
        arrayBufferToImageBitmap(transformImgData, callback);
      } else {
        arrayBufferToImage(transformImgData, callback);
      }
    }
  };
  if (requestParameters.type === "json") {
    return getJSON(requestParameters, optionFunc);
  } else {
    return getArrayBuffer(requestParameters, optionFunc);
  }
};
var formatImage = (imgData, callback) => {
  const imageBitmapSupported = typeof createImageBitmap === "function";
  if (imageBitmapSupported) {
    arrayBufferToImageBitmap(imgData, callback);
  } else {
    arrayBufferToImage(imgData, callback);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AJAXError,
  formatImage,
  getArrayBuffer,
  getData,
  getImage,
  getJSON,
  getProtocolAction,
  makeXMLHttpRequestPromise,
  postData,
  sameOrigin
});
