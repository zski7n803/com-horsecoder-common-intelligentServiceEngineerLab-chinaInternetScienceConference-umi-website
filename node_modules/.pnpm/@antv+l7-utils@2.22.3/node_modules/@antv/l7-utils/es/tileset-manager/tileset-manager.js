var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/tileset-manager/tileset-manager.ts
import EventEmitter from "eventemitter3";
import { lodashUtil } from "../lodash-adapter";
import {
  BOUNDS_BUFFER_SCALE,
  DEFAULT_CACHE_SCALE,
  DEFAULT_EXTENT,
  NOOP,
  UPDATE_TILE_STRATEGIES
} from "./const";
import { SourceTile } from "./tile";
import { UpdateTileStrategy } from "./types";
import { getLatLonBoundsBuffer, isLatLonBoundsContains } from "./utils/bound-buffer";
import { getTileIndices, osmLonLat2TileXY } from "./utils/lonlat-tile";
var { throttle } = lodashUtil;
var TileEventType = /* @__PURE__ */ ((TileEventType2) => {
  TileEventType2["TilesLoadStart"] = "tiles-load-start";
  TileEventType2["TileLoaded"] = "tile-loaded";
  TileEventType2["TileError"] = "tile-error";
  TileEventType2["TileUnload"] = "tile-unload";
  TileEventType2["TileUpdate"] = "tile-update";
  TileEventType2["TilesLoadFinished"] = "tiles-load-finished";
  return TileEventType2;
})(TileEventType || {});
var TilesetManager = class extends EventEmitter {
  constructor(options) {
    super();
    // 当前层级的瓦片
    this.currentTiles = [];
    // 缓存的瓦片，key 为 {z}-{x}-{y}
    this.cacheTiles = /* @__PURE__ */ new Map();
    this.throttleUpdate = throttle((zoom, latLonBounds) => {
      this.update(zoom, latLonBounds);
    }, 16);
    // 瓦片加载成功回调
    this.onTileLoad = (tile) => {
      this.emit("tile-loaded" /* TileLoaded */, tile);
      this.updateTileVisible();
      this.loadFinished();
    };
    // 瓦片加载失败回调
    this.onTileError = (error, tile) => {
      this.emit("tile-error" /* TileError */, { error, tile });
      this.updateTileVisible();
      this.loadFinished();
    };
    // 瓦片被删除回调
    this.onTileUnload = (tile) => {
      this.emit("tile-unload" /* TileUnload */, tile);
      this.loadFinished();
    };
    this.options = {
      tileSize: 256,
      minZoom: 0,
      maxZoom: Infinity,
      zoomOffset: 0,
      extent: DEFAULT_EXTENT,
      getTileData: NOOP,
      warp: true,
      // TODO 更新策略
      updateStrategy: UpdateTileStrategy.Replace
    };
    this.updateOptions(options);
  }
  get isLoaded() {
    return this.currentTiles.every((tile) => tile.isDone);
  }
  // 缓存的瓦片数组
  get tiles() {
    const tiles = Array.from(this.cacheTiles.values()).sort((t1, t2) => t1.z - t2.z);
    return tiles;
  }
  // 更新配置项
  updateOptions(options) {
    const minZoom = options.minZoom === void 0 ? this.options.minZoom : Math.ceil(options.minZoom);
    const maxZoom = options.maxZoom === void 0 ? this.options.maxZoom : Math.floor(options.maxZoom);
    this.options = __spreadProps(__spreadValues(__spreadValues({}, this.options), options), { minZoom, maxZoom });
  }
  // 更新
  // 1.瓦片序号发生改变 2.瓦片新增 3.瓦片显隐控制
  update(zoom, latLonBounds) {
    const verifyZoom = Math.max(0, Math.ceil(zoom));
    if (this.lastViewStates && this.lastViewStates.zoom === verifyZoom && isLatLonBoundsContains(this.lastViewStates.latLonBoundsBuffer, latLonBounds)) {
      return;
    }
    const latLonBoundsBuffer = getLatLonBoundsBuffer(latLonBounds, BOUNDS_BUFFER_SCALE);
    this.lastViewStates = {
      zoom: verifyZoom,
      latLonBounds,
      latLonBoundsBuffer
    };
    this.currentZoom = verifyZoom;
    let isAddTile = false;
    const tileIndices = this.getTileIndices(verifyZoom, latLonBoundsBuffer).filter((tile) => {
      return this.options.warp || tile.x >= 0 && tile.x < Math.pow(2, verifyZoom);
    });
    this.emit("tiles-load-start" /* TilesLoadStart */);
    this.currentTiles = tileIndices.map(({ x, y, z }) => {
      let tile = this.getTile(x, y, z);
      if (tile) {
        const needsReload = (tile == null ? void 0 : tile.isFailure) || (tile == null ? void 0 : tile.isCancelled);
        if (needsReload) {
          tile.loadData({
            getData: this.options.getTileData,
            onLoad: this.onTileLoad,
            onError: this.onTileError
          });
        }
        return tile;
      }
      tile = this.createTile(x, y, z);
      isAddTile = true;
      return tile;
    });
    if (isAddTile) {
      this.resizeCacheTiles();
    }
    this.updateTileVisible();
    this.pruneRequests();
  }
  // 重新加载瓦片
  reloadAll() {
    for (const [tileId, tile] of this.cacheTiles) {
      if (!this.currentTiles.includes(tile)) {
        this.cacheTiles.delete(tileId);
        this.onTileUnload(tile);
        return;
      }
      this.onTileUnload(tile);
      tile.loadData({
        getData: this.options.getTileData,
        onLoad: this.onTileLoad,
        onError: this.onTileError
      });
    }
  }
  reloadTileById(z, x, y) {
    const tile = this.cacheTiles.get(`${x},${y},${z}`);
    if (tile) {
      this.onTileUnload(tile);
      tile.loadData({
        getData: this.options.getTileData,
        onLoad: this.onTileLoad,
        onError: this.onTileError
      });
    }
  }
  reloadTileByLnglat(lng, lat, z) {
    const tile = this.getTileByLngLat(lng, lat, z);
    if (tile) {
      this.reloadTileById(tile.z, tile.x, tile.y);
    }
  }
  reloadTileByExtent(extent, z) {
    const tiles = this.getTileIndices(z, extent);
    tiles.forEach((tile) => {
      this.reloadTileById(tile.z, tile.x, tile.y);
    });
  }
  // 取消滞留请求中的瓦片
  pruneRequests() {
    const abortCandidates = [];
    for (const tile of this.cacheTiles.values()) {
      if (tile.isLoading) {
        if (!tile.isCurrent && !tile.isVisible) {
          abortCandidates.push(tile);
        }
      }
    }
    while (abortCandidates.length > 0) {
      const tile = abortCandidates.shift();
      tile.abortLoad();
    }
  }
  getTileByLngLat(lng, lat, zoom) {
    const { zoomOffset } = this.options;
    const z = Math.ceil(zoom) + zoomOffset;
    const xy = osmLonLat2TileXY(lng, lat, z);
    const tiles = this.tiles.filter((t) => t.key === `${xy[0]}_${xy[1]}_${z}`);
    return tiles[0];
  }
  getTileExtent(extent, zoom) {
    return this.getTileIndices(zoom, extent);
  }
  getTileByZXY(z, x, y) {
    const tile = this.tiles.filter((t) => t.key === `${x}_${y}_${z}`);
    return tile[0];
  }
  // 摧毁
  clear() {
    for (const tile of this.cacheTiles.values()) {
      if (tile.isLoading) {
        tile.abortLoad();
      } else {
        this.onTileUnload(tile);
      }
    }
    this.lastViewStates = void 0;
    this.cacheTiles.clear();
    this.currentTiles = [];
  }
  // 摧毁
  destroy() {
    this.clear();
    this.removeAllListeners();
  }
  // 更新瓦片显隐状态
  updateTileVisible() {
    const updateStrategy = this.options.updateStrategy;
    const beforeVisible = /* @__PURE__ */ new Map();
    for (const tile of this.cacheTiles.values()) {
      beforeVisible.set(tile.key, tile.isVisible);
      tile.isCurrent = false;
      tile.isVisible = false;
    }
    for (const tile of this.currentTiles) {
      tile.isCurrent = true;
      tile.isVisible = true;
    }
    const tiles = Array.from(this.cacheTiles.values());
    if (typeof updateStrategy === "function") {
      updateStrategy(tiles);
    } else {
      UPDATE_TILE_STRATEGIES[updateStrategy](tiles);
    }
    let isVisibleChange = false;
    Array.from(this.cacheTiles.values()).forEach((tile) => {
      if (tile.isVisible !== beforeVisible.get(tile.key)) {
        tile.isVisibleChange = true;
        isVisibleChange = true;
      } else {
        tile.isVisibleChange = false;
      }
    });
    if (isVisibleChange) {
      this.emit("tile-update" /* TileUpdate */);
    }
  }
  // 获取当前视野层级瓦片的所有索引
  getTileIndices(zoom, latLonBounds) {
    const { tileSize, extent, zoomOffset } = this.options;
    const maxZoom = Math.floor(this.options.maxZoom);
    const minZoom = Math.ceil(this.options.minZoom);
    const indices = getTileIndices({
      maxZoom,
      minZoom,
      zoomOffset,
      tileSize,
      zoom,
      latLonBounds,
      extent
    });
    return indices;
  }
  // 获取瓦片 ID
  getTileId(x, y, z) {
    const tileId = `${x},${y},${z}`;
    return tileId;
  }
  loadFinished() {
    const finish = !this.currentTiles.some((t) => !t.isDone);
    if (finish) {
      this.emit("tiles-load-finished" /* TilesLoadFinished */);
    }
    return finish;
  }
  // 获取瓦片
  getTile(x, y, z) {
    const tileId = this.getTileId(x, y, z);
    const tile = this.cacheTiles.get(tileId);
    return tile;
  }
  // 创建瓦片
  createTile(x, y, z) {
    const tileId = this.getTileId(x, y, z);
    const tile = new SourceTile({
      x,
      y,
      z,
      tileSize: this.options.tileSize,
      warp: this.options.warp
    });
    this.cacheTiles.set(tileId, tile);
    tile.loadData({
      getData: this.options.getTileData,
      onLoad: this.onTileLoad,
      onError: this.onTileError
    });
    return tile;
  }
  // 当缓存超过最大值时，清除不可见的瓦片
  resizeCacheTiles() {
    const maxCacheSize = DEFAULT_CACHE_SCALE * this.currentTiles.length;
    const overflown = this.cacheTiles.size > maxCacheSize;
    if (overflown) {
      for (const [tileId, tile] of this.cacheTiles) {
        if (!tile.isVisible && !this.currentTiles.includes(tile)) {
          this.cacheTiles.delete(tileId);
          this.onTileUnload(tile);
        }
        if (this.cacheTiles.size <= maxCacheSize) {
          break;
        }
      }
    }
    this.rebuildTileTree();
  }
  // 重新计算瓦片树
  rebuildTileTree() {
    for (const tile of this.cacheTiles.values()) {
      tile.parent = null;
      tile.children.length = 0;
    }
    for (const tile of this.cacheTiles.values()) {
      const parent = this.getNearestAncestor(tile.x, tile.y, tile.z);
      tile.parent = parent;
      if (parent == null ? void 0 : parent.children) {
        parent.children.push(tile);
      }
    }
  }
  // 获取瓦片的最近上级的瓦片
  getNearestAncestor(x, y, z) {
    while (z > this.options.minZoom) {
      x = Math.floor(x / 2);
      y = Math.floor(y / 2);
      z = z - 1;
      const parent = this.getTile(x, y, z);
      if (parent) {
        return parent;
      }
    }
    return null;
  }
};
export {
  TileEventType,
  TilesetManager
};
