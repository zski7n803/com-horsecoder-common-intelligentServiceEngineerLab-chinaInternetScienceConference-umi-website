// src/dom.ts
import { lodashUtil } from "./lodash-adapter";
var { pull } = lodashUtil;
function getContainer(domId) {
  let $dom = domId;
  if (typeof domId === "string") {
    $dom = window.document.getElementById(domId);
  }
  return $dom;
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function splitWords(str) {
  return trim(str).split(/\s+/);
}
function testProp(props) {
  var _a;
  const docStyle = (_a = document == null ? void 0 : document.documentElement) == null ? void 0 : _a.style;
  if (!docStyle) {
    return props[0];
  }
  for (const i in props) {
    if (props[i] && props[i] in docStyle) {
      return props[i];
    }
  }
  return props[0];
}
function create(tagName, className, container) {
  const el = window.document.createElement(tagName);
  if (className) {
    el.className = className || "";
  }
  if (container) {
    container.appendChild(el);
  }
  return el;
}
function remove(el) {
  const parent = el.parentNode;
  if (parent) {
    parent.removeChild(el);
  }
}
function addClass(el, name) {
  if (el.classList !== void 0) {
    const classes = splitWords(name);
    for (let i = 0, len = classes.length; i < len; i++) {
      el.classList.add(classes[i]);
    }
  } else if (!hasClass(el, name)) {
    const className = getClass(el);
    setClass(el, (className ? className + " " : "") + name);
  }
}
function removeClass(el, name) {
  if (el.classList !== void 0) {
    const classes = splitWords(name);
    classes.forEach((className) => {
      el.classList.remove(className);
    });
  } else {
    setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
  }
}
function hasClass(el, name) {
  if (el.classList !== void 0) {
    return el.classList.contains(name);
  }
  const className = getClass(el);
  return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
}
function setClass(el, name) {
  if (el instanceof HTMLElement) {
    el.className = name;
  } else {
    el.className.baseVal = name;
  }
}
function toggleClass(el, className, force) {
  if (force === void 0) {
    if (hasClass(el, className)) {
      removeClass(el, className);
    } else {
      addClass(el, className);
    }
  } else if (force) {
    addClass(el, className);
  } else {
    removeClass(el, className);
  }
}
function getClass(el) {
  if (el instanceof SVGElement) {
    el = el.correspondingElement;
  }
  return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
}
function empty(el) {
  while (el && el.firstChild) {
    el.removeChild(el.firstChild);
  }
}
var transformProp = testProp(["transform", "WebkitTransform"]);
function setTransform(el, value) {
  el.style[transformProp] = value;
}
function triggerResize() {
  if (typeof Event === "function") {
    window.dispatchEvent(new Event("resize"));
  } else {
    const evt = window.document.createEvent("UIEvents");
    evt.initUIEvent("resize", true, false, window, 0);
    window.dispatchEvent(evt);
  }
}
function printCanvas(canvas) {
  const css = [
    "padding: " + (canvas.height / 2 - 8) + "px " + canvas.width / 2 + "px;",
    "line-height: " + canvas.height + "px;",
    "background-image: url(" + canvas.toDataURL() + ");"
  ];
  console.log("%c\n", css.join(""));
}
function getViewPortScale() {
  var _a;
  const meta = window.document.querySelector('meta[name="viewport"]');
  if (!meta) {
    return 1;
  }
  const contentItems = (_a = meta.content) == null ? void 0 : _a.split(",");
  const scale = contentItems.find((item) => {
    const [key] = item.split("=");
    return key === "initial-scale";
  });
  return scale ? scale.split("=")[1] * 1 : 1;
}
var DPR = getViewPortScale() < 1 ? 1 : window.devicePixelRatio;
function addStyle(el, style) {
  el.setAttribute("style", `${el.style.cssText}${style}`);
}
function getStyleList(style) {
  return style.split(";").map((item) => item.trim()).filter((item) => item);
}
function removeStyle(el, style) {
  var _a;
  const oldStyleList = getStyleList((_a = el.getAttribute("style")) != null ? _a : "");
  const targetStyleList = getStyleList(style);
  const newStyleList = pull(oldStyleList, ...targetStyleList);
  el.setAttribute("style", newStyleList.join(";"));
}
function css2Style(obj) {
  return Object.entries(obj).map(([key, value]) => `${key}: ${value}`).join(";");
}
function getDiffRect(dom1Rect, dom2Rect) {
  return {
    left: dom1Rect.left - dom2Rect.left,
    top: dom1Rect.top - dom2Rect.top,
    right: dom2Rect.left + dom2Rect.width - dom1Rect.left - dom1Rect.width,
    bottom: dom2Rect.top + dom2Rect.height - dom1Rect.top - dom1Rect.height
  };
}
function setChecked(el, value) {
  el.checked = value;
  if (value) {
    el.setAttribute("checked", "true");
  } else {
    el.removeAttribute("checked");
  }
}
function clearChildren(el) {
  el.innerHTML = "";
}
function setUnDraggable(el) {
  el.setAttribute("draggable", "false");
}
function appendElementType(container, children) {
  if (typeof children === "string") {
    const div = document.createElement("div");
    div.innerHTML = children;
    while (div.firstChild) {
      container.append(div.firstChild);
    }
  } else if (Array.isArray(children)) {
    container.append(...children);
  } else {
    container.append(children);
  }
}
function findParentElement(target, selector) {
  var _a;
  const selectors = Array.isArray(selector) ? selector : [selector];
  let current = target;
  while (current instanceof Element && current !== window.document.body) {
    if (selectors.find((item) => current == null ? void 0 : current.matches(item))) {
      return current;
    }
    current = (_a = current == null ? void 0 : current.parentElement) != null ? _a : null;
  }
  return void 0;
}
export {
  DPR,
  addClass,
  addStyle,
  appendElementType,
  clearChildren,
  create,
  css2Style,
  empty,
  findParentElement,
  getClass,
  getContainer,
  getDiffRect,
  getStyleList,
  getViewPortScale,
  hasClass,
  printCanvas,
  remove,
  removeClass,
  removeStyle,
  setChecked,
  setClass,
  setTransform,
  setUnDraggable,
  splitWords,
  toggleClass,
  triggerResize,
  trim
};
