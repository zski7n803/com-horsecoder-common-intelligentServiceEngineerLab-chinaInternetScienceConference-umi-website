var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/ajax.ts
import { SceneConifg } from "./config";
var getProtocolAction = (url) => SceneConifg.REGISTERED_PROTOCOLS[url.substring(0, url.indexOf("://"))];
var AJAXError = class extends Error {
  constructor(status, statusText, url, body) {
    super(`AJAXError: ${statusText} (${status}): ${url}`);
    this.status = status;
    this.statusText = statusText;
    this.url = url;
    this.body = body;
  }
};
function makeXMLHttpRequest(requestParameters, callback) {
  const xhr = new XMLHttpRequest();
  const url = Array.isArray(requestParameters.url) ? requestParameters.url[0] : requestParameters.url;
  xhr.open(requestParameters.method || "GET", url, true);
  if (requestParameters.type === "arrayBuffer") {
    xhr.responseType = "arraybuffer";
  }
  for (const k in requestParameters.headers) {
    if (requestParameters.headers.hasOwnProperty(k)) {
      xhr.setRequestHeader(k, requestParameters.headers[k]);
    }
  }
  if (requestParameters.type === "json") {
    xhr.responseType = "text";
    xhr.setRequestHeader("Accept", "application/json");
  }
  xhr.withCredentials = requestParameters.credentials === "include";
  xhr.onerror = () => {
    callback(new Error(xhr.statusText));
  };
  xhr.onload = () => {
    if ((xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) && xhr.response !== null) {
      let data = xhr.response;
      if (requestParameters.type === "json") {
        try {
          data = JSON.parse(xhr.response);
        } catch (err) {
          return callback(err);
        }
      }
      callback(
        null,
        data,
        xhr.getResponseHeader("Cache-Control"),
        xhr.getResponseHeader("Expires"),
        xhr
      );
    } else {
      const body = new Blob([xhr.response], {
        type: xhr.getResponseHeader("Content-Type")
      });
      callback(new AJAXError(xhr.status, xhr.statusText, url.toString(), body));
    }
  };
  xhr.cancel = xhr.abort;
  xhr.send(requestParameters.body);
  return xhr;
}
function makeXMLHttpRequestPromise(requestParameters) {
  return new Promise((resolve, reject) => {
    makeXMLHttpRequest(requestParameters, (error, data, cacheControl, expires, xhr) => {
      if (error) {
        reject({
          err: error,
          data: null,
          xhr
        });
      } else {
        resolve({
          err: null,
          data,
          cacheControl,
          expires,
          xhr
        });
      }
    });
  });
}
function makeRequest(requestParameters, callback) {
  return makeXMLHttpRequest(requestParameters, callback);
}
var getJSON = (requestParameters, callback) => {
  const action = getProtocolAction(requestParameters.url) || makeRequest;
  return action(__spreadProps(__spreadValues({}, requestParameters), { type: "json" }), callback);
};
var getArrayBuffer = (requestParameters, callback) => {
  const action = getProtocolAction(requestParameters.url) || makeRequest;
  return action(__spreadProps(__spreadValues({}, requestParameters), { type: "arrayBuffer" }), callback);
};
var postData = (requestParameters, callback) => {
  return makeRequest(__spreadProps(__spreadValues({}, requestParameters), { method: "POST" }), callback);
};
var getData = (requestParameters, callback) => {
  return makeRequest(__spreadProps(__spreadValues({}, requestParameters), { method: "GET" }), callback);
};
function sameOrigin(url) {
  const a = window.document.createElement("a");
  a.href = url;
  return a.protocol === window.document.location.protocol && a.host === window.document.location.host;
}
var transparentPngUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
function arrayBufferToImage(data, callback) {
  const img = new window.Image();
  const URL = window.URL || window.webkitURL;
  img.crossOrigin = "anonymous";
  img.onload = () => {
    callback(null, img);
    URL.revokeObjectURL(img.src);
    img.onload = null;
    window.requestAnimationFrame(() => {
      img.src = transparentPngUrl;
    });
  };
  img.onerror = () => callback(
    new Error(
      "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."
    )
  );
  const blob = new Blob([new Uint8Array(data)], { type: "image/png" });
  img.src = data.byteLength ? URL.createObjectURL(blob) : transparentPngUrl;
}
function arrayBufferToImageBitmap(data, callback) {
  const blob = new Blob([new Uint8Array(data)], { type: "image/png" });
  createImageBitmap(blob).then((imgBitmap) => {
    callback(null, imgBitmap);
  }).catch((e) => {
    callback(
      new Error(
        `Could not load image because of ${e.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`
      )
    );
  });
}
var getImage = (requestParameters, callback, transformResponse) => {
  const optionFunc = (err, imgData) => {
    if (err) {
      callback(err);
    } else if (imgData) {
      const imageBitmapSupported = typeof createImageBitmap === "function";
      const transformImgData = transformResponse ? transformResponse(imgData) : imgData;
      if (imageBitmapSupported) {
        arrayBufferToImageBitmap(transformImgData, callback);
      } else {
        arrayBufferToImage(transformImgData, callback);
      }
    }
  };
  if (requestParameters.type === "json") {
    return getJSON(requestParameters, optionFunc);
  } else {
    return getArrayBuffer(requestParameters, optionFunc);
  }
};
var formatImage = (imgData, callback) => {
  const imageBitmapSupported = typeof createImageBitmap === "function";
  if (imageBitmapSupported) {
    arrayBufferToImageBitmap(imgData, callback);
  } else {
    arrayBufferToImage(imgData, callback);
  }
};
export {
  AJAXError,
  formatImage,
  getArrayBuffer,
  getData,
  getImage,
  getJSON,
  getProtocolAction,
  makeXMLHttpRequestPromise,
  postData,
  sameOrigin
};
